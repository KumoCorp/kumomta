{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"KumoMTA Documentation","text":"<p>This the is documentation site for the KumoMTA Message Transfer Agent.</p> <p>The documentation is organized into four sections:</p> <ul> <li>The Tutorial - a beginner's guide for those who are new to setting up, configuring, testing, and deploying email infrastructure.</li> <li>The User Guide - a guide for those who are familiar with email infrastructure but are new to KumoMTA and its unique features and capabilities.</li> <li>The Reference Manual - for those who are familiar with KumoMTA, and need to quickly look up syntax and examples for functions and modules.</li> <li>The FAQ - A collection of Frequently Asked Questions for quick reference.</li> <li>The Changelog - a collection of all the updates, bug fixes, and changes made to KumoMTA on a per-release basis.</li> </ul> <p>Note</p> <p>The Reference Manual will always contain the most current information on KumoMTA as it is updated with every commit. The User Guide is updated more periodically based on the Reference Manual. When using the User Guide we recommend always following its links to the Reference Manual to ensure you are up to date on any changes.</p>"},{"location":"tags/","title":"Tags","text":"<p>Find documentation grouped by tag:</p>"},{"location":"tags/#tag:aaa","title":"aaa","text":"<ul> <li>            get_acl_definition          </li> <li>            load_acl_map          </li> <li>            make_access_control_list          </li> <li>            make_http_url_resource          </li> <li>            query_resource_access          </li> <li>            set_acl_cache_ttl          </li> <li>            set_check_cache_ttl          </li> <li>            set_fall_back_to_acl_map          </li> </ul>"},{"location":"tags/#tag:bounce","title":"bounce","text":"<ul> <li>            DELETE /api/admin/bounce/v1          </li> <li>            GET /api/admin/bounce/v1          </li> <li>            POST /api/admin/bounce/v1          </li> <li>            kcli bounce          </li> <li>            kcli bounce-cancel          </li> <li>            kcli bounce-list          </li> </ul>"},{"location":"tags/#tag:config","title":"config","text":"<ul> <li>            POST /api/admin/bump-config-epoch          </li> <li>            POST /api/admin/bump-config-epoch          </li> </ul>"},{"location":"tags/#tag:debugging","title":"debugging","text":"<ul> <li>            GET /api/admin/trace-smtp-client/v1          </li> <li>            GET /api/admin/trace-smtp-server/v1          </li> <li>            GET /api/machine-info          </li> <li>            GET /api/machine-info          </li> <li>            kcli inspect-message          </li> <li>            kcli inspect-sched-q          </li> <li>            kcli set-log-filter          </li> <li>            kcli top          </li> <li>            kcli trace-smtp-client          </li> <li>            kcli trace-smtp-server          </li> <li>            log_debug          </li> <li>            log_error          </li> <li>            log_info          </li> <li>            log_warn          </li> <li>            set_diagnostic_log_filter          </li> </ul>"},{"location":"tags/#tag:filesystem","title":"filesystem","text":"<ul> <li>            glob          </li> <li>            glob          </li> <li>            open          </li> <li>            read_dir          </li> <li>            read_dir          </li> <li>            uncached_glob          </li> <li>            uncached_glob          </li> </ul>"},{"location":"tags/#tag:inject","title":"inject","text":"<ul> <li>            POST /api/inject/v1          </li> </ul>"},{"location":"tags/#tag:inspect","title":"inspect","text":"<ul> <li>            GET /api/admin/inspect-message/v1          </li> <li>            GET /api/admin/inspect-sched-q/v1          </li> <li>            GET /api/admin/ready-q-states/v1          </li> </ul>"},{"location":"tags/#tag:liveness","title":"liveness","text":"<ul> <li>            GET /api/check-liveness/v1          </li> </ul>"},{"location":"tags/#tag:logging","title":"logging","text":"<ul> <li>            Log Record          </li> <li>            POST /api/admin/set_diagnostic_log_filter/v1          </li> <li>            POST /api/admin/set_diagnostic_log_filter/v1          </li> <li>            back_pressure          </li> <li>            compression_level          </li> <li>            configure_acct_log          </li> <li>            configure_local_logs          </li> <li>            configure_log_hook          </li> <li>            filter_event          </li> <li>            headers          </li> <li>            kcli set-log-filter          </li> <li>            log_debug          </li> <li>            log_dir          </li> <li>            log_error          </li> <li>            log_info          </li> <li>            log_warn          </li> <li>            max_file_size          </li> <li>            max_segment_duration          </li> <li>            meta          </li> <li>            min_free_inodes          </li> <li>            min_free_space          </li> <li>            per_record          </li> <li>            set_diagnostic_log_filter          </li> <li>            should_enqueue_log_record          </li> </ul>"},{"location":"tags/#tag:memory","title":"memory","text":"<ul> <li>            GET /api/admin/memory/stats          </li> <li>            GET /api/admin/memory/stats          </li> <li>            Memory Management          </li> <li>            get_memory_hard_limit          </li> <li>            get_memory_low_thresh          </li> <li>            get_memory_soft_limit          </li> <li>            low_memory_reduction_policy          </li> <li>            no_memory_reduction_policy          </li> <li>            set_memory_hard_limit          </li> <li>            set_memory_low_thresh          </li> <li>            set_memory_soft_limit          </li> <li>            shrink_policy          </li> </ul>"},{"location":"tags/#tag:message","title":"message","text":"<ul> <li>            inject_message          </li> <li>            kcli inspect-message          </li> <li>            make_message          </li> <li>            object: message          </li> </ul>"},{"location":"tags/#tag:meta","title":"meta","text":"<ul> <li>            Predefined Metadata          </li> <li>            get_meta          </li> <li>            import_x_headers          </li> <li>            meta          </li> <li>            object: connectionmeta          </li> <li>            set_meta          </li> </ul>"},{"location":"tags/#tag:ops","title":"ops","text":"<ul> <li>            kcli provider-summary          </li> <li>            kcli queue-summary          </li> <li>            kcli top          </li> <li>            kcli trace-smtp-client          </li> <li>            kcli trace-smtp-server          </li> <li>            kcli xfer          </li> <li>            kcli xfer-cancel          </li> </ul>"},{"location":"tags/#tag:port","title":"port","text":"<ul> <li>            protocol          </li> <li>            remote_port          </li> <li>            smtp_port          </li> </ul>"},{"location":"tags/#tag:rebind","title":"rebind","text":"<ul> <li>            POST /api/admin/rebind/v1          </li> </ul>"},{"location":"tags/#tag:status","title":"status","text":"<ul> <li>            GET /proxy/status          </li> </ul>"},{"location":"tags/#tag:suspend","title":"suspend","text":"<ul> <li>            DELETE /api/admin/suspend-ready-q/v1          </li> <li>            DELETE /api/admin/suspend/v1          </li> <li>            GET /api/admin/suspend-ready-q/v1          </li> <li>            GET /api/admin/suspend/v1          </li> <li>            POST /api/admin/suspend-ready-q/v1          </li> <li>            POST /api/admin/suspend/v1          </li> <li>            kcli suspend          </li> <li>            kcli suspend-cancel          </li> <li>            kcli suspend-list          </li> <li>            kcli suspend-ready-q          </li> <li>            kcli suspend-ready-q-cancel          </li> <li>            kcli suspend-ready-q-list          </li> </ul>"},{"location":"tags/#tag:templates","title":"templates","text":"<ul> <li>            Template Syntax          </li> <li>            eval_template          </li> </ul>"},{"location":"tags/#tag:threadpool","title":"threadpool","text":"<ul> <li>            available_parallelism          </li> <li>            set_httpinject_threads          </li> <li>            set_logging_threads          </li> <li>            set_qmaint_threads          </li> <li>            set_ready_qmaint_threads          </li> <li>            set_readyq_threads          </li> <li>            set_signing_threads          </li> <li>            set_smtpsrv_threads          </li> <li>            set_spoolin_threads          </li> </ul>"},{"location":"tags/#tag:utility","title":"utility","text":"<ul> <li>            glob          </li> <li>            glob          </li> <li>            open          </li> <li>            read_dir          </li> <li>            read_dir          </li> <li>            uncached_glob          </li> <li>            uncached_glob          </li> </ul>"},{"location":"tags/#tag:xfer","title":"xfer","text":"<ul> <li>            POST /api/admin/xfer/cancel/v1          </li> <li>            POST /api/admin/xfer/v1          </li> <li>            POST /api/xfer/inject/v1          </li> <li>            cancel_xfer          </li> <li>            get_xfer_target          </li> <li>            kcli xfer          </li> <li>            kcli xfer-cancel          </li> <li>            module: kumo.xfer          </li> <li>            xfer          </li> <li>            xfer_in_requeue          </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<ul> <li>Unreleased Changes in The Mainline</li> <li>Release 2025.12.02-67ee9e96</li> <li>Release 2025.10.06-5ec871ab</li> <li>Release 2025.05.06-b29689af</li> <li>Release 2025.03.19-1d3f1f67</li> <li>Release 2025.01.29-833f82a8</li> <li>Release 2025.01.23-7273d2bc</li> <li>Release 2024.11.08-d383b033</li> <li>Release 2024.09.02-c5476b89</li> <li>Release 2024.06.10-84e84b89</li> <li>Release 2023.12.28-63cde9c7</li> <li>Release 2023.11.28-b5252a41</li> <li>Release 2023.08.22-4d895015 - Automation</li> <li>Release 2023.06.22-51b72a83</li> <li>Release 2023.05.10-e88ad036 - Beta 2</li> <li>Release 2023.03.31-36aa20de - Beta1</li> </ul>"},{"location":"changelog/2023.03.31-36aa20de/","title":"Release 2023.03.31-36aa20de - Beta1","text":"<p>This section will list all of the major changes that happened within this release of KumoMTA. Depending on the install environment, not all of the listed changes may apply.</p>"},{"location":"changelog/2023.05.10-e88ad036/","title":"Release 2023.05.10-e88ad036 - Beta 2","text":"<p>This section will list all of the major changes that happened within this release of KumoMTA. Depending on the install environment, not all of the listed changes may apply.</p> <ul> <li>Expose ready queue size to metrics. #30</li> <li>Fixed IPv6 lookups for domains without MX records</li> <li>kumo.configure_local_logs can now be called   multiple times to configure multiple different logging locations and   configurations.</li> <li>Added HA Proxy client support. #19</li> <li>Added HTTP delivery support. #36</li> <li>Added logging for inject and delivery types.</li> <li>Added option to force fsync per-message. #6</li> <li>Added traffic shaping policy helper. #43</li> <li>Added webhook support. #18</li> </ul>"},{"location":"changelog/2023.06.22-51b72a83/","title":"Release 2023.06.22-51b72a83","text":"<p>This section will list all of the major changes that happened within this release of KumoMTA. Depending on the install environment, not all of the listed changes may apply.</p>"},{"location":"changelog/2023.06.22-51b72a83/#breaking-changes","title":"Breaking Changes","text":"<ul> <li> <p>Handling of egress source/pool has moved from <code>define_egress_source</code> and <code>define_egress_pool</code> to <code>make_egress_source</code> and <code>make_egress_pool</code>, allowing these configurations to be loaded dynamically at runtime, removing the need for a server restart. See make_egress_source.</p> </li> <li> <p>Configuration of relay domains has been moved out of <code>start_esmtp_listener</code> into its own event, allowing these configurations to be loaded dynamically at runtime, removing the need for a server restart. See make_listener_domain.</p> </li> </ul>"},{"location":"changelog/2023.06.22-51b72a83/#enhancements","title":"Enhancements","text":"<ul> <li>spool_message_enumerated   event. #42</li> <li>Rabbit MQ/AMQP Event/Message Publishing. #31</li> <li>SOCKS5 Proxy Support. #45</li> <li>Added helper policy scripts for managing egress source/pool and listeners domains. See make_egress_source and make_listener_domain.</li> </ul>"},{"location":"changelog/2023.06.22-51b72a83/#fixes","title":"Fixes","text":"<ul> <li>Fix issue with log flushing during shutdown. #46</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/","title":"Release 2023.08.22-4d895015 - Automation","text":""},{"location":"changelog/2023.08.22-4d895015/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>kumo.configure_log_hook now requires   a name field to be set to identify which instance of a log hook is being considered   by the should_enqueue_log_record event.   This change is to support distributing logs to the traffic shaping automation   service in addition to feeding them into your own reporting infrastructure.</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/#new-traffic-shaping-automation","title":"New: Traffic Shaping Automation","text":"<ul> <li>The <code>shaping.toml</code> file now supports automation rules. See the UserGuide for information on how to deploy this feature.</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>Calling   kumo.configure_redis_throttles   now also enables redis-based shared connection limits. #41</li> <li>kumo.make_egress_path <code>max_deliveries_per_connection</code> now defaults to <code>1024</code> rather than unlimited.   Specifying unlimited deliveries is no longer supported as part of shared   connection limit lease fairness. #41</li> <li>Added   message:remove_all_named_headers.   Thanks to @postmastery! #70</li> <li>Ready queue names now factor in the delivery protocol, making it easier to vary   the protocol by eg: tenant or campaign while keeping the domain the same.   You will notice a suffix like <code>@smtp</code> on the end of queue names in metrics   and in the <code>site_name</code> field of log records as a result of this change.</li> <li>It is now more convenient to do smart hosting using the new smtp protocol <code>mx_list</code>   in kumo.make_queue_config.</li> <li>Introduced new <code>routing_domain</code> meta value (see predefined   values) which allows you to override the recipient   domain for routing/delivery, without blending scheduled queues.</li> <li>New kumo.cidr.make_map function for   building CIDR lookup tables/mappings.</li> <li>The listener_domains policy   helper   now supports <code>relay_from_authz</code> to allow listing out authorization identities   for which relaying from a particular sending domain is permitted.</li> <li>The kumo.digest module for computing SHA   digests of strings and other data.</li> <li>The kumo.encode module for encoding/decoding   base32, base64 and hex strings.</li> <li>kumo.dns.configure_resolver for   adjusting DNS resolver configuration.</li> <li>kumo.dkim.ed25519_signer now also   supports loading signing keys that are in PEM encoded PKCS8 format.</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/#fixes","title":"Fixes","text":"<ul> <li>Loading secrets from HashiCorp Vault failed to parse underlying json data into   a byte array.</li> <li><code>kumo.reject(421, ...)</code> didn't disconnect the incoming session. #79</li> <li><code>kumo.reject</code> in <code>smtp_server_message_received</code> could still produce a <code>250 ok</code>   after the rejection response.</li> </ul>"},{"location":"changelog/2023.11.28-b5252a41/","title":"Release 2023.11.28-b5252a41","text":""},{"location":"changelog/2023.11.28-b5252a41/#breaking-changes","title":"Breaking Changes","text":"<p>None known</p>"},{"location":"changelog/2023.11.28-b5252a41/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>New RFC-conformance options are available to control server behavior   when receiving messages that are non-conformant:<ul> <li>invalid_line_endings #22 #23</li> <li>line_length_hard_limit #25</li> <li>message:check_fix_conformance #17 #24 #26</li> </ul> </li> <li>HTTP injection API will now parse and re-encode the message content to ensure   that it has appropriate transfer encoding applied when <code>content</code> is set to a   string, rather than using the builder variant of the API.</li> <li>Preliminary support for   MTA-STS. It defaults to   enabled. See   make_egress_path for   more details. At this time, we do not support   TLSRPT.</li> <li>Preliminary support for   DANE. It defaults to   disabled because it requires additional configuration to enable DNSSEC. See   make_egress_path for   more details. At this time, we do not support   TLSRPT.</li> <li>The DKIM   helper   now allows setting <code>body_canonicaliation</code> and <code>header_canonicalization</code>.   Thanks to @cai-n! #81</li> <li>msg:dkim_verify() and   msg:add_authentication_results() #82</li> <li>You may now use <code>log_record</code> to refer to the entire log record when using   templated log files. See   kumo.configure_local_logs for   more information.</li> <li>You may now specify an optional <code>segment_header</code> and optional <code>filter_event</code>,   when customizing local logs.   See kumo.configure_local_logs   for more information.</li> <li>Delivery log records now include information about the TLS cipher, protocol   version and peer subject name for SMTP deliveries that used TLS</li> <li>New regex_set_map type for efficiently   matching multiple regular expressions in a single search operation and returning   an associated value.</li> <li>New   smtp_client_rewrite_delivery_status   event to enable rewriting SMTP client status codes.</li> <li>minijinja templates now provide date/time formatting filters and globals   via minijinja_contrib.   Thanks to @cai-n! #91</li> <li>It is no longer necessary to call <code>shaper.get_queue_config</code> when using the shaping   helper together with TSA.  You should change your config from:</li> </ul> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  local cfg = shaper.get_queue_config(domain, tenant, campaign)\n  if cfg then\n      return cfg\n  end\n\n  -- Do your normal queue config handling here\nend)\n</code></pre> <p>to:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  -- Do your normal queue config handling here\nend)\n</code></pre> <ul> <li>It is no longer necessary to register <code>shaper.should_enqueue_log_record</code> when using the shaping   helper together with TSA.  You should remove this line from your config:</li> </ul> <pre><code>-- Remove this next line\nkumo.on('should_enqueue_log_record', shaper.should_enqueue_log_record)\n</code></pre> <ul> <li>New pre_init event to aid in building optional   modular lua helpers.</li> <li>log records now only log meta values which are non-null. Thanks to @cai-n! #94</li> <li>Admin bounces now have the option to suppress generation of <code>AdminBounce</code> log   records. #75</li> </ul>"},{"location":"changelog/2023.11.28-b5252a41/#fixes","title":"Fixes","text":"<ul> <li>HTTP injection API did not expand templating in <code>From</code>, <code>Reply-To</code> or   <code>Subject</code> headers unless they were set in the additional headers object</li> <li>Allow optional spaces after the colon in <code>MAIL FROM:</code> and <code>RCPT TO:</code>. #76</li> <li>Missing 334 response to clients using multi-step SMTP <code>AUTH PLAIN</code></li> <li>Messages that require \"dot stuffing\" could hang an outgoing SMTP session   and tie up a connection until the data and/or data-dot timeout was reached.</li> <li>DKIM Signature headers with a long list of signed headers would wrap on   hyphens instead of colons, which caused problems with some but not all   verifiers.</li> </ul>"},{"location":"changelog/2023.12.28-63cde9c7/","title":"Release 2023.12.28-63cde9c7","text":"<p>Note</p> <p>While the release is dated <code>2023.12.28</code>, that date reflects the date of the last change to the code, rather than the date that the release was cut and published. This release was published <code>2024.01.03</code>.</p>"},{"location":"changelog/2023.12.28-63cde9c7/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/2023.12.28-63cde9c7/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>You may now use arbitrary bounce classification labels when defining bounce classification rules. #98</li> <li>queue helper: Added <code>setup_with_options</code> method that allows skipping the registration of the   <code>get_queue_config</code> event handler. This helps when building a more complex configuration   policy, such as using the rollup helper. Thanks to @cai-n! #101</li> <li>You may now use simple suffix based wildcards like <code>X-*</code> to match header   names to capture in log records. See   kumo.configure_local_logs. #74</li> </ul>"},{"location":"changelog/2023.12.28-63cde9c7/#fixes","title":"Fixes","text":"<ul> <li>MTA-STS policy may fail to match due to trailing periods in mx host names</li> <li>Assigning <code>nil</code> via <code>msg:set_meta</code> would return a userdata wrapper around the   underlying json <code>null</code> value when <code>msg:get_meta</code> was called for that key.  We   now map that as <code>nil</code>.</li> <li>Various duration options (such as <code>idle_timeout</code>) once again accept bare   integer values to mean that number of seconds as stated in the docs.   Previously, you would have to use a string like <code>\"10 seconds\"</code>. Now you can   simply write <code>10</code>.  This regressed long long ago, but is now resolved. #108</li> <li>ARF parser now accepts historic feedback reports using version <code>0.1</code> and   the deprecated <code>Received-Date</code> header.</li> </ul>"},{"location":"changelog/2024.06.10-84e84b89/","title":"Release 2024.06.10-84e84b89","text":""},{"location":"changelog/2024.06.10-84e84b89/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>We now normalize line breaks in SMTP client responses into spaces, to make it   a little easier to deal with multi-line responses in both TSA automation,   response rewriting and bounce classification. Thanks to @cai-n! #157</li> <li>We now also strip the enhanced status code prefix from each subsequent line   of multi-line responses, rather than just the first line. This may influence   your classification or TSA automation regexes.  For example, for a response   like <code>500-5.5.5 foo\\n500 5.5.5 bar</code> we would previously represent that   with a logged <code>response.content</code> value of <code>foo\\n5.5.5 bar</code>, but will now   encode it as <code>foo bar</code>. See #157 for more context.</li> </ul>"},{"location":"changelog/2024.06.10-84e84b89/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>We now provide pre-built ARM packages for <code>amazonlinux:2023</code> and   <code>Ubuntu 22.04</code>.</li> <li>We now provide a pre-built ARM Docker container.  </li> <li>Added a default timeout of 60 seconds to the HTTP client returned from   kumo.http.build_client.   Added request:timeout()   method to explicitly set a timeout value.</li> <li>You may now list multiple <code>regex</code>s and/or multiple <code>action</code>s for TSA rules   by using an array in your toml file. Single values are still supported. #99</li> <li>Added over_sign   optional to easily enabled DKIM over-signing to protect your messages   against replay attacks. The same option can be set for the ed25519_signer   as well. #111</li> <li>Updated RocksDB from 8.1 to 8.10</li> <li>Slightly relaxed the MIME parser so that we can tolerate non-conforming 8-bit   message bodies with missing transfer encoding when all we need is to parse   headers. The invalid messages will trigger <code>NEEDS_TRANSFER_ENCODING</code> when   using   msg:check_fix_conformance()   to validate messages, but won't cause header parsing to fail in general.   These non-compliant messages will be parsed (or fixed) using a lossy decode   to UTF-8 that will remap invalid bytes to <code>U+FFFD</code> the Unicode Replacement   Character.</li> <li>Added <code>max_message_rate</code> option to   kumo:make_queue_config   to configure the rate at which a given Scheduled Queue can feed   into the Ready Queue.</li> <li>Added   request_body_limit   option to raise the default HTTP request size, which is useful when   performing HTTP based injection with large message payloads.</li> <li>It is now possible to use <code>protocol</code> in the <code>queues.toml</code> lua helper   configuration file. Thanks to @aryeh! #155</li> <li>The TSA <code>Suspend</code> action will now generate suspensions that are visible   via the HTTP API and kcli utility, and that will take effect in realtime.</li> <li>TSA now supports <code>SuspendTenant</code> and <code>SuspendCampaign</code> actions that allow   reacting to source-domain-specific tempfails. These will also be visible   via the HTTP API and kcli utility, and also take effect in realtime.</li> <li>New glob,   read_dir and   uncached_glob filesystem functions.   #161</li> <li>New kumo.api.inject.inject_v1 lua   function for constructing and injecting arbitrary messages via policy. #102</li> <li>4xx and 5xx rejections made by the SMTP server are now logged as <code>Rejection</code>   log records. #88</li> <li>New msg:set_data,   msg:append_text_plain,   msg:append_text_html message   methods for amending the message content, which can be used to inject   tracking pixels. #120</li> <li><code>kcli bounce</code> (and the underlying bounce HTTP   API) no longer wait for the   contents of matching scheduled queues to be removed from the spool. This   reduces contention in the system for large queues, but means that the stats   returned to the initial request will generally be lower than in previous   releases. You can use <code>kcli bounce-list</code> or the corresponding bounce HTTP   API to retrieve the totals   asynchronously.</li> <li>kumo.memoize now includes thundering herd   protection, which constrains the concurrency of the cache population function   when there is a cache miss.</li> <li>redis.open now also supports a <code>connect_timeout</code>   option. #168</li> <li>Added <code>kcli top</code> command for watching system status from the comfort of   your terminal.</li> <li>The Prometheus Metrics Endpoint now supports   an optional <code>prefix</code> parameter to rewrite metrics names with a prefix.   Thanks to @cai-n! #179</li> </ul>"},{"location":"changelog/2024.06.10-84e84b89/#fixes","title":"Fixes","text":"<ul> <li>The <code>delivered_this_connection</code> counter was incorrectly double-counted for   SMTP sessions, effectively halving the effective value of   <code>max_deliveries_per_connection</code>.</li> <li>msg:set_scheduling wouldn't take   effect until after the first transient failure.</li> <li>Re-run the ready queue maintainer immediately after closing a connection   due to reaching the <code>max_deliveries_per_connection</code>, so that new connection(s)   can be established to replace the one that just closed. Previously, we would   only do this once every minute. #116</li> <li>The <code>smtp_client_rewrite_delivery_status</code> event could trigger with incorrect   scheduled queue name components.</li> <li>webhooks and other lua delivery handlers didn't reuse connections correctly.   Thanks to @cai-n! #135</li> <li><code>OOB</code> and <code>ARF</code> reports were incorrectly logged as <code>Reception</code> records</li> <li><code>OOB</code> reports did not respect <code>headers</code> and <code>meta</code> configured in the logger</li> <li>MIME Parser would discard whitespace from improperly encoded <code>message/rfc822</code>   parts when rebuilding messages.</li> <li>proxy-server didn't actually bind to the requested source address</li> <li><code>listener_domains.lua</code> helper didn't always fallback to full wildcard/default   (<code>*</code>) entries correctly. #128</li> <li>smtp client did not always wait for the full extent of the idle timeout for   new messages before closing the connection.</li> <li>Potential deadlock on systems with very low core counts when MTA-STS is enabled,   and sending to domain(s) with an MTA-STS policy.</li> <li>If a TSA rule suspends a ready queue in response to a 421-before-MAIL-FROM,   the contents of the corresponding ready queue could get stuck</li> <li>When <code>log_arf</code> or <code>log_oob</code> are set to true with <code>relay_to=false</code>, we now return   a 550 error response for messages that are not ARF or OOB reports.   Previously, we would return a 250 response and silently drop the message in this case,   which gave the false impression that it was accepted for relaying.</li> <li>Large <code>connection_limit</code> values combined with large ready queues could result in   more connections than necessary being opened.</li> <li>A client issuing RCPT TO outside of a transaction could cause the service to panic.</li> </ul>"},{"location":"changelog/2024.09.02-c5476b89/","title":"Release 2024.09.02-c5476b89","text":""},{"location":"changelog/2024.09.02-c5476b89/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>None</li> </ul>"},{"location":"changelog/2024.09.02-c5476b89/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>Pattern matching rollups have been introduced in the shaping helper to allow for the definition of Providers, collecting together multiple site names when a given MBP has inconsistent MX patterns.</li> <li>The kumomta-dev container   image is now   a multiarch image, supporting both <code>linux/amd64</code> and <code>linux/arm64</code>   architectures.  Simply use <code>docker pull ghcr.io/kumocorp/kumomta-dev:latest</code>   to get the appropriate architecture.</li> <li>Split out the banner waiting portion of   connect_timeout into   a new banner_timeout   option to make it easier to manage the system behavior if, for example, the   connection is blocked by a firewall. You can now set the connection timeout   to a smaller value while keeping the banner timeout at a more RFC-compliant,   longer, value. #196</li> <li>New kcli trace-smtp-client   diagnostic command for observing outbound SMTP sessions. #87</li> <li>New Extended configuration validation mode. #211</li> <li>New kumo.regex and   kumo.string lua modules. #220</li> <li>New <code>kcli rebind</code> and   /api/admin/rebind/v1 HTTP   endpoint to allow moving/rebinding messages from one scheduled queue to   another. There is an optional corresponding   rebind_message event for more   advanced rebinding logic. #209</li> <li>Moved JSON and TOML functions into a new   kumo.serde module. Those functions are   also still available under the <code>kumo</code> module for backwards compatibility   sake, but will be removed in a future release. You should standardize on the   new <code>kumo.serde</code> module name moving forwards.</li> <li>Added YAML serialization/deserialization functions to   kumo.serde.</li> <li>You may now run <code>kumod --validate</code> to perform extended validation checks   of the helper configuration in your policy. This can be performed offline/concurrently   with a running kumod. The output is human readable. The exit code will   be 0 when no validation errors are detected, non-zero otherwise. #211</li> <li><code>Rejection</code> log records now capture the triggering incoming SMTP command   line, or, in the case of the <code>technical difficulties</code> error message,   the stack trace of the triggering issue.  This information is available   in <code>log_record.response.command</code>.</li> <li>Add explicit <code>close</code> method to AMQP, HTTP, Kafka and SQLite client objects.</li> <li>Added UUID functions in a new kumo.uuid   module.</li> <li>SMTP client log records now include the <code>source_address</code> in addition to   the <code>egress_pool</code> and <code>egress_source</code> that were already present in the   record. <code>source_address</code> includes proxy server information. #40 #154</li> <li>Improved diagnostics around connectivity issues in KumoProxy</li> <li>New TLS related options for   kumo.make_egress_path:   <code>tls_prefer_openssl</code>, <code>openssl_cipher_list</code>, <code>openssl_cipher_suites</code>,   <code>openssl_options</code>, <code>rustls_cipher_suites</code>.</li> <li>Improved granularity of scheduled queue maintainer wakeups when small   a <code>retry_interval</code> is configured. Previously this was fixed at 1 minute,   but now it will scale to smaller values.</li> <li>proxy-server: added <code>--no-splice</code> option to opt out of using <code>splice(2)</code>   on Linux. Switch to using <code>tokio::io::copy_bidirectional</code> for non-splice mode.   Switch to using <code>tokio_splice::zero_copy_bidirectional</code> for splice mode.</li> <li>Add <code>/api/check-liveness/v1</code> API endpoint to determine whether the KumoMTA    node is live and ready to receive messages.</li> <li>Updated redis crate to 0.26, which improves connection management and pooling.</li> <li>Reduced latency during shutdown. Connections that are being attempted to   unreachable destinations no longer block shutdown until they timeout, and   are instead terminated immediately.</li> <li>Parallelize DNS lookups to improve latency when validating shaping configuration</li> <li>TSA log hook now has an option to match rules on the client side before   deciding to send a record to the daemon, reducing IO pressure on the spool   and bandwidth between the MTA and the TSA daemon, at the cost of some CPU   utilization. This defaults to enabled but can be disabled by setting   <code>pre_filter = false</code> in the call to <code>setup_with_automation</code>.</li> <li>New   max_connections   option to set a limit on the number of concurrent incoming connections   permitted to a given listener. This defaults to <code>32768</code>. A new   <code>total_connections_denied</code> counter is increment whenever this limit is hit,   and whenever a connection is rejected due to being over the memory limit.</li> <li>HTTP requests made from a trusted host that set an Authorization header will   now take the authorization information from the header. Previously the   authentication handling would stop as soon as we recognized the trusted   source IP. Either way, the request always did and will still continue   (assuming that the auth header is valid).</li> <li>Improved the performance of the bounce classifier by exposing configurable   thread pool and caching options.</li> <li>configure_local_logs and   define_spool now both allow specifying   the minimum storage space and inodes required for healthy operation. The   usage will be periodically monitored and the system will begin rejecting new   messages when the available storage falls below the minimum, until it   recovers. Usage is exported via prometheus metrics. The default minimum level   is <code>10%</code>.</li> <li>Scheduled queue configuration refreshes are now performed sequentially by   a dedicated configuration refresh task. In prior releases they could be   performed concurrently by multiple tasks running in the qmaint pool.   This change reduces overhead from speculative processing of config changes,   especially when there are very many scheduled queues.</li> </ul>"},{"location":"changelog/2024.09.02-c5476b89/#fixes","title":"Fixes","text":"<ul> <li>Using <code>expiration</code> in a DKIM signer would unconditionally raise an error and   prevent reception of the incoming message.</li> <li>Invalid structured headers, such as Message-ID, in combination with other message   body conformance issues could cause   msg:check_fix_conformance to   raise an error instead of fixing the issue. #216</li> <li>Swapped retry-after/reset-after results, and increased timestamp precision   when using cluster-backed   throttles. Thanks to @cai-n!   #217</li> <li>Didn't expand the requested SASL mech when responding <code>504 5.5.4 AUTH {sasl_mech}   not supported</code> to unsupported authentication mechanisms.</li> <li>Delayed messages were scheduled 1-step further along the exponental backoff schedule   than intended; rather than being initially delayed for 20 minutes, they would be   delayed for 40 minutes.</li> <li>MTA-STS: failed to load the policy for some sites due to a redirect caused   by a trailing dot in the policy domain</li> <li>redis cluster: <code>could not acquire connection lease: An error was signalled by   the server</code> with some redis cluster deployments when using <code>kumo.configure_redis_throttles</code>.</li> <li>bounce classifier: when multiple rules can match the same input, the   resultant classification is now \"won\" by the rule that was loaded first from   the earliest containing file. Previously, the order would be perturbed by the   name of the classification, preferring to match in alphabetical order of the   classification name. So if you had an \"A\" classification and a \"B\"   classification with the same rule, the \"A\" classification would be the   result, even if the \"B\" rule was the first one listed in your classification   data file(s).</li> <li>Changing the <code>max_ready</code> value for a ready queue no longer requires waiting for   the queue to be reaped before it will take effect.</li> <li>When connecting to single-node redis, the username and password were ignored.</li> <li><code>max_segment_duration</code> for log files was only processed in idle periods.</li> <li>log hooks only partially respected the <code>back_pressure</code> parameter, which could   leave to more system pressure (higher RAM and larger number of concurrent   tasks) in overload scenarios.</li> <li>Improved Content-ID header parsing conformance in   msg:check_fix_conformance. #259</li> </ul>"},{"location":"changelog/2024.11.08-d383b033/","title":"Release 2024.11.08-d383b033","text":""},{"location":"changelog/2024.11.08-d383b033/#breaking-changes","title":"Breaking Changes","text":"<ul> <li><code>kcli bounce-list</code> no longer returns json output by default. Use <code>--json</code>   to explicitly request json output.</li> <li>The filename format for log file segments now includes fractional seconds   so that there is no chance of file naming collision when using aggressively   small values for <code>max_file_size</code> or <code>max_segment_duration</code>.</li> <li>TSA rules will no longer by default match internally generated failure   responses, that is, those that begin with the text <code>KumoMTA internal:</code>.   This prevents accidentally triggering cyclical behavior in the case where   you have a very lenient regex for a rule that triggers a suspension.   If you have rules that you wish to intentionally match these internal   messages, you can mark the automation entry with <code>match_internal = true</code>   to allow the match to be considered.</li> <li>The SMTP client will now look for the system CA-certificate bundle   when making connections. If no CA-certificate bundle is present, it will   have no available trust store and will not be able to successfully establish   TLS sessions. Previously, we used a bundled hard-coded, non-extensible,   copy of the Mozilla CA certificate store. You must therefore ensure that   you install the <code>ca-certificates</code> package for your system, or otherwise   contrive to populate the system certificate store.</li> </ul>"},{"location":"changelog/2024.11.08-d383b033/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li> <p>Queue and Egress configs can now be set to work in a mode where they refresh   when the underlying configuration files have changed, rather than always   reloading on a schedule. This makes a difference for sites with many queues.   This mode is used for the shaping and queue helpers. See   Configuration Monitoring   for more information about this.</p> </li> <li> <p>Improved performance of <code>/metrics</code> and <code>/metrics.json</code> endpoint generation;   these endpoints now stream data rather than buffering and sending to the   client. This makes a big difference for systems with over 1 million queues.</p> </li> <li> <p><code>kcli top</code> and <code>kcli queue-summary</code> now use streaming mertrics parsers to   improve latency with systems with over 1 million queues.</p> </li> <li> <p>HTTP clients can now opt-in to compressed responses by setting their   <code>Accept-Encoding</code> header. We support <code>gzip</code> and <code>deflate</code> compression.   Compression is set to <code>Fastest</code> rather than <code>Best</code>, which produces good   results without costing too much CPU or request latency.  We do not   support compressed bodies at this time.</p> </li> <li> <p>Optimized per-message overheads in the scheduled queue, reduced the memory   utilization by 112 bytes per message.</p> </li> <li> <p>Changed the default queue   strategy to   <code>SingletonTimerWheel</code>.</p> </li> <li> <p><code>kcli trace-smtp-client</code> and <code>kcli trace-smtp-server</code> both have some new   options: <code>--terse</code> to make it easier to get the sense of the flow of messages   without seeing all of the message body data, <code>--only-new</code> to trace only sessions   for which the tracer client has observed the session opening, and   <code>--only-one</code> to trace just a single session.</p> </li> <li> <p>The HTTP injection API now supports an   optional <code>deferred_spool</code> parameter that allows deferring writing the   message(s) spool for a given send attempt, <code>deferred_generation</code> for quickly   accepting a batch for asynchronous generation, and you can control a rate   limit for ingress using   kumo.set_httpinject_recipient_rate_limit.</p> </li> <li> <p>We now randomize the set of hosts within a given MX preference level when   computing the connection plan for an individual session. This helps to   probablistically load balance across the advertised hosts for the destination.</p> </li> <li> <p>The /api/admin/bounce/v1 no longer   returns any partial statistics from the bounce. On systems with very large   numbers of queues, returning data in this context would take too long. The endpoint   will now return immediately and report the <code>id</code> of the bounce entry, but no   other statistics.</p> </li> <li> <p><code>kcli bounce-list</code> now summarizes the bounce information in a human readable   format by default, rather than showing the underlying json data as we did   in previous releases.</p> </li> <li> <p>The log_hooks helper now supports batching using the new <code>batch_size</code> parameter   and <code>send_batch</code> method. See the example</p> </li> <li> <p>Added <code>proxy_connection_failures</code> and <code>bind_failures</code> counters to track   the number of times that kumod either failed to connect to an egress proxy   server, or failed to directly bind a source address. Both of these events   typically indicate a severe issue with the local infrastructure, either in   terms of a configuration error or production service availability.</p> </li> <li> <p>The <code>validate-shaping</code> utility and underlying   kumo.shaping.load function now support   options to control whether individual checks should be warnings, errors or be   ignored.  The shaping helper allows specifying these options as   <code>load_validation_options</code> (for regular load-time checks) and   <code>validation_options</code> (for <code>--validate</code> mode).</p> </li> <li> <p>The requeue_message event now also   receives the SMTP response that led to the requeue event being triggered.</p> </li> <li> <p>The bounce classifier will now automatically reload when the configuration   epoch is updated. #298</p> </li> <li> <p>Spool enumeration completion no longer prevents the reception of new messages.   The spool does need to have started before messages will be received, which   means that there is still a very small window during startup where the liveness   check and SMTP sessions can turn away incoming connections.</p> </li> <li> <p>The dkim helper now supports passing the <code>expiration</code> value through to   the underlying signer.</p> </li> <li> <p>HTTP injection now includes control over the   trace_headers, which now   default to including the supplemental trace header for   FBL/ARF processing, but not including the Received header.   These parameters are set per-request.</p> </li> <li> <p>Added   remember_broken_tls   option to streamline dealing with sites with broken TLS.</p> </li> <li> <p>We now also flush/purge rocksdb memtables/caches,   memoize and other TTL based LRU caches when   the system is in a low-memory state.</p> </li> <li> <p>New SPF validation function,   kumo.check_host. Thanks to @djc! #83</p> </li> </ul>"},{"location":"changelog/2024.11.08-d383b033/#fixes","title":"Fixes","text":"<ul> <li> <p><code>kcli trace-smtp-client</code> and <code>kcli trace-smtp-server</code> would always report   <code>0ns</code> for sessions for which we had not observed the session opening. Now we   will assume a start time time of the first record observed for a session, so   that some sense of relative time can be gleaned from the trace output.</p> </li> <li> <p>When using the dkim helper and splitting the configuration   across multiple files, a missing <code>domain</code> or <code>base</code> configuration section in   any individual file would raise a validation error.</p> </li> <li> <p>Punycode encoded domain names would resolve to the unicode representation of   the domain name internally, and in the case of domains with no explicit MX   records, the fallback record that was synthesized from the domain name would   also be encoded in the unicode representation.</p> </li> <li> <p>TSA SuspendTenant rules didn't respect the duration specified in the rule,   instead defaulting to 5 minutes.</p> </li> <li> <p>Suspensions didn't apply to every case where a message could enter the ready   queue.  We now check both as part of entering the ready queue and as a last   moment check when a message is popped off the ready queue. We will now log a   <code>TransientFailure</code> log record whenever a message matches a scheduled queue   suspension. In addition, suspensions will now always respect the normal   exponential backoff retry schedule instead of clumping together when the   suspension expires. #290 #293</p> </li> <li> <p>During a low memory condition, we'd only release the body and metadata memory   if they had previously been saved, when the intent was that we should   explicitly save it and then drop it.  This meant that running with   deferred-spooling or otherwise modifying the message or its metadata after   reception could result in messages that wouldn't be eligible to shrink   until after their next attempt. In addition, we could repeatedly try this   each time the readyq maintainer would trigger during a memory shortage.</p> </li> <li> <p>The requeue_message event was   internally named <code>message_requeued</code>, contrary to the documentation. This has   now been corrected. #236</p> </li> <li> <p>The throttle_insert_ready_queue event   was not correctly registered and would never trigger.</p> </li> <li> <p>A MIME message rebuild could improperly re-encode unicode Subject lines into   a series of quoted-printable encoded-words, causing spaces between those   words to be effectively discarded when the subject is decoded.  The header   re-encoding will now prefer to re-assemble unstructured fields as a single   encoded-word to avoid this.</p> </li> <li> <p>Using <code>msg:append_text_html()</code> or <code>msg:append_text_plain()</code> on a mime part   that had a pre-existing <code>Content-Transfer-Encoding</code> header wouldn't remove   the header. If the original encoding was <code>base64</code> and the new form of the   part was written out in <code>quoted-printable</code> then the resulting mime part would   be ambiguous to decode.</p> </li> <li> <p>An error raised in a custom <code>get_queue_config</code> event handler during reception   wouldn't remove the message from the spool, but would report a transient   failure back to the injector, which could lead to it sending a message again.</p> </li> </ul>"},{"location":"changelog/2025.01.23-7273d2bc/","title":"Release 2025.01.23-7273d2bc","text":""},{"location":"changelog/2025.01.23-7273d2bc/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/2025.01.23-7273d2bc/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li> <p>Log records now include an optional <code>session_id</code> field to correlate   messages received or sent (depending on the type of the record) on   the same connection/session. #316</p> </li> <li> <p>Updated embedded libunbound to 1.22</p> </li> <li> <p>Use more compact representation of ResolvedAddress in logs. Instead of   showing something like <code>ResolvedAddress { name: \"some.host.\", addr: 10.0.0.1 }</code>   we now display it as <code>some.host./10.0.0.1</code> which is a bit easier to   understand and occupies less space in the logs.</p> </li> <li> <p>We will now trigger the   requeue_message event in the   case of an error resolving the ready queue, such as DNS related errors.   This gives an opportunity to rebind or reject messages which are   experiencing persistent DNS resolution issues. #319</p> </li> <li> <p>New <code>dns_mx_resolve_in_progress</code>, <code>dns_mx_resolve_status_ok</code>,   <code>dns_mx_resolve_status_fail</code>, <code>dns_mx_resolve_cache_hit</code>,   <code>dns_mx_resolve_cache_miss</code> metrics that reflect the status of MX   resolution. These are available via the metrics endpoints.</p> </li> <li> <p>maildir   can now specify file and directory modes. #109</p> </li> <li> <p>maildir   now supports template expansion in the <code>maildir_path</code>. #109</p> </li> <li> <p>TSA now supports <code>\"Bounce\"</code>, <code>\"BounceTenant\"</code> and <code>\"BounceCampaign\"</code> actions   which create bounces for scheduled queues which match the   domain/tenant/campaign of the triggering event. #272</p> </li> <li> <p>Ready Queues now use intrusive lists through the internal Message structure,   which keeps memory usage for the ready queues bounded to <code>O(number-of-messages)</code>   rather than the previous <code>O(number-of-ready-queues * max_ready)</code>.</p> </li> <li> <p>Provider match rules now also support exactly matching MX hostnames via the   new <code>HostName</code> entry.</p> </li> <li> <p>kcli queue-summary will now show connection limit and connection rate throttled   status effects as part of the ready queue information, making it easier to   determine when a (potentially shared with multiple nodes) limit might be   responsible for messages in the ready queue. There is a corresponding   ready-q-states API   endpoint that can be used to retrieve this same information.</p> </li> <li> <p>connection_limit   may now be explicitly set to be local to the kumod instance, even if   redis-sharing is enabled, by using a string value like <code>\"local:100\"</code>.</p> </li> <li> <p>New kafka   client:send_batch   method for submitting a batch of kafka messages and waiting for the results   of the complete batch. Thanks to @cai-n! #324</p> </li> <li> <p>The Ready Queue maintainer will now perform blocking acquisition of connection   limit leases in order to reduce latency when the limit is contended. For   Redis-backed limits the \"blocking\" is really a periodic poll every 3 seconds.</p> </li> <li> <p>The smtp_server_ehlo event now   supports editing the list of ESMTP extensions that are reported by the   SMTP listener in response to the EHLO command.</p> </li> <li> <p>You may now configure an egress path to   use_lmtp to talk to an LMTP   implementation.  The   mx_list in the queue   configuration can now also be set to a unix domain socket address to   facilitate this. #267</p> </li> <li> <p>New enable_rset and   enable_pipelining   options to influence the use of SMTP protocol features.</p> </li> <li> <p>New   opportunistic_tls_reconnect_on_failed_handshake   option.</p> </li> </ul>"},{"location":"changelog/2025.01.23-7273d2bc/#fixes","title":"Fixes","text":"<ul> <li> <p>When <code>enable_tls</code> is set to <code>Required</code> or <code>RequiredInsecure</code>, ignore the   effect of <code>remember_broken_tls</code>.  This makes it easier to set a default value   of <code>remember_broken_tls</code> without having to remember to special case it for   sites where TLS is required, or sites that use MTA-STS or DANE to advertise   that it should be required.</p> </li> <li> <p>When configuring the unbound resolver, the port number was not passed through   for the upstream DNS server, so non-standard ports would not be respected.   #314</p> </li> <li> <p>Expiration was checked only when incrementing the number of attempts, or when   spooling in.  There are some situations where a message can be delayed and   re-queued without incrementing the number of attempts, which meant that some   messages could linger in the queues until they are actually attempted again.</p> </li> <li> <p>Running <code>validate-shaping</code> without passing any files to validate would report   <code>OK</code> instead of telling you that you should have passed one or more file names.</p> </li> <li> <p>Some messages could sometimes get delayed slightly longer than intended when   using TimerWheels (the default) when moving from the scheduled queue to   the ready queue.</p> </li> <li> <p>The <code>get_listener_domain</code> event handler results were incorrectly cached globally   which allowed a given source IP which successfully authenticated in one session   to appear authenticated for other separate connections made by that same IP   to/from the same domain, within the same 60 second period. #320</p> </li> <li> <p>TSA daemon would not report the list of scheduled queue suspensions in the   initial websocket request made by a (re)connecting client.</p> </li> <li> <p>Certain providers configurations with multiple <code>MXSuffix</code> rules and multiple   candidate MX hosts might not match in cases where they should.</p> </li> <li> <p>Connection establishment rate for a ready queue could be constrained to   1-new-connection-per-10-minute period if that ready queue had no new messages   being added to it and if a connection limit had prevented new connections   being opened.</p> </li> <li> <p>When using the HTTP injection API to construct a mailbox using UTF-8 characters,   the resulting From header could wrap in an undesirable location and produce   an invalid From header that fails to parse.</p> </li> <li> <p>When using the HTTP injection API to construct a mailbox with a <code>name</code> containing   the <code>@</code> sign, the resulting From header did not enclose the <code>name</code> portion   in double quotes, producing an invalid From header that failed to parse.</p> </li> <li> <p>When using the HTTP injection API to construct a subject header with a non-space   UTF-8 sequence containing the byte 0x20, the quoted printable encoder would   confuse that sequence with a space and produce an invalid output sequence.</p> </li> <li> <p>Changing the egress pool associated with a scheduled queue would not actually   take effect until the scheduled queue aged out (eg: was idle for 10 minutes).</p> </li> <li> <p>RFC3464 reports that used a transfer encoding for their delivery-status parts   were not parsed successfully into OOB log records.</p> </li> <li> <p>TSA daemon would not apply multiple <code>SetConfig</code> actions that were present   in an automation rule, and would instead only apply the first listed rule.</p> </li> <li> <p>Egress pools didn't allow de-serializing definitions that had an empty set   of sources.</p> </li> </ul>"},{"location":"changelog/2025.01.29-833f82a8/","title":"Release 2025.01.29-833f82a8","text":""},{"location":"changelog/2025.01.29-833f82a8/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>Added kcli inspect-sched-q command. #231</li> <li>Added   reconnect_strategy   egress path option to control what happens with a session that experiences   a disconnection during message sending.</li> <li>Improved robustness of kcli   trace-smtp-server and kcli   trace-smtp-client on busy servers.</li> <li>kafka client can now process non-UTF8 binary payloads. Thanks to @cai-n! #328</li> <li>Exposed the <code>max_burst</code> throttle parameter to the throttle parser. This   functionality was always present, it just wasn't configurable. See the   kumo.make_throttle docs for the revised   throttle specification.</li> </ul>"},{"location":"changelog/2025.01.29-833f82a8/#fixes","title":"Fixes","text":"<ul> <li>Regression with the recent RSET optimizations: we didn't issue an RSET if a send   failed partway through, leading to issues with the connection state.</li> <li>SMTP Client could sometimes get stuck attempting to process a series of messages   on a connection that had previously been closed.</li> <li>Potential cache thrashing issue with <code>remember_broken_tls</code> could lead to a larger   number of connection attempts to sites with broken TLS.</li> <li>The RFC3464 parser could fail to parse certain <code>Arrival-Date</code> headers. Thanks   to @cai-n!  #329</li> <li>The lua context pool would not invalidate entries when the config   epoch changed. This meant that   if you had config values encoded in the lua script itself (rather than via a   memoized load from a datasource), you would need to wait until the maximum   lua context age had expired   for those changes to be reflected.</li> <li>Changing the composition (sources) of an egress pool might not fully take   effect until the associated queues had aged out.</li> </ul>"},{"location":"changelog/2025.03.19-1d3f1f67/","title":"Release 2025.03.19-1d3f1f67","text":""},{"location":"changelog/2025.03.19-1d3f1f67/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>New   data_processing_timeout   sets a default time limit of 5 minutes for processing the DATA phase during   SMTP reception.  If this limit is too short for your workflow, you will   need to configure a larger value in your <code>start_esmtp_listener</code> setup.</li> <li>Removed deprecated <code>should_enqueue_log_record</code> and <code>get_queue_config</code> fields   from the <code>shaper</code> object returned from <code>shaping:setup_with_automation</code>.   These have had no effect for the past several stable releases, having been   made automatic. If you are referencing them in your policy, you can simply   remove the associated logic.</li> <li>MX resolution now has a default timeout of 5 seconds. Read   kumo.dns.set_mx_timeout for more   information.</li> <li>The HTTP client returned from <code>kumo.http.build_client</code> will now look for the   system CA-certificate bundle when making connections. If no CA-certificate   bundle is present, it will have no available trust store and will not be   able to successfully establish TLS sessions. Previously, we used a bundled   hard-coded, non-extensible, copy of the Mozilla CA certificate store. You   must therefore ensure that you install the <code>ca-certificates</code> package for your   system, or otherwise contrive to populate the system certificate store. Note   that this change is consistent with a similar change to the SMTP client in   the <code>2024.11.08-d383b033</code> release.</li> <li>message:import_scheduling_header()   will now produce errors for invalid scheduling headers instead of its   previous erroneous behavior of silently ignoring errors. If you relied upon   the prior behavior, you can use the lua <code>pcall</code> function to catch and ignore   those errors.</li> </ul>"},{"location":"changelog/2025.03.19-1d3f1f67/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>DKIM signer TTLs can be now be expressed using duration strings like <code>\"5   mins\"</code>. Previously you could only use the integer number of seconds.</li> <li>debian packages will now unmask kumod and tsa-daemon services as part   of post installation.  Thanks to @cai-n! #331</li> <li>memoize now has an optional   <code>invalidate_with_epoch</code> parameter that allows you to opt a specific cache   into epoch-based invalidation.</li> <li>DKIM signer has a separate supplemental cache for the parsed key data,   which helps to reduce latency for deployments where the same key data   is shared between multiple signing domains.</li> <li>New msg:shrink() and   msg:shrink_data() methods.</li> <li>Added various python compatibility functions to the minijinja template engine.   See the pycompat   docs   for a list of the additional functions.</li> <li>New kumo.string.eval_template   function for expanding minijinja template strings.</li> <li>New low_memory_reduction_policy,   no_memory_reduction_policy and   options give advanced control over memory vs. spool IO trade-offs when   available is memory low.</li> <li>New shrink_policy   option to give advanced control over memory vs. spool IO trade-offs when   messages are delayed.</li> <li>Expose <code>back_pressure</code> option to <code>shaping:setup_with_automation</code> call. This   allows setting the underlying   back_pressure for the TSA log   hooks.</li> <li>local logger will now create sub-directories if they do not already exist   below the configured log directory.</li> <li>traffic-gen: you may now specify relative weights for the randomly generated destination   domains using eg: <code>--domain gmail.com:3 --domain outlook.com:1</code> to have gmail.com   be 3x more likely to be generated than outlook.com.</li> <li>New kumo.dns.set_mx_timeout option   to configure a timeout for MX record resolution. #325</li> <li>New kumo.dns.set_mx_negative_cache_ttl   option to configure the duration used for caching MX resolution errors.</li> <li>New <code>lruttl</code> cache implementation exposes more internal cache metrics to   prometheus with the <code>lruttl_</code> prefix.</li> <li>New kumo.set_lruttl_cache_capacity   function to configure internal cache sizes.</li> <li>New kumo.log_error,   kumo.log_warn,   kumo.log_info, and   kumo.log_debug functions for logging   diagnostics from your policy scripts.</li> <li>When performing source selection, if round robin would tell us to use a   source whose associated ready queue is full, we'll now try to use one of the   other available sources in that pool instead of immediately generating a   transient failure for that message.</li> <li>New   source_selection_rate,   additional_source_selection_rates   and a provider-specific <code>provider_source_selection_rate</code> options to adjust   the source selection algorithm to enable explicit configuration of IP-warmup   on a per-source basis.</li> <li>New <code>/opt/kumomta/sbin/explain-throttle</code> utility that can be used to show   what effect <code>max_burst</code> has on a throttle spec. Usage is <code>explain-throttle 100/hr,max_burst=2</code>   and it will emit its explanation to stdout.</li> <li>There is now a default <code>5s</code> timeout for retrieving shaping data from   the TSA daemon.  Previously, there was no timeout.  You can set a different   value through the <code>load_validation_options</code> parameter in the shaping   helper, or through the second parameter to kumo.shaping.load.</li> <li>websocket clients created via   kumo.http.connect_websocket   now have a <code>recv_batch</code> method to aid in batch processing.</li> </ul>"},{"location":"changelog/2025.03.19-1d3f1f67/#fixes","title":"Fixes","text":"<ul> <li>When using   kumo.dkim.set_signing_threads,   some extraneous unused threads would be created.</li> <li>Using a display name with commas in the builder mode of the HTTP injection   API would produce an invalid mailbox header.</li> <li>Potential stack overflow during spool enumeration when using   <code>max_message_rate</code> with local (non-redis) throttles together with custom lua delivery   handlers.</li> <li>Missing <code>string.format</code> in kumod/tsa-daemon version mismatch error report. #351</li> <li>Failed to parse SPF records when the TXT record contained non-SPF records</li> <li>DKIM validation now attempts to verify a signature using each DKIM record   found in DNS, rather than just the first one, which improves support for   domains that publish multiple records for key rotation purposes.</li> <li>Invalid fields for message:set_scheduling   were silently ignored, leaving the scheduling restrictions silently unset.</li> <li>long rfc2047 encoded mailbox headers (<code>From</code>, <code>To</code>) might misinterpret   encoded words in the display name, leading to <code>msg:check_fix_conformance</code>   rebuilding that header incorrectly.</li> <li>Using <code>prefer_openssl</code> with a <code>routing_domain</code> could result in TLS certificate   verification failure due to a trailing <code>.</code> on the canonical DNS name passed   to the verification routine.</li> <li>tsa-daemon: sqlite db lock could block tokio scheduler threads</li> <li>tsa-daemon: bounce and suspension data pushes via websocket would be deduped   by just the rule hash instead of the full set of fields, resulting in   under-reporting the full set of bounces and subscriptions when initially   connecting via websocket.</li> <li>tsa-daemon: when busy, could report <code>channel lagged by NUMBER</code> and drop the   websocket connection, causing the MTA to need to reconnect and re-sync.</li> <li>Incorrectly attempted to retry a broken TLS connection when <code>enable_tls =   \"Required\"</code> (such as when implied by MTA-STS) and   <code>opportunistic_tls_reconnect_on_failed_handshake = true</code>, which could   lead to a session being stuck in a retry loop.</li> </ul>"},{"location":"changelog/2025.05.06-b29689af/","title":"Release 2025.05.06-b29689af","text":""},{"location":"changelog/2025.05.06-b29689af/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The embedded hickory DNS resolver was updated to version <code>0.25</code>.   If you are using   kumo.dns.configure_resolver be   aware that hickory has changed its configuration schema and that you may need   to update your configuration to match; be sure to test this before trying to   deploy to production.</li> <li>There is now an artificial limit of <code>128</code> concurrent MX lookups that are   permitted to be in-flight at any given time. In prior versions there was   no limit. You can adjust this via the new   kumo.dns.set_mx_concurrency_limit   function.</li> <li>dev docker images are now published as <code>ghcr.io/kumocorp/kumomta:main</code>   instead of <code>ghcr.io/kumocorp/kumomta-dev:latest</code>. The most recent version   of the older image will be retained for a while, but you should   update to reference the new tag.</li> </ul>"},{"location":"changelog/2025.05.06-b29689af/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>SMTP Server: TLS parameters will now be cached for up to 5 minutes at   a time, making it easier for a server to pick up an updated certificate   file. In prior versions, the TLS parameters would be held for the lifetime   of the process, requiring a restart to pick up a changed certificate/key   pair.</li> <li>SMTP Server: new via,   peer, and   meta options for   SMTP listeners enable metadata (and other existing listener options) to   be conditionally set based on the source and local address of the   incoming SMTP session.</li> <li>SMTP Server: new   smtp_server_connection_accepted   event allows custom processing prior to returning the banner to the client.</li> <li>SMTP Server: new   smtp_server_get_dynamic_parameters   event allows dynamically amending listener configuration to support IP-based   virtual service.</li> <li>Updated the hickory DNS resolver to <code>0.25</code>. While no kumomta-user-visible   changes are anticipated as a result of this upgrade, it is a fairly   significant release of the DNS resolver so please report unexpected   changes in behavior around DNS.</li> <li>Added example and recommended default shaping configuration for the   TSA daemon to the default <code>shaping.toml</code> file.</li> <li>If you are running on a system where   kumo.available_parallelism   returns an inaccurate value (such as an overcommitted VM), then you may   now export <code>KUMO_AVAILABLE_PARALLELISM</code> into the launching environment to   override the value to something more appropriate, which helps to scale   the various thread pools more appropriately.</li> <li>New systemd environment override files for both kumod and tsa-daemon.  These   are useful for setting the <code>KUMO_AVAILABLE_PARALLELISM</code> variable mentioned in   the item above. See the   commit   for details.</li> <li>Ready Queue Maintenance is now carried out in a new <code>readyq_qmaint</code> thread   pool. In previous versions, it was handled by the <code>qmaint</code> thread pool.  If   you were tuning via   kumo.set_qmaint_threads in a prior   version, you may need to review and adjust both that and the corresponding   kumo.set_ready_qmaint_threads   tuning.</li> <li>New   system_shutdown_timeout   option to specify how long we should wait for an in-flight delivery attempt   to wrap up before terminating it once we have received a request to shutdown   kumod.</li> <li><code>kcli top</code>: you may now scroll through the metrics using the arrow keys   (to move one metric at a time), page up/down (10 at a time) and home/end   (to move to the top/bottom). Pressing <code>f</code> edits a fuzzy matching filter.   Pressing Tab moves through tabs and allows viewing heatmap vizualizations.   #372</li> <li>Disabled DANE in the default <code>shaping.toml</code> for the <code>office365-dane</code> provider.   We cannot default DANE to on without a guarantee that the DNS/resolver   situation is correctly deployed with DNSSEC and without also knowing that   we're configure to use openssl.</li> <li>MX lookups now participate in lruttl cache thundering herd protection.   In prior versions, we could potentially issue multiple concurrent requests   for the same name.</li> <li>Singleton wheel now spawns batches of messages when promoting them to   the ready queue, helping to ensure more even time keeping when there are   domains with slow DNS.</li> <li>Add caching and, more importantly, negative caching in the queue insertion   code paths when checking for admin bounce entries. This improves performance   on systems with a large number of admin bounce entries.</li> <li>Improved performance of TSA state storage, which in turn improves   latency in tsa-daemon response times when many automation rules are triggering.</li> <li>New   maintainer_wakeup_strategy   and   dispatcher_wakeup_strategy   options for fine tuning overall system performance.</li> <li>log_arf and   log_oob now support   <code>\"LogThenDrop\"</code> to make it easier to express a policy that wants to log   incoming reports but not relay them. Additional descriptive dispositions for   the prior behavior are now also supported, in addition to the legacy boolean   values.</li> <li>The rfc5965 (ARF) parser is now more forgiving if the incoming message   has an invalid <code>Arrival-Date</code> or <code>Received-Date</code> header, such as that   included in one of the examples in rfc5965 itself.</li> </ul>"},{"location":"changelog/2025.05.06-b29689af/#fixes","title":"Fixes","text":"<ul> <li>Specifying <code>validation_options</code> for the shaping helper without explicitly   setting the new <code>http_timeout</code> could lead to a <code>missing field</code> error when   running <code>kumod --validate</code>.</li> <li>tsa-daemon now increases its soft <code>NOFILE</code> limit to match its hard limit   on startup (just as we do in kumod), which helps to avoid issues with   running out of file descriptors on systems with very large core counts.</li> <li>Shutdown could take longer than the 300s permitted by kumomta.service   when lua delivery handlers are experiencing delays, leading to systemd   issuing a SIGKILL.</li> <li>Loading an ed25519 private key via <code>kumo.dkim.ed25519_signer</code> would always   fail. #368</li> <li>msg:get_data,   msg:get_meta and   msg:set_meta now internally will ensure   that the data or meta portion of the message is loaded from spool.</li> <li>Rebuilding a MIME message (such as via <code>msg:check_fix_conformance</code>) that had   binary attachments would incorrectly re-interpret the bytes as windows-1252   encoded characters, damaging the attachment.</li> <li>Using redis-based throttles without redis-cell and with long periods (eg: <code>500/d</code>)   could result in throttles being exceeded.</li> </ul>"},{"location":"changelog/2025.10.06-5ec871ab/","title":"Release 2025.10.06-5ec871ab","text":""},{"location":"changelog/2025.10.06-5ec871ab/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/2025.10.06-5ec871ab/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>try_next_host_on_transport_error    option to more aggressively retry failures that are either transport errors    (eg: timeout) or are not definitively associated with the message (eg:    response to commands in between transactions).</li> <li>You may now specify outbound SMTP port numbers when configuring    make_queue_config().protocol    with an <code>mx_list</code>.</li> <li>You may now specify outbound SMTP port numbers when assigning either the    <code>routing_domain</code> or the domain portion of the scheduled queue name using the    <code>queue</code> meta item. #352</li> <li>kumo.dns.lookup_ptr function for looking    up PTR records. Thanks to @kayozaki! #390</li> <li>kumo.mpsc.define function for advanced    non-durable, non-persistent, in-memory queue processing.</li> <li>kumo.fs module for efficiently working with    the filesystem.  The functions    kumo.read_dir,    kumo.glob and    kumo.uncached_glob have been    deprecated in favor of functions with the same names in <code>kumo.fs</code>.  In    addition, a new kumo.fs.open function that    can create async capable file handles is now provided.</li> <li>SMTP Receptions made via TLS now: #100<ul> <li>Show in the trace headers as ESMTPS/ESMTPSA along with the TLS version   and cipher as a comment. eg: <code>with ESMTPS (TLSv1_3:TLS13_AES_256_GCM_SHA384)</code></li> <li>Are recorded as <code>tls_cipher</code>, <code>tls_protocol_version</code> and   <code>tls_peer_subject_name</code> in the meta values for the message and in the   <code>Reception</code> log record.</li> </ul> </li> <li>New    tls_required_client_ca    parameter to aid in configuring mTLS</li> <li>HTTP endpoints now support decompressing <code>deflate</code> and <code>gzip</code> compressed    request bodies, which helps to reduce bandwidth usage particularly with the    injection API. Thanks to @dschaaff! #394</li> <li>You may now consume HashiCorp Vault secrets stored with keys named something    other than <code>key</code> by using the new optional <code>vault_key</code> field in a    KeySource. Thanks to @pankajrathi95! #399</li> <li>Powerful MIME parsing API exposed to lua. Use    msg:parse_mime to parse incoming    messages, or kumo.mimepart to parse    and/or (re)build messages independently from the incoming message flow. #117</li> <li>kumo.generate_rfc3464_message    can be used to generate RFC 3464 non-delivery-reports.</li> <li>New <code>event_time</code> and <code>created_time</code> fields in Log    Record provide sub-second time stamp    granularity. #405</li> <li>kumo.encode is now a bit more relaxed    about excess (but otherwise harmless) padding in the various    <code>baseXX</code> encoding schemes.</li> <li><code>received_via</code> and <code>hostname</code> are now set in the message metadata for    messages injected via HTTP. #417</li> <li><code>SMTPUTF8</code> and <code>8BITMIME</code> are now advertised by the ESMTP listener. If the    next SMTP hop doesn't advertise these extensions and the current message is    8bit, then the message will be marked as permanently failed with a reason    explaining that the content is incompatible with the next hop.  Previously,    we'd try to send the 8bit data anyway, and the remote host would respond    with its own error informing of the incompatibility. See    ignore_8bit_checks    for more discussion on this topic and the ability to disable this send-time    checking.  #327</li> <li>New    start_esmtp_listener.allow_xclient    option enables support for    XCLIENT.</li> <li>configure_local_logs.meta,    and related logging <code>meta</code> options such as those in    configure_log_hook and other    higher level helpers that are built atop those functions now support simple    wildcard suffix matching of meta names, allowing capture of all meta fields    via <code>*</code> or all prefixed names via <code>prefix*</code>.</li> </ul>"},{"location":"changelog/2025.10.06-5ec871ab/#fixes","title":"Fixes","text":"<ul> <li><code>msg:check_fix_conformance</code> could panic when attempting to fix messages with    broken base64 parts</li> <li>The kumo <code>proxy-server</code> now increases its soft <code>NOFILE</code> limit to match its    hard limit on startup (just as we do in <code>kumod</code> and <code>tsa-daemon</code>), which    helps to avoid issues with running out of file descriptors when no explicit    tunings have been deployed for the proxy server.</li> <li>spf: implemented missing <code>h</code>, <code>r</code> and <code>p</code> macros. #423</li> </ul>"},{"location":"changelog/2025.12.02-67ee9e96/","title":"Release 2025.12.02-67ee9e96","text":""},{"location":"changelog/2025.12.02-67ee9e96/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Enabling    <code>batch_handling=\"BatchByDomain\"</code>    will cause message:recipient and the    <code>recipient</code> field of Log Record to switch to    an array holding the list of recipients.  These are NOT active by default,    but if you wish to enable them you should audit your policy and consider    switching to using    message:recipient_list as well as    review your log processors to ensure that they are able to handle the    <code>recipient</code> field being either an array or a string, or otherwise adjusting    your log templates accordingly.</li> <li>HTTP injections no longer consider the <code>Forwarded</code> header as a source of    information to populate the <code>received_from</code> metadata.  Instead, only the    directly connecting IP information will be used.  See the upstream    issue for more    information.</li> <li>Our SMTP client now treats a 552 response during <code>RCPT TO</code> as a    <code>TransientFailure</code> instead of a <code>PermanentFailure</code> as described by RFC 5321    Section    4.5.3.1.10.    If you are employing    smtp_server_rewrite_response    and happen to rewrite transient codes to <code>552</code> then you will find that the    disposition remains as a <code>TransientFailure</code> even after the rewrite.  Our    recommendation is that you update such rewrite rules to use <code>550</code> or <code>555</code>    to avoid this classification.</li> </ul>"},{"location":"changelog/2025.12.02-67ee9e96/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>msg:check_fix_conformance    now supports optionally detecting and fixing 8-bit charsets.</li> <li>smtp_server_data event enables    once-per-transaction processing of a message and recipient list modification    for alias expansion and legal capture.</li> <li>Admin bounces and scheduled queue suspensions can now optionally target the    complete queue name instead of matching by domain/campaign/tenant.  This is    useful in certain automation scenarios where you wish to target a specific    queue precisely.  The kcli commands support a <code>--queue</code> option to select the    queue name, while the API expose that via a <code>queue_names</code> field.</li> <li>New kcli xfer and kcli    xfer-cancel commands enable migration    of queues to alternative kumomta nodes as part of operational tasks such    draining a queue for decomissioning or scaling down infrastructure.  These    commands are building blocks for you to deploy auto-scaling or similar    functionality within your infrastructure orchestration. The new    xfer_message_received can be    used to fixup messages as they are arrive on the target node via xfer.    <code>XferOut</code> and <code>XferIn</code> are two new log record    types associated with message transfers. The kcli commands have    corresponding HTTP API endpoints:    xfer and    xfer-cancel #311</li> <li>New kumo.file_type module provides    functions for reasoning about file types.</li> <li>kumo.amqp.build_client is    deprecated in favor of    kumo.amqp.basic_publish.</li> <li>New kumo.dns.ptr_host,    kumo.dns.reverse_ip,    kumo.dns.define_resolver and    kumo.dns.rbl_lookup functions. #269</li> <li>new <code>smtp_server_rejections</code> counter to track the number of <code>Rejection</code> log    records produced by the smtp listener. The service key is the listener    address and port, and there is a <code>total</code> key that represents the total across    all listeners.</li> <li>new kumo.spf.check_msg convenience    function for checking SPF and producing Authentication-Results once the    data has been received.</li> <li>new kumo.crypto module. Thanks to    @dariomaiocchi! #395</li> <li>new Time and    TimeDelta objects.</li> <li>new    smtp_server_rewrite_response    event.</li> <li>msg:append_header and    msg:prepend_header both now accept    an optional <code>ENCODE</code> parameter that opts in to wrapping or quoted-printable    encoding the value as appropriate.</li> <li>new headermap:append method for    appending a header. This supplements the already available <code>:prepend</code>    method.</li> <li>new kumo.string.wrap function that    enables manual wrapping of strings for use in, for example, header values.</li> <li>new msg:arc_verify and    msg:arc_seal functions. #16</li> <li>Enable thundering herd protection for <code>dkim_key_cache</code> and    <code>dkim_signer_cache</code></li> <li>new policy-extras.mail_auth    module for performing mail authentication and producing an aggregate    <code>Authentication-Results</code> header.</li> <li>new normalize_smtp_response    lua function and jinja filter.</li> <li>The default value for    prohibited_hosts    now also includes the IPv4 and IPv6 Any addresses.</li> <li>kumo.version exposes the kumo version    number to your policy scripts, allowing you to conditionally phrase them    based on the running version of kumo.</li> <li>kumo.digest.sha225,    kumo.digest.sha3_256,    kumo.digest.sha3_384 and    kumo.digest.sha3_512 digest functions.</li> <li>kumo.digest.hmac_sha1,    kumo.digest.hmac_sha224,    kumo.digest.hamc_sha256,    kumo.digest.hmac_sha384 and    kumo.digest.hmac_sha512 HMAC functions.</li> <li>kumo.start_esmtp_listener.require_proxy_protocol    enables support for the HA Proxy Protocol in the ESMTP listener, allowing it    to pass through the <code>received_from</code> and <code>received_via</code> metadata from the    proxy. Thanks to @Solvik and @cai-n! #440</li> <li><code>traffic-gen</code> now accepts a <code>--header</code> flag to add arbitrary    headers to generated messages when simulating traffic, useful for testing    queue-specific flows or measuring latency impacts introduced    by custom header manipulation. Thanks to @cristian-porta! #434</li> <li>You may now specify the <code>template_dialect</code> when using the HTTP injection    API to select between <code>Jinja</code>, <code>Handlebars</code> or <code>Static</code>.  Similarly,    <code>kumo.string.eval_template</code> now supports an optional dialect parameter.</li> <li>You may now use an event-based callback to perform parameterized data    fetching in a keysource</li> <li>New kumo.crypto.aws_sign_v4    function for working with AWS V4 signatures. Thanks to @AdityaAudi! #457</li> </ul>"},{"location":"changelog/2025.12.02-67ee9e96/#fixes","title":"Fixes","text":"<ul> <li>smtp server would incorrectly return a 451 instead of a 452 status when    <code>max_recipients_per_message</code> or <code>max_messages_per_connection</code> limits    were exceeded.</li> <li>spf: a <code>NoRecordsFound</code> response from DNS during an <code>exists:</code> rule check    could cause the result to incorrectly be reported a <code>temperror</code></li> <li>spf: <code>%{h}</code> macro expansion could incorrectly enclose the domain in double quotes</li> <li>spf: relax macro parsing to allow spaces in, for example, explanation txt records</li> <li>kumo.spf.check_host: <code>%{h}</code> will be assumed to have the value of the    <code>domain</code> field when <code>sender</code> is not set, as <code>ehlo_domain</code> won't be set in    the connection context until after <code>smtp_server_ehlo</code> returns successfully.</li> <li>kumo.start_esmtp_listener.line_length_hard_limit    could by off-by-two in certain cases when applied to DATA, and could    sometimes allow up to 1024 bytes for a single SMTP command outside of DATA,    even though the limit was set smaller.</li> <li>Message builder API didn't quote every possible character that needed to be    quoted in the display name of a mailbox. #428</li> <li>Incorrectly treated a 552 as a transient failure for non-RCPT-TO 552    responses. #431</li> <li>spf: we now populate <code>smtp.mailfrom</code> in the Authentication-Results props map.</li> <li>keysource now supports inline binary bytes    being passed via <code>key_data</code>.  Previously, only UTF-8 strings could be    passed that way.</li> <li>keysource now supports callback/event based    data loading, which is similar to inline <code>key_data</code>, but allows for more    efficient cache keys that use less RAM.</li> <li>dkim verification would incorrectly treat <code>i=@fexample.net</code> as a valid    subdomain of <code>d=example.net</code>.</li> <li>mx_list says that    the list of addresses are tried in the order specified, but they were    incorrectly tried in the reverse of that order (because internally that list    is placed into a LIFO stack).  This has now been corrected and the    connection plan now follows the ordering of your <code>mx_list</code>.  You might    consider using kumo.version to accommodate    this change in behavior.</li> <li>Metrics with multiple labels, such as    <code>connection_count</code>, didn't respect the <code>prefix=PREFIX</code> URL parameter when    preparing the <code>/metrics</code> prometheus text exposition output.</li> </ul>"},{"location":"changelog/main/","title":"Unreleased Changes in The Mainline","text":""},{"location":"changelog/main/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The <code>rfc5321_rustls_config</code> cache has been renamed to <code>rustls_client_config</code>.    If you have a policy that tunes this cache via    kumo.set_lruttl_cache_capacity,    you will need to update the cache name.</li> <li>The effect of the skip_hosts    configuration has been downgraded from a <code>550</code> to a <code>451</code> to make it more inline    with the effect of resolving a domain to an empty list of MX hosts.  The rationale    for this is that users primarily employ <code>skip_hosts</code> to prevent the use of IPv6.    That, coupled with a few recent issues with Microsoft hosted domains where their    DNS would only transiently return IPv6 addresses (no IPv4) addresses meant that    some mail could be inadvertently permanently failed.  The reason field now    also has <code>KumoMTA internal:</code> prefixed to it, to make it clearer that it was    synthesized by us, rather than returned from a remote host.</li> </ul>"},{"location":"changelog/main/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>Enhanced Access Control subsystem,    supported by a new Authentication, Authorization and Accounting (AAA) module    exposed to lua as kumo.aaa.</li> <li>The <code>Handlebars</code> template dialect now runs with recursive lookup    for improved compatibility with other handlebars implementations.</li> <li><code>msg:check_fix_conformance()</code> can now detect and attempt to fix issues where    the charset is invalid for parts that use transfer-encoding, by applying    any charset detection options, falling back to UTF-8.</li> <li>The lua HTTP <code>Request</code> object now supports AWS V4 signatures via a new    request:aws_sign_v4    method.  Thanks to @AdityaAudi! #458</li> <li>The HTTP Injection API and MIME    Builder API now support creating    messages with AMP    HTML    parts.    mimepart:get_simple_structure()    also supports AMP HTML parts.</li> <li>Improved the context shown in error messages produced by the HTTP injection    API</li> <li>Kumo Proxy:<ul> <li>Now optionally supports configuration via a proxy policy lua script.</li> <li>Optional support for TLS and mutual TLS when using a proxy policy script,    however, kumod itself doesn't currently support using TLS for SOCKS5.</li> <li>Optional support for RFC 1929 authentication</li> <li>Use proxy.start_proxy_listener    function to configure a SOCKS5 proxy server</li> <li>Many thanks to @vietcgi! #459</li> <li>Exposes proxy-specific metrics    via its new proxy.start_http_listener.    Thanks to @AdityaAudi! #472</li> </ul> </li> <li>New kumo.xfer.xfer and    kumo.xfer.xfer_in_requeue    functions to enable per-message transfer between nodes, which is useful in    combination with the    requeue_message event.</li> <li>New    message:increment_num_attempts    method for advanced message manipulation.</li> <li>The requeue_message event now    exposes additional context about the event leading to the the requeue,    allowing for more nuanced/advanced requeue logic.</li> <li>Each metric exported by kumod now has a documentation page. You can find an    index at kumod metrics.</li> <li>New <code>/tsa/status</code> HTTP endpoint for the TSA daemon which can be used to determine    that its service is up.</li> <li>New    redis_operation_latency    histogram metric which tracks operation type, status and latency.</li> <li>New system- and process-specific CPU usage metrics. We export both the    total overall percentage across all cores, which results in values ranging    from <code>0%</code> through to <code>num_cpus * 100%</code> for a fully saturated system,    as well as normalized values that use <code>100%</code> to indicate a fully saturated    system.  The process-specific variants account only for the individual service    process (eg: <code>kumod</code> only), whereas the system-specific variants indicate    the total load on the entire system. #186</li> <li>The HTTP Injection API now    reports content/template syntax errors with HTTP status code 422    \"Unprocessable Content\".  Previously, these would be reported as a 500    status code.  The 422 code helps to specifically identify that there is a    problem with the content portion of the injection request as oppossed to    some other kind of error.  This check and status response also applies to    requests that have enabled <code>deferred_generation</code>.  Previously, content    syntax errors would be deferred as part of the overall injection request    deferral, making it awkward to surface this class of problem.</li> </ul>"},{"location":"changelog/main/#fixes","title":"Fixes","text":"<ul> <li>An SPF record containing U+200B (zero width space) could cause    SPF record parsing to panic and the service to crash</li> <li>MIME part body extraction did not always consider the charset for text parts</li> <li>Errors raised while dispatching    should_enqueue_log_record    were not logged to the diagnostic log.</li> <li>Rebuilding (eg: for conformance fixing via <code>msg:check_fix_conformance()</code>, or    as part of the post-HTTP injection fixup) a header like <code>From:    \"something\\n\\tthat wraps lines\" &lt;user@example.com&gt;</code> would produce an invalid    rendition of that header.</li> <li>Setting <code>content.headers[\"To\"]</code> in the HTTP injection API would result in    two <code>To</code> headers being generated in the message; one for the per-recipient    <code>To</code> header, and one for the specified <code>content.headers[\"To\"]</code> value.  This    has been fixed; the behavior now is to use the <code>content.headers[\"To\"]</code>    header and not to emit a per-recipient <code>To</code> header in this situation.</li> <li>HTTP Injection didn't gate on the spool being started which meant that    there was a race condition on startup where an injection request could    begin processing prior to starting spool enumeration, which could then    cause a <code>set_meta_spool has not been called</code> panic.</li> <li>HTTP Injection and XFER Injections didn't grab an Activity handle which    meant that there was a potential race condition when shutting down the    system which could result in loss of accountability of the message(s)    that were part of that request.</li> <li>Fixed possible integer overflow when computing a very long delay.    Thanks to @edgarsendernet! #480</li> <li>Filter out not-relevant-to-TSA records earlier in the logging pipeline. #478</li> <li>Outbound SMTP connections that have been closed by the destination during    idle time are now detected more robustly in between message sends, reducing    the rate at which a message will get classified as an internal connection    failure. #482</li> <li>Certain very specific combinations of long lengths of fields captured in the    DKIM-Signature header during signing could lead to conflicting wrapping of    that field in the second pass of signing, and result in a signature that    some MBPs (specifically, AWS SES) would not validate. #483</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<ul> <li>Can I Migrate From Momentum (Ecelerity) to KumoMTA?</li> <li>Can I Migrate From PowerMTA to KumoMTA?</li> <li>Does KumoMTA Follow Secure Development Lifecycle (SDLC) Practices?</li> <li>How do I flush a queue?</li> <li>How Can I Get Help With KumoMTA?</li> <li>How Can I Tell What Traffic Shaping Rules Apply To A Domain?</li> <li>How do I skip IPv6 MX hosts for outbound SMTP?</li> <li>How do I create an always-suspended queue?</li> <li>How do I include multiple configuration files from a directory?</li> <li>Is There a SaaS Version of KumoMTA?</li> <li>How Can I Apply Multiple DKIM Signatures to a Message?</li> <li>Why is KumoMTA Accepting Connections From Systems Not Listed in relay_hosts?</li> <li>How do I resolve a <code>Permission Denied</code> error?</li> <li>How Do I Configure POP3/IMAP?</li> <li>How Do Shared Throttles Work for Small Connection Limits in a Cluster?</li> <li>How Do I Avoid Having a Single Point of Failure?</li> <li>How Can I Test TLS Injection?</li> <li>What is KumoMTA?</li> <li>Who is KumoMTA For?</li> </ul>"},{"location":"faq/can_i_migrate_from_momentum_ecelerity_to_kumomta/","title":"Can I Migrate From Momentum (Ecelerity) to KumoMTA?","text":"<p>Yes, we have helped several organizations with their Momentum (AKA Ecelerity) to KumoMTA migration.</p> <p>A good primer on performing a Momentum to KumoMTA migration can be found in our blog at https://kumomta.com/blog/moving-from-momentum.</p> <p>If you would prefer the help of our professional services team in performing your Momentum to KumoMTA migration, you can contact us at hello@kumomta.com.</p>"},{"location":"faq/can_i_migrate_from_powermta_to_kumomta/","title":"Can I Migrate From PowerMTA to KumoMTA?","text":"<p>Yes, a PowerMTA to KumoMTA migration is the most common migration our users have inquired about.</p> <p>A good primer on performing a PowerMTA to KumoMTA migration can be found in our blog at https://kumomta.com/blog/moving-from-pmta.</p> <p>If you would prefer the help of our professional services team in performing your PowerMTA to KumoMTA migration, you can contact us at hello@kumomta.com.</p>"},{"location":"faq/does_kumomta_follow_secure_development_lifecycle_practices/","title":"Does KumoMTA Follow Secure Development Lifecycle (SDLC) Practices?","text":"<p>Yes, we follow common SDLC practices:</p> <ul> <li>Our first party code carefully considers and validates security requirements as part of the design process.</li> <li>We leverage github's \"Dependabot\" and security notification features for automated notifications of potential issues in our dependencies.</li> <li>We regularly update those dependencies anyway to stay proactive.</li> <li>Third party contributions are carefully reviewed before being accepted and integrated.</li> </ul>"},{"location":"faq/flush_queue/","title":"How do I flush a queue?","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>You can use <code>kcli rebind</code> for this; the following will flush <code>example.com</code> for all tenant/campaigns:</p> <pre><code>$ kcli rebind --reason \"Cleaning up a bad send\" --domain example.com --always-flush\n</code></pre> <p><code>kcli rebind</code> re-evaluates the queue for messages in matching queues. In the usage above, we're not passing in any new metadata, so the queue won't actually change. The <code>--always-flush</code> parameter tells KumoMTA that it should make the messages immediately eligible for delivery even though we didn't change the queue.</p> <p>If you want to do this via API, then  you should look at the /api/admin/rebind/v1 HTTP endpoint documentation.</p>"},{"location":"faq/how_can_i_get_help_with_kumomta/","title":"How Can I Get Help With KumoMTA?","text":"<p>If you would like help with KumoMTA, the KumoMTA team provides both Professional Services and Commercial Support. For more information on paid support and services contact the KumoMTA team at hello@kumomta.com.</p> <p>For community support, refer to the How To Get Help page in the User Guide.</p>"},{"location":"faq/how_can_i_tell_what_traffic_shaping_rules_apply_to_a_domain/","title":"How Can I Tell What Traffic Shaping Rules Apply To A Domain?","text":"<p>Use the <code>/opt/kumomta/sbin/resolve-shaping-domain</code> executable to identify what traffic shaping rules match the domain in question.</p> <pre><code>/opt/kumomta/sbin/resolve-shaping-domain mosaicco.com\n</code></pre>"},{"location":"faq/how_do_I_skip_ipv6_mx_hosts_for_outbound_smtp/","title":"How do I skip IPv6 MX hosts for outbound SMTP?","text":"<p>You can use the skip_hosts option to skip all IPv6 hosts by using the IPv6 CIDR <code>::/0</code> which matches all possible IPv6 addresses.</p> <p>You can set this as the default in your <code>shaping.toml</code> if you wish:</p> <pre><code>[\"default\"]\nskip_hosts = [\"::/0\"]\n</code></pre>"},{"location":"faq/how_do_i_create_an_always_suspended_queue/","title":"How do I create an always-suspended queue?","text":"<p>Some sites employ a catch-all queue for messages that didn't get categorized and queued into an expected queue. In the Momentum (AKA Ecelerity) MTA they might do this by defining a binding or binding group that has delivery permanently suspended.</p> <p>The equivalent concept in KumoMTA is to define an Egress Pool that has no sources, and associate the always-suspended queue with that pool.</p> <p>That will cause messages that are queued to it to experience a transient failure with a disposition of this form:</p> <pre><code>451 4.4.4 no non-zero-weighted sources available for QUEUE_NAME\n</code></pre> <p>Messages will be subject to the usual retry schedule, which you can of course configure for your queue.</p> <p>To configure this using the queues and sources helpers:</p> <ul> <li>Add the following to your <code>queues.toml</code>:</li> </ul> TOMLJSON <pre><code>[queue.\"always-suspended\"]\negress_pool = \"always-suspended-pool\"\n</code></pre> <pre><code>{\n  \"queue\": {\n    \"always-suspended\": {\n      \"egress_pool\": \"always-suspended-pool\"\n    }\n  }\n}\n</code></pre> <ul> <li>Add the following to your <code>sources.toml</code>:</li> </ul> TOMLJSON <pre><code>[pool.\"always-suspended-pool\"]\n</code></pre> <pre><code>{\n  \"pool\": {\n    \"always-suspended-pool\": {\n    }\n  }\n}\n</code></pre> <ul> <li>Then in your policy, you can put messages in that queue explicitly:</li> </ul> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  if some_condition then\n    -- Explicitly assign the message to the always-suspended queue.\n    -- Its envelope, tenant and campaign will be ignored as the queue\n    -- meta value takes precedence\n    msg:set_meta('queue', 'always-suspended')\n  end\nend)\n</code></pre>"},{"location":"faq/how_do_i_include_multiple_files/","title":"How do I include multiple configuration files from a directory?","text":"<p>If you are looking to structure your configuration as a collection of include files in a directory hierarchy you can use the kumo.glob function to build out the appropriate include string.</p> <p>For example, the following code will load the shaping helper with all toml files in a given directory:</p> <pre><code>local shaper = shaping:setup_with_automation {\n  publish = { 'http://127.0.0.1:8008' },\n  subscribe = { 'http://127.0.0.1:8008' },\n  extra_files = {\n    '/opt/kumomta/etc/policy/shaping.toml',\n    '/opt/kumomta/etc/policy/vmta_shaping.toml',\n    '/opt/kumomta/etc/policy/automation_rules.toml',\n    table.unpack(kumo.glob '/opt/kumomta/etc/shaping/*.toml'),\n  },\n}\n</code></pre>"},{"location":"faq/is_there_a_saas_version_of_kumomta/","title":"Is There a SaaS Version of KumoMTA?","text":"<p>There is no official SaaS version of KumoMTA, but those who wish to operate their own email infrastructure but lack the skillset required can contact our Services team at hello@kumomta.com to learn about our Remote Management service where our team will set up and manage a KumoMTA installation on the platform of your choice.</p>"},{"location":"faq/multiple_dkim_signatures/","title":"How Can I Apply Multiple DKIM Signatures to a Message?","text":"<p>Applying multiple DKIM signatures to a message is straightforward, but will depend on how you implement DKIM signing in your installation:</p>"},{"location":"faq/multiple_dkim_signatures/#using-the-dkim-helper","title":"Using the DKIM Helper","text":"<p>If you are using the DKIM Helper to manage the signing of messages, you can add additional DKIM signatures by using the <code>additional_signatures</code> option in your helper config, combined with the <code>signature</code> block:</p> TOMLJSON <pre><code>additional_signatures = [\"MyESPName\"]\n\n[signature.\"MyESPName\"]\n# Policy is interpreted differently for these\npolicy = \"Always\" # Always add this signature\n#policy = \"OnlyIfMissingDomainBlock\" # Use this as a fallback\n\n# specifies the signing domain for this signature block\ndomain = \"myesp.com\"\n</code></pre> <pre><code>{\n  \"additional_signatures\": [\n    \"MyESPName\"\n  ],\n  \"signature\": {\n    \"MyESPName\": {\n      // Policy is interpreted differently for these\n      \"policy\": \"Always\",\n      // #policy = \"OnlyIfMissingDomainBlock\" # Use this as a fallback\n      // \n      // specifies the signing domain for this signature block\n      \"domain\": \"myesp.com\"\n    }\n  }\n}\n</code></pre> <p>You can add as many additional signatures as needed, and selectively decide whether those signatures are used globally or only when the sending domain does not have a signature of its own.</p>"},{"location":"faq/multiple_dkim_signatures/#using-lua","title":"Using Lua","text":"<p>If you are directly controlling DKIM signing using Lua, additional signatures are simply a matter of calling the signing module more than once:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  local signer_one\n  kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'myselector',\n    headers = { 'Content-Type', 'Message-Id', 'Subject' },\n    key = '/opt/kumomta/etc/dkim/mydomain.com/myselector.key',\n  }\n\n  msg:dkim_sign(signer_one)\n\n  local signer_two\n  kumo.dkim.rsa_sha256_signer {\n    domain = 'my_esp_domain.com',\n    selector = 'my_esp_selector',\n    headers = { 'Content-Type', 'Message-Id', 'Subject' },\n    key = '/opt/kumomta/etc/dkim/my_esp_domain.com/my_esp_selector.key',\n  }\n\n  msg:dkim_sign(signer_two)\nend)\n</code></pre> <p>Because you have granular control in Lua for signing, you can add as many signers as you wish, and set them either programmatically or arbitrarily depending on your needs.</p>"},{"location":"faq/non_relay_hosts/","title":"Why is KumoMTA Accepting Connections From Systems Not Listed in relay_hosts?","text":"<p>Let's say you have the following configured for your listeners:</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n  relay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n}\n</code></pre> <p>And the following configured for your `listener_domains`` helper:</p> TOMLJSON <pre><code>[\"*\"]\nrelay_to = false\nlog_oob = true\nlog_arf = true\n</code></pre> <pre><code>{\n  \"*\": {\n    \"relay_to\": false,\n    \"log_oob\": true,\n    \"log_arf\": true\n  }\n}\n</code></pre> <p>As you operate your server, you may be concerned to discover in your logs that messages are being accepted from hosts not listed in your <code>relay_hosts</code> list.</p> <pre><code>{\n  \"type\": \"Reception\",\n  \"id\": \"ebaaab5e9e7b11eeb206960002ccea16\",\n  \"sender\": \"test@test.com\",\n  \"recipient\": \"mmiihhww09@gmail.com\",\n  \"queue\": \"default@gmail.com\",\n  \"site\": \"\",\n  \"size\": 594,\n  \"response\": {\n    \"code\": 250,\n    \"enhanced_code\": null,\n    \"content\": \"\",\n    \"command\": null\n  },\n  \"peer_address\": {\n    \"name\": \"WIN-CLJ1B0GQ6JP\",\n    \"addr\": \"91.92.251.215\"\n  },\n  \"timestamp\": 1702996556,\n  \"created\": 1702996556,\n  \"num_attempts\": 0,\n  \"bounce_classification\": \"Uncategorized\",\n  \"egress_pool\": null,\n  \"egress_source\": null,\n  \"feedback_report\": null,\n  \"meta\": {},\n  \"headers\": {\n    \"Subject\": \"test smtp xx.xx.xx.xxx--\"\n  },\n  \"delivery_protocol\": null,\n  \"reception_protocol\": \"ESMTP\",\n  \"nodeid\": \"dd2b41fd-78f0-4105-8cd9-01ac7114cada\"\n}\n</code></pre> <p>This occurs because of the <code>log_oob</code> and <code>log_arf</code> options being enabled for <code>*</code> in the configuration.</p> <p>Whenever any of the <code>relay_to</code>, <code>log_oob</code>, or <code>log_arf</code> options are set to <code>true</code>, KumoMTA cannot immediately reject connections from hosts not listed in <code>relay_hosts</code> because it needs to see whether the remote host is sending messages to one of the domains listed in the <code>listener_domains</code> helper configuration.</p> <p>After a <code>RCPT TO</code> command is received, KumoMTA will check whether the destination domain is listed in the <code>listener_domain</code> config and if so, will receive the message and act accordingly. This can result in messages being received that may or may not be queued after being processed as an OOB and/or ARF message, depending on whether <code>relay_to</code> is set to <code>true</code>.</p>"},{"location":"faq/permission_denied/","title":"How do I resolve a <code>Permission Denied</code> error?","text":"<p>If you encounter an error message similar to the following:</p> <pre><code>stack traceback:\n        [C]: in local 'poll'\n        [string \"?\"]:5: in function 'kumo.start_http_listener'\n        [string \"/opt/kumomta/etc/policy/init.lua\"]:54: in function &lt;[string \"/opt/kumomta/etc/policy/init.lua\"]:13&gt;\ncaused by: Permission denied (os error 13)\n</code></pre> <p>The error is caused when the files referenced (and/or their containing directory) are not readable or writable by the <code>kumod</code> user. In the example above, this refers to TLS certificates used in the HTTP listener.</p> <p>Check that all files referenced to in your <code>init.lua</code> file (including the init.lua file itself), as well as their parent directories, are readable to the <code>kumod</code> user. These directories should have <code>g+x</code> permissions.</p>"},{"location":"faq/pop3_imap/","title":"How Do I Configure POP3/IMAP?","text":"<p>KumoMTA is a Message Transfer Agent, or MTA.</p> <p>The role of an MTA in your email infrastructure is to relay messages between systems, typically with an MTA configured for sending messages, and another MTA configured in the recipient's network to receive those messages.</p> <p>Where an MTA is designed to relay messages, storing them only temporarily for as long as needed to deliver the message to the next host, a Message Delivery Agent, or MDA, is designed to store messages until they are retrieved by the user's email client over POP3 or IMAP.</p> <p>KumoMTA is not designed nor intended to be used as an MDA, and users will need to look elsewhere for MDA functionality.</p>"},{"location":"faq/shared_throttles_in_cluster/","title":"How Do Shared Throttles Work for Small Connection Limits in a Cluster?","text":"<p>One common challenge when sending to highly restrictive Mailbox Providers (MBPs) is that if the provider publishes a very low connection limit, you may have more nodes sharing an external IP than the provider allows for.</p> <p>One common example is France's Orange, with a published connection limit of two connections at any time, as listed on their Postmaster Page. The Orange guidelines are implemented in the default shaping.toml file as follows:</p> <pre><code># https://messagerie.orange.fr/postmaster.html\n[\"orange.fr\"]\nconnection_limit = 2\nmax_deliveries_per_connection = 100\n</code></pre> <p>But what if you have multiple nodes sharing the same external IP address?</p> <p>If you have two nodes an option is to set each node to use a single connection.</p> <p>If you have more than two nodes a common workaround is to have a designated node for orange.fr that other nodes route all their traffic to, with the designated node configured to a two connection limit. This approach is of course quite fragile in that it depends on the availability of the designated node.</p> <p>KumoMTA supports shared throttles when installed as a cluster with a clustered Redis data store for throttle counters, but a common question is \"what happens when there's more than two nodes?\"</p> <p>KumoMTA maintains a shared lease approach for connections from a given IP to a given destination in a clustered install. The lease is maintained and extended each time a message is sent.</p> <p>The connection is closed and the lease released when the max deliveries on that connection is reached, or the connection idles out due to not having anything to do. This allows other nodes the opportunity to acquire the lease and send.</p> <p>In this example <code>orange.fr</code> has a published limit of 100 messages per connection; when creating similar throttles a smaller number of messages per connection is desirable (even when the MBP allows for more messages per connection) because it allows for leases to be released more regularly.</p>"},{"location":"faq/spof/","title":"How Do I Avoid Having a Single Point of Failure?","text":"<p>In high-volume sending environment uptime becomes critical, and one key to that is to avoid having a Single Point of Failure (SPOF).</p> <p>The following can help keep your email infrastructure highly available:</p> <ul> <li>Place your KumoMTA instances behind load balancers. A common architectural choice is to configure message generators that are assigned to a single specific MTA node, or even to assign individual tenants to a single MTA node. KumoMTA is cluster-aware and able to share tenants and throttles across all nodes. </li> <li>If you use a public cloud provider, leverage their hosted implementations of services such as Redis and AMQP. These implementations have extensive fault tolerance built into them that can help ensure continuous uptime.</li> <li>Ensure that your public IPs are highly available. If you use KumoProxy or HAProxy you will need to ensure that the public IPs attached to them are highly available. For an example on how to implement IP failover for proxy nodes see this article (note that the article is written with Nginx as the monitored service but it can also apply to proxy servers). Another alternative is to leverage the RNAT or port mapping capabilities of your enterprise firewall, as those systems generally have very high availability.</li> </ul> <p>In addition, you can leverage the RNAT or port mapping capabilities of enterprise-grade firewalls as a way to ensure high availability of public IP addresses. KumoMTA's clustering approach is also compatible with firewall-based IP sharing. * Load-balance your webhook consumers. One common SPOF is having a single server consuming webhooks. This can not only lead to overload during busy times, it creates a potential SPOF if the consumer goes down. While KumoMTA will retry delivery of webhooks, an extended outage can result in a full spool partition.</p>"},{"location":"faq/test_tls_injection/","title":"How Can I Test TLS Injection?","text":"<p>While it is straightforward to test SMTP message injection against KumoMTA using telnet to port 25 on the KumoMTA instance, you cannot test a session involving TLS (or SMTP AUTH, which requires TLS), using telnet due to the encrypted nature of a TLS connection.</p> <p>Instead, we recommend using Swaks for all testing, not only for TLS and AUTH but for the sake of repeatability, especially when asking for help.</p> <p>Swaks, or Swiss Army Knife for SMTP, is a flexible and effective testing tool for all manners of MTAs and SMTP scenarios.</p>"},{"location":"faq/test_tls_injection/#installing-swaks","title":"Installing Swaks","text":"<p>Installing Swaks can be as simple as pulling a copy using Curl and setting permissions:</p> <pre><code>curl -O https://jetmore.org/john/code/swaks/files/swaks-20240103.0/swaks\nchmod 755 ./swaks\n</code></pre>"},{"location":"faq/test_tls_injection/#testing-tls-and-smtp-auth-with-swaks","title":"Testing TLS and SMTP AUTH with Swaks","text":"<p>The following code shows how to perform a test injection to your local server over tls and authorized with AUTH PLAIN using Swaks:</p> <pre><code>[root@localhost ~]# ./swaks --to testrecipient@testdomain.fake --from testsender@testdomain.fake --server 127.0.0.1 --port 587 --auth plain --tls --auth-user someuser --auth-password somepassword\n=== Trying 127.0.0.1:587...\n=== Connected to 127.0.0.1.\n&lt;-  220 testdomain.fake KumoMTA Corp Mailer\n -&gt; EHLO localhost\n&lt;-  250-testdomain.fake Aloha localhost\n&lt;-  250-PIPELINING\n&lt;-  250-ENHANCEDSTATUSCODES\n&lt;-  250 STARTTLS\n -&gt; STARTTLS\n&lt;-  220 Ready to Start TLS\n=== TLS started with cipher TLSv1.3:TLS_AES_256_GCM_SHA384:256\n=== TLS client certificate not requested and not sent\n=== TLS no client certificate set\n=== TLS peer[0]   subject=[/CN=testdomain.fake]\n===               commonName=[testdomain.fake], subjectAltName=[DNS:testdomain.fake] notAfter=[2024-02-25T23:19:10Z]\n=== TLS peer[1]   subject=[/C=US/O=Let's Encrypt/CN=R3]\n===               commonName=[R3], subjectAltName=[] notAfter=[2025-09-15T16:00:00Z]\n=== TLS peer[2]   subject=[/C=US/O=Internet Security Research Group/CN=ISRG Root X1]\n===               commonName=[ISRG Root X1], subjectAltName=[] notAfter=[2024-09-30T18:14:03Z]\n=== TLS peer certificate passed CA verification, failed host verification (using host demo2.kumomta.com to verify)\n ~&gt; EHLO localhost\n&lt;~  250-testdomain.fake Aloha localhost\n&lt;~  250-PIPELINING\n&lt;~  250-ENHANCEDSTATUSCODES\n&lt;~  250 AUTH PLAIN\n ~&gt; AUTH PLAIN AHNvbWV1c2VyAHNvbWVwYXNzd29yZA==\n&lt;~* 535 5.7.8 AUTH invalid\n*** No authentication type succeeded\n ~&gt; QUIT\n&lt;~  221 So long, and thanks for all the fish!\n=== Connection closed with remote host.\n</code></pre>"},{"location":"faq/what_is_kumomta/","title":"What is KumoMTA?","text":"<p>KumoMTA is an open-source Message Transfer Agent (MTA) designed for high-performance outbound email functionality.</p> <p>The KumoMTA project was founded by a group of email industry veterans with decades of experience building and managing high-performance On-Prem MTAs and is supported by a community of some of the largest senders in the world. While paying attention to the lessons of history, KumoMTA was designed from the ground up with new tech as opposed to modifying something that already existed.</p>"},{"location":"faq/who_is_kumomta_for/","title":"Who is KumoMTA For?","text":"<p>Because it is designed for high-performance sending environments, KumoMTA is for experienced email operations professionals who are accustomed to high-performance sending environments and familiar with DevOps practices. Those sending less than one million messages per month will likely be better served by a more general-purpose MTA such as Postal.</p>"},{"location":"reference/","title":"Reference","text":"<p>This section contains reference documentation</p>"},{"location":"reference/access_control/","title":"Access Control","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>This section describes how Access Control is implemented within KumoMTA. There are three related parts to access control:</p> <ul> <li>Authentication - deciding the identity of a session, which may be    base on factors such as the peer address or an explicit credential    exchanged as part of SMTP or HTTP authentication.</li> <li>Authorization - deciding whether the session is allowed to perform some    action on a resource based on their identity and the configured Access    Control List for that resource.</li> <li>Accounting - tracking the disposition of each authorization check for    later review</li> </ul> <p>These three areas are known collectively as Authentication, Authorization and Accounting, or more succinctly as AAA.</p>"},{"location":"reference/access_control/#authentication","title":"Authentication","text":"<p>Each session into the server has an associated AuthInfo object that records the authentication state. It holds at least the following information:</p> <ul> <li>The peer address - the IP address that is connecting to the server</li> <li>A list of identities - for instance, the SMTP or HTTP auth username if auth    was successfully processed.  If the list is empty we consider the session    to be Unauthenticated.  If the list has at least one identity we consider    the session to be Authenticated.</li> <li>A list of group names - These may be established as part of authenticating    the session, and in some cases, may be special pre-set groups assigned    based on the peer address being present in the set of trusted hosts    for the associated listener.</li> </ul>"},{"location":"reference/access_control/#http-authentication","title":"HTTP Authentication","text":"<p>HTTP sessions are authenticated via the http_server_validate_auth_basic event.</p> <p>If that event returns <code>true</code> then the <code>username</code> parameter is added to the list of identities in the <code>AuthInfo</code>.  Alternatively, the event can directly return an <code>AuthInfo</code> to provide additional authentication information.</p>"},{"location":"reference/access_control/#smtp-authentication","title":"SMTP Authentication","text":"<p>SMTP sessions are authenticated via the smtp_server_auth_plain event.</p> <p>If that event returns <code>true</code> then the <code>authz</code> AND <code>authc</code> identities are both added to the list of identities in the <code>AuthInfo</code>.  Alternatively, the event can directly return an <code>AuthInfo</code> to provide additional authentication information.</p>"},{"location":"reference/access_control/#authorization","title":"Authorization","text":"<p>Authorization is the process of deciding whether a particular type of access is permitted to happen to a particular resource.  In KumoMTA we encode authorization rules into an Access Control List (ACL) for the resource.  To aid in the definition of ACLs, a resource has an associated hierarchy and can inherit ACLs from its parent/lineage in that hierarchy.</p> <p>The following terms apply to authorization:</p> <ul> <li><code>resource</code> - a string that identifies the resource.  For example, it may be    a string that corresponds to an HTTP API endpoint.</li> <li><code>privilege</code> - a string describing the nature of access that is desired.  For    example, it may be <code>POST</code> to indicate an HTTP post request is being    attempted, but it could be a more abstract privilege defined by the logic    that gates access to the resource.</li> <li><code>criteria</code> - an expression term that is used to define when an ACL rule    applies. For example, it might be \"members of a specific named group\".</li> <li><code>rule</code> - A combination of <code>privilege</code>, <code>criteria</code> and an access    level that defines the access permitted for that combination of    privilege and criteria.</li> <li><code>ACL</code> - An Access Control List, which is an ordered sequence of rules that    apply to a specific resource.</li> </ul> <p>When deciding whether access is permitted, the system will determine the resource that is to be accessed and then attempt to resolve the ACL for that resource.  This is carried out via the get_acl_definition event, with a fall back to a built in default ACL (which you can disable if you wish via kumo.aaa.set_fall_back_to_acl_map).</p> <p>Each rule in the returned ACL is considered (in the order in which they were defined in the ACL) and compared against the <code>AuthInfo</code> for the session.  If the <code>criteria</code> and <code>privilege</code> in the rule match then the access level defined by the rule is taken as the definitive outcome and authorization checking stops there at the first matching rule.</p> <p>If no rules from the ACL match, then the parent resource of the current resource is determined and its ACL is resolved, again evaluating its rules one by one until a match is found.</p> <p>If no matching rules were found, the parent resource of this resource is resolved and the process is repeated until there are no more parent resources. At that point the disposition is that access is denied by default.</p>"},{"location":"reference/access_control/#http-resources","title":"HTTP Resources","text":"<p>Access to HTTP API endpoints is decided by an initial authorization check in the HTTP request routing layer based on the endpoint URL, HTTP method (which is mapped to the <code>privilege</code>) and auth info in the current HTTP session.</p> <p>When the AuthInfo for the HTTP session is instantiated and if the peer IP address matches the start_http_listener.trusted_hosts option then the built-in group <code>kumomta:http-listener-trusted-ip</code> is added to the list of groups.</p> <p>Rather than directly taking the HTTP URI from the request as the resource name, the resource name is produced by re-composing the request elements.</p> <p>For a URL like <code>http://localhost:8080/foo/bar/baz</code>:</p> <ul> <li>The host portion of the request (<code>localhost:8080</code>) is ignored</li> <li>The listen address of the listener (as per    start_http_listener.listen) on which    the request was received is used to decide which http listener is being    accessed. For the sake of this example, let's assume that it is    <code>127.0.0.1:8080</code>.</li> <li>The HTTP request path is combined with the listen address to make a resource    path of the form <code>http_listener/127.0.0.1:8080/foo/bar/baz</code></li> </ul> <p>The inheritance hierarchy for such a resource is shown below, with the first of these being checked first and so on:</p> <ul> <li><code>http_listener/127.0.0.1:8080/foo/bar/baz</code></li> <li><code>http_listener/127.0.0.1:8080/foo/bar</code></li> <li><code>http_listener/127.0.0.1:8080/foo</code></li> <li><code>http_listener/127.0.0.1:8080</code></li> <li><code>http_listener/*/foo/bar/baz</code></li> <li><code>http_listener/*/foo/bar</code></li> <li><code>http_listener/*/foo</code></li> <li><code>http_listener</code></li> </ul> <p>Notice that the path is traversed similarly to a filesystem path, but when we reach the listener address (<code>http_listener/127.0.0.1:8080</code>) the next step is the full resource path underneath a special <code>*</code> resource location (<code>http_listener/*/foo/bar/baz</code>) which is consulted regardless of the listener address.</p> <p>Ultimately an HTTP access is checked against the logical <code>http_listener</code> resource which can be used to encode a general access rule if required.</p> <p>To illustrate how this works, the product default ACLs allow <code>GET</code>, <code>DELETE</code> and <code>POST</code> access to members of the group <code>kumomta:http-listener-trusted-ip</code> for the resource <code>http_listener/*/api/admin</code>.  Since all admin API endpoints fall under this particular resource path, that one rule definition applies to all admin API endpoints on all http listeners that may have been defined in the product, with the effect being that any IP in the list of trusted hosts for the listener is permitted to make admin API requests.</p>"},{"location":"reference/access_control/#defining-acls","title":"Defining ACLs","text":"<p>If you wish to define your own ACLs then the recommended way is to deploy an ACL map file to the system and configure it as shown in Augmenting the default ACL or Replacing the default ACL.</p> <p>The documentation for kumo.aaa.load_acl_map describes the syntax of an ACL map file and includes a copy of the default ACL map file.</p> <p>It is also possible to dynamically load ACLs from other data sources, or compute them dynamically, and that is demonstrated in Advanced ACL Building.</p>"},{"location":"reference/access_control/#accounting","title":"Accounting","text":"<p>You may enable and configure logging to an accounting log using kumo.aaa.configure_acct_log.</p> <p>The accounting log configuration is similar to the delivery log configuration, except that authentication and authorization events are logged rather than delivery information.  You can choose whether to include or exclude successful or failing authentication or authorization events.</p>"},{"location":"reference/authenticationresult/","title":"Authentication Result Object","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This object represents parsed individual Authentication Result as specified by RFC 8601.  Technically speaking, each instance of the object corresponds to the parsed form of the <code>resinfo</code> term specified by the RFC.  It doesn't represent an entire header value, just an individual result for an individual authentication method.</p> <p>Certain verification methods return arrays of authentication results for you to act upon in your policy and/or add to incoming message as headers.</p> <p>The object has the following fields:</p> <ul> <li><code>method</code> - required string; the authentication method</li> <li><code>method_version</code> - optional integer; the version of the authentication method</li> <li><code>result</code> - required string; the result of the authentication method.</li> <li><code>reason</code> - optional string; an explanation of why the method produced that result</li> <li><code>props</code> - a table with string keys and values containing various     method-specific properties that describe additional information about this     result. For example, for DKIM results, this will often contain copies of     some of the DKIM signature fields in order to correlate a given result with     the appropriate DKIM signature header when multiple signatures are present. </li> </ul>"},{"location":"reference/authenticationresult/#example-obtaining-dkim-authentication-results","title":"Example: obtaining DKIM authentication results","text":"<p>This will verify the DKIM signatures that are present in the message and return an array of authentication results:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  -- Verify the dkim signature and return the results.\n  -- Note that this example isn't making any policy decisions;\n  -- it is only annotating the message with the results and\n  -- allowing it to be relayed\n  local verify = msg:dkim_verify()\n  print('dkim', kumo.json_encode_pretty(verify))\n  -- Add the results to the message\n  msg:add_authentication_results(msg:get_meta 'hostname', verify)\nend)\n</code></pre> <p>might print something like this to the diagnostic log:</p> <pre><code>dkim    [\n  {\n    \"props\": {\n      \"header.d\": \"github.com\",\n      \"header.i\": \"@github.com\",\n      \"header.s\": \"pf2023\",\n      \"header.a\": \"rsa-sha256\",\n      \"header.b\": \"jo0EO4dX\"\n    },\n    \"result\": \"pass\",\n    \"method\": \"dkim\",\n    \"reason\": null,\n    \"method_version\": null\n  }\n]\n</code></pre>"},{"location":"reference/authenticationresult/#see-also","title":"See Also:","text":"<ul> <li>msg:add_authentication_results()</li> <li>msg:dkim_verify()</li> </ul>"},{"location":"reference/configuration/","title":"Configuration Lifecycle","text":"<p>Configuration in kumomta is expressed through the policy script that <code>kumod</code> is instructed to start with. The default value for the policy script is <code>/opt/kumomta/etc/policy/init.lua</code>.</p> <p>When the service is started the policy script is evaluated and the policy will then register a number of event handler functions whose purpose it is to provide configuration information to the system.</p> <p>This enables you to have a very dynamic setup that could be fed from an online data source, if desired, although you should carefully consider how you want your deployment to behave if such a data source is transiently unavailable before you go down that path.</p> <p>The main configuration events are:</p> <ul> <li> <p>init - called only once, when <code>kumod</code> is initializing   the service. The goal is to define listeners for SMTP, HTTP, logging and   spool, and perform other one-time initialization.</p> </li> <li> <p>get_listener_domain - called during an   SMTP transaction to resolve relaying information about sending and receiving   domains.</p> </li> <li> <p>get_queue_config - called in response to   enqueuing a message to a scheduled queue which has not yet been instantiated   in the system, and when the system decides that that information needs to be   refreshed--see more on that below. This event uses   make_queue_config to create a queue   configuration object to communicate the settings to the system.</p> </li> <li> <p>get_egress_pool - typically called right   after <code>get_queue_config</code> to resolve the egress pool that was specified   for that queue, if we don't already have that information cached.</p> </li> <li> <p>get_egress_source - called to resolve   an individual source as part of setting up a scheduled queue if we   don't have that information cached.</p> </li> </ul> <p>Configuration data is kept primarily only in the associated objects (such as queues) while those objects are live and required by the system, aging out as the corresponding queue is emptied and idles out of the system.  This means that we do not need to keep a massive static configuration in memory for the lifetime of the service.</p> <p>Note</p> <p>KumoMTA provides a number of higher level helper modules that provide implementations of these underlying event handlers, so in the most common usage scenarios you don't need to get into the details of most of these event handlers.</p>"},{"location":"reference/configuration/#configuration-caching-and-refreshing","title":"Configuration Caching and Refreshing","text":"<p>KumoMTA provides two different configuration refresh strategies:</p> <ul> <li> <p><code>Ttl</code> - the object will be considered stale after its refresh interval   has expired, which will lead to the corresponding event handler being   triggered to refresh its state.  In a system with many queues, this   can lead to periodic busy cycles to ensure that the configuration is   current.</p> </li> <li> <p><code>Epoch</code> - the object will remain valid until the configuration epoch (see   below) changes.  This results in fewer speculative periodic calls to   the associated event handlers, but is harder to use in concert when   pulling configuration from remote data sources.</p> </li> </ul>"},{"location":"reference/configuration/#config-epoch","title":"Config Epoch","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>KumoMTA monitors your local configuration files and computes a hash of their contents.  When that hash changes, which signals an observable change in something in those configuration files, it marks the start of a new configuration epoch, and bumps the current epoch number up by one.</p> <p>This change of epoch can be used as a signal to update/refresh information that is derived from your configuration files.</p>"},{"location":"reference/configuration/#configuration-monitoring","title":"Configuration Monitoring","text":"<p>Configuration monitoring uses a fairly simplistic filesystem polling mechanism that, every 10 seconds, evaluates a set of glob expressions to determine the list of files that should be considered to factor into the overall configuration state.</p> <p>This polling system intentionally does not use an OS-level file monitoring facility because it is not possible to efficiently do that with a glob expression, and also because those facilities are not guaranteed to work in every type of container solution.</p> <p>The default set of globs that are monitored is:</p> <ul> <li><code>/opt/kumomta/etc/**/*.{lua,json,toml,yaml}</code></li> </ul> <p>which matches the most likely sources of configuration code and data.</p> <p>You can use kumo.set_config_monitor_globs to change the set of globs if your deployment requires it.</p>"},{"location":"reference/configuration/#explicitly-bumping-the-config-epoch","title":"Explicitly Bumping the Config Epoch","text":"<p>The Epoch system will automatically notice and react to changes to the local files that match its glob expression, but if you are dependent upon non-filesystem data sources, such as TSA daemon, or other remote databases, it is necessary to provide a way to signal to KumoMTA that it should re-assess the configuration.</p> <p>There are two ways that this is achieved:</p> <ul> <li> <p>kumo.bump_config_epoch is a lua function that   can be called in code to force the epoch to increment and to notify other   modules about the change.  This mechanism is used by our shaping helper in   response to a websocket push from the TSA daemon to cause its configuration   updates to be picked up.</p> </li> <li> <p>/api/admin/bump-configuration   is an HTTP endpoint that can be used to externally bump the configuration   epoch. This can be useful as part of a deployment process or configuration   update happening elsewhere in your infrastructure.</p> </li> </ul>"},{"location":"reference/connectionmeta/","title":"Connection Metadata Object","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This object represents a collection of metadata keys and values that are associated with an established incoming SMTP connection.</p> <p>KumoMTA populates a small number of predefined fields (see below), and allows your policy scripts the ability to read those values as well as write (and read!) additional values as needed by the local policy. For instance, you may decide to compute a value after EHLO has been processed by smtp_server_ehlo and access that value in a later SMTP event handler.</p> <p>Prior to calling smtp_server_message_received, KumoMTA will copy the values from the connection metadata and use those to populate the message metadata.</p> <p>The <code>get_meta</code> and <code>set_meta</code> methods shown below are used to read and write metadata values.</p>","tags":["meta"]},{"location":"reference/connectionmeta/#predefined-connection-metadata-values","title":"Predefined Connection Metadata Values","text":"<p>The following values are predefined by KumoMTA:</p> Scope Name Purpose Since Connection <code>reception_protocol</code> indicates the reception protocol, such as <code>ESMTP</code> (Since: Version 2023.08.22-4d895015) Connection <code>received_via</code> indicates the IP:port of the KumoMTA listener that is handling this session (Since: Version 2023.08.22-4d895015) Connection <code>received_from</code> indicates the IP:port of the sending or peer machine in this session (Since: Version 2023.08.22-4d895015) Connection <code>hostname</code> A copy of the effective value of the hostname set by kumo.start_esmtp_listener (Since: Version 2023.11.28-b5252a41) Connection <code>authn_id</code> the authentication id if the message was received via authenticated SMTP Connection <code>authz_id</code> the authorization id if the message was received via authenticated SMTP <p>Note</p> <p>Additional metadata is available at the Message scope, for a full list of all available metadata, see the Predefined Metadata page.</p>","tags":["meta"]},{"location":"reference/connectionmeta/#available-methods","title":"Available Methods","text":"","tags":["meta"]},{"location":"reference/connectionmeta/#conn_metaget_metaname","title":"<code>conn_meta:get_meta(name)</code>","text":"<p>Returns the value associated with name, or <code>nil</code> if no such value has been defined. Values may be predefined by KumoMTA or may be set by policy scripts using <code>conn_meta:set_meta()</code>.</p>","tags":["meta"]},{"location":"reference/connectionmeta/#conn_metaset_metaname-value","title":"<code>conn_meta:set_meta(name, value)</code>","text":"<p>Sets the value associated with name to value.  Value must be serializable as JSON; it can be simple strings or numbers, but may also be an array or object value.</p>","tags":["meta"]},{"location":"reference/connectionmeta/#conn_metaauth_info","title":"<code>conn_meta:auth_info()</code>","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Returns a read-only copy of the AuthInfo object for the current session, which can be used in a call to kumo.aaa.query_resource_access for advanced access control use-cases.</p>","tags":["meta"]},{"location":"reference/keysource/","title":"KeySource Object","text":"<p>KeySource objects are used in several places:</p> <ul> <li>Embedded into DKIM signer objects.</li> <li>The <code>tls_certificate</code> and <code>tls_key</code> fields of listeners.</li> <li>To hold credentials for SMTP AUTH.</li> <li>With the kumo.secrets.load function.</li> </ul>"},{"location":"reference/keysource/#acceptable-values","title":"Acceptable Values","text":"<p>KeySources pattern match from one of the following shapes:</p>"},{"location":"reference/keysource/#local-file","title":"Local File","text":"<p>When the value is a simple string value, it is interpreted as the path to a file from which the key will be loaded when needed:</p> <pre><code>local file_signer = kumo.dkim.rsa_sha256_signer {\n  key = '/path/to/file.pem',\n}\n</code></pre>"},{"location":"reference/keysource/#caller-provided-data","title":"Caller Provided Data","text":"<p>Note</p> <p>Please also take a look at the callback/event based example further below</p> <p>When the value is a table with the field <code>key_data</code>, the value of the <code>key_data</code> field will be used as the key data when needed:</p> <pre><code>local file_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    -- Doing literally this is probably unwise;\n    -- see the example below for a more practical\n    -- and manageable way to use this\n    key_data = '-----BEGIN RSA PRIVATE KEY----....',\n  },\n}\n</code></pre> <p><code>key_data</code> exists to allow you to manage loading key data via some other lua function, for example, you could load your keys from a sqlite database:</p> <pre><code>function get_key(domain, selector)\n  local db = sqlite:open '/opt/kumomta/etc/dkim/keys.db'\n  local result = db:execute(\n    'select data from keys where domain=? and selector=?',\n    domain,\n    selector\n  )\n  return result[1]\nend\n\nlocal sqlite_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    key_data = get_key(msg:from_header().domain, 'default'),\n  },\n}\n</code></pre>"},{"location":"reference/keysource/#hashicorp-vault","title":"HashiCorp Vault","text":"<p>You may store and manage your keys in a HashiCorp Vault:</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'dkim/' .. msg:from_header().domain,\n\n    -- Specify how to reach the vault; if you omit these,\n    -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n    -- Note that these environment vars must be accessible\n    -- by the kumod user.  If using systemd, edit the systemd\n    -- service file. [Look here](docs/tutorial/using_vault/) for more information\n\n    -- vault_address = \"http://127.0.0.1:8200\"\n    -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n\n    -- Optional: specify the key name within the vault secret\n    -- (*Since: Version 2025.10.06-5ec871ab*)\n    -- Defaults to \"key\" if not specified\n    -- vault_key = \"my_custom_key_name\"\n  },\n}\n</code></pre> <p>The key must be stored under the <code>path</code> specified. By default, it looks for a field named <code>key</code> in the vault secret. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret dkim/example.org key=@example-private-dkim-key.pem\n</code></pre> <p>If you want to use a different field name, you can specify it with <code>vault_key</code> (Since: Version 2025.10.06-5ec871ab):</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'dkim/' .. msg:from_header().domain,\n    vault_key = 'private_key', -- Look for 'private_key' instead of 'key'\n  },\n}\n</code></pre> <p>And store it in vault like this:</p> <pre><code>$ vault kv put -mount=secret dkim/example.org private_key=@example-private-dkim-key.pem\n</code></pre>"},{"location":"reference/keysource/#callbackevent-based-data-source","title":"Callback/Event based Data Source","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>You may define an event handling function to perform parameterized data fetching.  This is in some ways similar to using the <code>key_data</code> form described above, but has the advantage of allowing deferred rather than eager access to the data.</p> <p>For example, you could enhance the sqlite dkim example above to use this form; the advantage is that the cache keys become smaller and more efficient, and the key source object is then a bit more declarative:</p> <pre><code>-- Define the event handling callback. The name must match up to the\n-- event_name field used in the keysource object below\nkumo.on('fetch-my-domain-key', function(domain, selector)\n  local db = sqlite:open '/opt/kumomta/etc/dkim/keys.db'\n  local result = db:execute(\n    'select data from keys where domain=? and selector=?',\n    domain,\n    selector\n  )\n  -- The callback must return a string which, depending on\n  -- the code that is consuming the keysource, may be binary.\n  -- DKIM keys are PEM encoded ASCII.\n  return result[1]\nend)\n\nlocal sqlite_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    -- name of the event handling callback you\n    -- have registered via kumo.on.\n    event_name = 'fetch-my-domain-key',\n    -- The list of parameters that will be passed to\n    -- the event handling callback\n    event_args = { msg:from_header().domain, 'default' },\n  },\n}\n</code></pre>"},{"location":"reference/log_record/","title":"Log Record","text":"","tags":["logging"]},{"location":"reference/log_record/#log-record","title":"Log Record","text":"<p>The log record is a JSON object with the following shape:</p> <pre><code>{\n    // The record type; can be one of \"Reception\", \"Delivery\",\n    // \"Bounce\", \"TransientFailure\", \"Expiration\", \"AdminBounce\",\n    // \"OOB\" or \"Feedback\"\n    \"type\": \"Delivery\",\n\n    // The message spool id; corresponds to the value returned by\n    // message:id()\n    \"id\": \"1d98076abbbc11ed940250ebf67f93bd\",\n\n    // The envelope sender\n    \"sender\": \"user@sender.example.com\",\n\n    // The envelope recipient\n    //\n    // If the message has multiple recipients (eg: it was part of\n    // an SMTP batch transaction) this will be an array of the\n    // recipients. (Multi-recipient is possible (*Since: Version 2025.12.02-67ee9e96*))\n    \"recipient\": \"user@recipient.example.com\",\n\n    // Which named queue the message was associated with\n    \"queue\": \"campaign:tenant@domain\",\n\n    // Which MX site the message was being delivered to.\n    // Empty string for Reception records.\n    \"site\": \"source2-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com.\",\n\n    // The size of the message payload, in bytes\n    \"size\": 1047,\n\n    // The response from the peer, if applicable\n    \"response\": {\n        // the SMTP status code\n        \"code\": 250,\n\n        // The ENHANCEDSTATUSCODE portion of the response parsed\n        // out into individual fields.\n        // This one is from a \"2.0.0\" status code\n        \"enhanced_code\": {\n            \"class\": 2,\n            \"subject\": 0,\n            \"detail\": 0,\n        },\n\n        // the remainder of the response content\n        \"content\": \"OK ids=8a5475ccbbc611eda12250ebf67f93bd\",\n\n        // the SMTP command verb to which the response was made.\n        // eg: \"MAIL FROM\", \"RCPT TO\" etc. \".\" isn't really a command\n        // but is used to represent the response to the final \".:\n        // we send to indicate the end of the message payload.\n        // This field can be nil/absent in some cases, particularly\n        // for Rejection records for incoming SMTP in older\n        // versions of kumomta.\n        \"command\": \".\"\n    },\n\n    // Information about the peer in the communication. This is either\n    // the submitter or the receiver, depending on the record type\n    \"peer_address\": {\n        // When delivering, this is the name from the MX record.\n        // When receiving, this is the EHLO/HELO string sent by\n        // the sender\n        \"name\": \"gmail-smtp-in.l.google.com.\",\n        \"addr\": \"142.251.2.27\"\n    },\n\n    // The time at which this record was generated, expressed\n    // as a unix timestamp: seconds since the unix epoch\n    \"timestamp\": 1757675281,\n\n    // The time at which this record was generated, expressed\n    // as an RFC 3339 string (*Since: Version 2025.10.06-5ec871ab*)\n    \"event_time\": \"2025-09-12T11:08:01.440526026Z\",\n\n    // The time at which the message was received, expressed\n    // as a unix timestamp: seconds since the unix epoch\n    \"created\": 1757675281,\n\n    // The time at which the message was received, expressed\n    // as an RFC 3339 string (*Since: Version 2025.10.06-5ec871ab*)\n    \"created_time\": \"2025-09-12T11:08:01.440526026Z\",\n\n    // The number of delivery attempts.\n    \"num_attempts\": 0,\n\n    // the classification assigned by the bounce classifier,\n    // or Uncategorized if unknown or the classifier is not configured.\n    \"bounce_classification\": \"Uncategorized\",\n\n    // The name of the egress pool used as the source for the delivery\n    \"egress_pool\": \"pool0\",\n\n    // The name of the selected egress source (a member of the egress pool)\n    // used for the delivery\n    \"egress_source\": \"source2\",\n\n    // For SMTP delivery, the source address (and port) that was used.\n    // (*Since: Version 2024.09.02-c5476b89*)\n    \"source_address\": {\n        // The source address. The port number may be unknown and reported\n        // as zero when using a proxy protocol.\n        \"address\": \"10.0.0.1:53210\",\n        // If a proxy protocol was used, this field will be\n        // set to its name. It may be null/not set for no proxy,\n        // \"haproxy\" or \"socks5\".\n        \"protocol\": \"socks5\",\n        // If a proxy protocol was used, this field will be\n        // set to the proxy server address. It will be null/not set\n        // when no proxy was used.\n        \"server\": \"192.168.1.1:5000\"\n    },\n\n    // when \"type\" == \"Feedback\", holds the parsed feedback report\n    \"feedback_report\": null,\n\n    // holds the values of the list of meta fields from the logger\n    // configuration\n    \"meta\": {},\n\n    // holds the values of the list of message headers from the logger\n    // configuration\n    \"headers\": {},\n\n    // The protocol used to deliver, or attempt to deliver, this message.\n    // May be null or unset for expirations or administrative bounces\n    // or other similar situations.\n    // \"ESMTP\" for SMTP, \"Maildir\" for maildir and \"Lua\" for a lua delivery\n    // mechanism.\n    \"delivery_protocol\": \"ESMTP\",\n\n    // The protocol used to receive the message\n    // \"ESMTP\" for SMTP, \"HTTP\" for the HTTP injection API, \"LogRecord\"\n    // for messages captured via `configure_log_hook`.\n    // This information is also stored in the message meta key named\n    // \"reception_protocol\".\n    \"reception_protocol\": \"ESMTP\",\n\n    // The node uuid. This identifies the node independently from its\n    // IP address or other characteristics present in this log record.\n    \"nodeid\": \"557f3ad4-2c8c-11ee-976e-782d7e12e173\",\n\n    // Information about TLS used for outgoing SMTP, if applicable.\n    // Incoming TLS info is available (*Since: Version 2025.10.06-5ec871ab*).\n    \"tls_cipher\": \"TLS_AES_256_GCM_SHA384\",\n    \"tls_protocol_version\": \"TLSv1.3\",\n    \"tls_peer_subject_name\": [\"C=US\",\"ST=CA\",\"L=SanFrancisco\",\"O=Fort-Funston\",\n                              \"OU=MyOrganizationalUnit\",\"CN=do.havedane.net\",\n                              \"name=EasyRSA\",\"emailAddress=me@myhost.mydomain\"]},\n\n    // A correlating session identifier. Messages received via\n    // the same connection will have the same session_id in their\n    // Reception or Rejection records. Messages being sent via the\n    // same session will have the same session_id in their TransientFailure,\n    // Delivery and Bounce records.\n    // May not be set in situations where there is no active session.\n    // (*Since: Version 2025.01.23-7273d2bc*)\n    \"session_id\": \"9bcd689e-23d9-41b7-a015-63a1382f8b57\"\n}\n</code></pre>","tags":["logging"]},{"location":"reference/log_record/#record-types","title":"Record Types","text":"<p>The following record types are defined:</p> <ul> <li><code>\"Reception\"</code> - logging the reception of a message via SMTP or via   the HTTP injection API</li> <li><code>\"Delivery\"</code> - logging the successful delivery of a message via SMTP</li> <li><code>\"Bounce\"</code> - logging a permanent failure response and end of delivery   attempts for the message.</li> <li><code>\"TransientFailure\"</code> - logging a transient failure when attempting delivery</li> <li><code>\"Expiration\"</code> - logged when the message exceeds the configured maximum   lifetime in the queue.</li> <li><code>\"AdminBounce\"</code> - logged when an administrator uses the <code>/api/admin/bounce</code>   API to fail message(s).</li> <li><code>\"OOB\"</code> - when receiving an out of band bounce with an attached RFC3464   delivery status report, the parsed report is used to synthesize an OOB   record for each recipient in the report.</li> <li><code>\"Feedback\"</code> - when receiving an ARF feedback report, instead of logging   a <code>\"Reception\"</code>, a <code>\"Feedback\"</code> record is logged instead with the report   contents parsed out and made available in the <code>feedback_report</code> field.</li> <li><code>\"Rejection\"</code> - logging a 4xx or 5xx response generated by KumoMTA   in response to an incoming SMTP command. (Since: Version 2024.06.10-84e84b89)</li> <li><code>\"Delayed\"</code> - explains why a message landed in the scheduled queue when   it doesn't otherwise have a <code>TransientFailure</code> record logged. (Since: Version 2025.01.23-7273d2bc)</li> <li><code>\"XferOut\"</code> - a message was transferred out from the current node to another   kumomta node as part of an xfer. (Since: Version 2025.12.02-67ee9e96)</li> <li><code>\"XferIn\"</code> - a message was transferred in to the current node from another   kumomta node as part of an xfer. (Since: Version 2025.12.02-67ee9e96)</li> </ul>","tags":["logging"]},{"location":"reference/log_record/#feedback-report","title":"Feedback Report","text":"<p>ARF feedback reports are parsed into a JSON object that has the following structure.  The fields of the <code>feedback_report</code> correspond to those defined by RFC 5965.</p> <p>See also trace_headers for information about the <code>supplemental_trace</code> field.</p> <pre><code>{\n    \"type\": \"Feedback\",\n    \"feedback_report\": {\n        \"feedback_type\": \"abuse\",\n        \"user_agent\": \"SomeGenerator/1.0\",\n        \"version\": 1,\n        \"arrival_date\": \"2005-03-08T18:00:00Z\",\n        \"incidents\": nil,\n        \"original_envelope_id\": nil,\n        \"original_mail_from\": \"&lt;somesender@example.net&gt;\",\n        \"reporting_mta\": {\n            \"mta_type\": \"dns\",\n            \"name\": \"mail.example.com\",\n        },\n        \"source_ip\": \"192.0.2.1\",\n        \"authentication_results\": [\n            \"mail.example.com; spf=fail smtp.mail=somesender@example.com\",\n        ],\n        \"original_rcpto_to\": [\n            \"&lt;user@example.com&gt;\",\n        ],\n        \"reported_domain\": [\n            \"example.net\",\n        ],\n        \"reported_uri\": [\n            \"http://example.net/earn_money.html\",\n            \"mailto:user@example.com\",\n        ],\n\n        // any fields found in the report that do not correspond to\n        // those defined by RFC 5965 are collected into this\n        // extensions field\n        \"extensions\": {\n            \"removal-recipient\": [\n                \"user@example.com\",\n            ],\n        },\n\n        // The original message or message headers, if provided in\n        // the report\n        \"original_message\": \"From: &lt;somesender@example.net&gt;\nReceived: from mailserver.example.net (mailserver.example.net\n    [192.0.2.1]) by example.com with ESMTP id M63d4137594e46;\n    Tue, 08 Mar 2005 14:00:00 -0400\nX-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\nTo: &lt;Undisclosed Recipients&gt;\nSubject: Earn money\nMIME-Version: 1.0\nContent-type: text/plain\nMessage-ID: 8787KJKJ3K4J3K4J3K4J3.mail@example.net\nDate: Thu, 02 Sep 2004 12:31:03 -0500\n\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\n\",\n\n        // if original_message is present, and a kumo-style trace\n        // header was decoded from it, then this holds the decoded\n        // trace information\n        \"supplemental_trace\": {\n            \"recipient\": \"test@example.com\",\n        },\n    }\n}\n</code></pre>","tags":["logging"]},{"location":"reference/memory/","title":"Memory Management","text":"<p>KumoMTA makes aggressive use of memory in the interest of performance, but memory is a finite resource.</p> <p>This section of the documentation discusses the general strategies employed by KumoMTA when it comes to managing its working set.</p>","tags":["memory"]},{"location":"reference/memory/#memory-limits-and-headroom","title":"Memory Limits and Headroom","text":"<p>On startup KumoMTA will determine the maximum RAM that is available but checking the following things in this same sequence:</p> <ul> <li>A <code>cgroup</code> memory limit, checking v2 cgroups before v1 cgroups.</li> <li>A <code>ulimit</code> constraint as observed via <code>getrlimit(2)</code>.</li> <li>The physical RAM available to the system</li> </ul> <p>A threshold is calculated at 75% of whichever of the above constraints is detected first of all.</p> <p>The calculated limit is published via the prometheus metrics endpoint as <code>memory_limit</code>, and is reported in bytes.</p> <p>A background task is started to monitor the memory usage of the system which is derived from:</p> <ul> <li>If running in a cgroup, the usage reported by that cgroup. Note that   this may include memory used by other processes in that same cgroup.</li> <li>The Resident Set Size (RSS) as reported in <code>/proc/self/statm</code></li> <li>The value configured via   kumo.set_memory_soft_limit, if any,   will always take precedence over the above.</li> </ul> <p>The current usage is published via the prometheus metrics endpoint as <code>memory_usage</code> and is reported in bytes.</p>","tags":["memory"]},{"location":"reference/memory/#headroom-and-load-shedding","title":"Headroom and Load Shedding","text":"<p>The memory headroom of the system is defined as the current value of <code>memory_limit - memory_usage</code>, clamping negative numbers to 0.</p> <p>If the memory headroom hits 0, at the point of transitioning from non-zero to zero, the system will take measures to scale back memory usage:</p> <ul> <li>Each ready queue will be walked and each message will be subject to   a shrink operation that will ensure that the message body is journalled   to spool (if using deferred spooling) and then free up the message body   memory.</li> <li>Each LRU cache in the system will be purged. The DNS subsystem, the   memoize function and DKIM signer caches are commonly used examples   of LRU caches</li> <li>If using RocksDB for the spool, RocksDB will be asked to flush any memtables   and caches.  You can monitor the usage of these objects via the   <code>rocks_spool_mem_table_total</code> and <code>rocks_spool_mem_table_readers_total</code>   prometheus metrics.</li> </ul> <p>While the system is operating with a memory headroom of 0 the liveness check will indicate that it is unhealthy and neither the SMTP or HTTP listeners will accept any new incoming messages.</p> <p>Once the system recovers and the headroom increases above zero, incoming messages will again be accepted and delivered.</p>","tags":["memory"]},{"location":"reference/memory/#passive-measures","title":"Passive Measures","text":"<p>In addition to the active measures when headroom reaches zero, there are a couple of passive measures:</p> <ul> <li> <p>The various thread pools in the system continuously signal to the jemalloc   allocator when they are idle, allowing memory to returned from its per-thread   caches and to make it available to other threads, or to be reclaimed.</p> </li> <li> <p>When the <code>memory_usage</code> is &gt;= 80% of the <code>memory_limit</code>, messages moving into   a ready queue, or being freshly inserted, will be subject to the same shrink   operation described above.  You may configure this value via   kumo.set_memory_low_thresh.</p> </li> </ul>","tags":["memory"]},{"location":"reference/memory/#budgetingtuning-memory","title":"Budgeting/Tuning Memory","text":"<p>Assuming ideal conditions, where the rate of egress is equal to the rate of ingress, the primary contributor to core memory usage is message bodies in the ready queue.</p> <p>The default fast path is that an incoming message is received and its body is retained in RAM until after the first delivery attempt.</p> <p>If your average message size is 100kb and you have <code>max_ready = 1000</code> then you are effectively budgeting <code>1000 x 100kb</code> of RAM for a given ready queue in its worst case.</p> <p>If you have <code>max_ready</code> set very large by default then you can increase memory pressure in the case where you have an issue with the rate of egress.</p> <p>In general you should size <code>max_ready</code> to be just large enough to accommodate your sustained egress rate for a given queue.  For example, if you have a throughput of <code>1000/s</code> then you might want to set <code>max_ready</code> to approximately <code>2000</code> in order to avoid transient delays if the ready queue is filled up.  The precise value for your system might be a slightly different single digit multiple of the per-second rate; this number is just a ballpark suggestion.</p> <p>Conversely, if your maximum egress rate is <code>1000/s</code> and you have over-provisioned <code>max_ready</code> to a very large number like <code>100,000</code>, and you have an issue where your egress rate drops to zero, then you will be allowing the system to use up to 50x as much memory as your normal rate of throughput would need.  If you have multiple queues over-provisioned in the same way, the system will be placed under a lot of memory pressure.</p> <p>The recommendation is to keep <code>max_ready</code> at a reasonably small value by default, but to increase it for your top-5 or top-10 destination sites by egress rate in order to achieve the sweet spot in throughput.</p>","tags":["memory"]},{"location":"reference/metadata/","title":"Predefined Metadata","text":"<p>KumoMTA provides the ability to set and retrieve metadata at both the connection and message level.</p> <p>By leveraging metadata, information can be made available to policy running at different phases in the life of a message, where the connection metadata is used for data that is shared in common with all messages injected over a given connection, and the message metadata is for all data related to a given individual message.</p> <p>There are get and set functions available for both connection and message metadata, and when a message is received all connection metadata is also copied into the message metadata, meaning that for retrieving connection metadata the user can opt to only access message metadata for any value that doesn't change over the life of the connection.</p> <p>The following metadata values are predefined by KumoMTA and are available to retrieve:</p> Scope Name Purpose Since Connection <code>reception_protocol</code> indicates the reception protocol, such as <code>ESMTP</code> (Since: Version 2023.08.22-4d895015) Connection <code>received_via</code> indicates the IP:port of the KumoMTA listener that is handling this session (Since: Version 2023.08.22-4d895015). For HTTP injections (Since: Version 2025.10.06-5ec871ab) Connection <code>orig_received_via</code> Set when XCLIENT or other similar proxying is active; it indicates the raw IP:port of the KumoMTA listener that is handling this session, independent of any adjustments applied by XCLIENT or proxy protocol (Since: Version 2025.10.06-5ec871ab) Connection <code>received_from</code> indicates the IP:port of the sending or peer machine in this session (Since: Version 2023.08.22-4d895015) Connection <code>orig_received_from</code> Set when XCLIENT or other similar proxying is active; it indicates the raw IP:port of the sending or peer machine in this session, independent of any adjustments applied by XCLIENT or proxy protocol (Since: Version 2025.10.06-5ec871ab) Connection <code>hostname</code> A copy of the effective value of the hostname set by kumo.start_esmtp_listener or kumo.start_http_listener (Since: Version 2023.11.28-b5252a41). For HTTP injections (Since: Version 2025.10.06-5ec871ab) Connection <code>authn_id</code> the authentication id if the message was received via authenticated SMTP Connection <code>authz_id</code> the authorization id if the message was received via authenticated SMTP Connection <code>ehlo_domain</code> the domain name that was passed in from the sender via the SMTP EHLO or HELO (Since: Version 2024.11.08-d383b033) Connection <code>tls_cipher</code> If STARTTLS was used, holds the negotiated TLS cipher name (Since: Version 2025.10.06-5ec871ab) Connection <code>tls_protocol_version</code> If STARTTLS was used, holds the negotiated TLS protocol version (Since: Version 2025.10.06-5ec871ab) Connection <code>tls_peer_subject_name</code> If STARTTLS was used, and the peer provided a client certificate, and the certificate matches up to the configured <code>tls_required_client_ca</code>, holds the subject name field of the verified peer certificate (Since: Version 2025.10.06-5ec871ab) Message <code>queue</code> specify the name of the queue to which the message will be queued. Must be a string value. Message <code>tenant</code> specify the name/identifier of the tenant, if any. Must be a string value. Message <code>campaign</code> specify the name/identifier of the campaign. Must be a string value. Message <code>routing_domain</code> Overrides the domain of the recipient domain for routing purposes. (Since: Version 2023.08.22-4d895015)","tags":["meta"]},{"location":"reference/queues/","title":"Queues, Sources, Pools","text":"<p>Messages are assigned to a Scheduled Queue upon reception. The system can support arbitrarily named queues but the convention is to construct the queue name from some metadata associated with the message:</p> <ul> <li><code>tenant</code> - some kind of sender or customer identifier or identity derived   either from the message itself or authentication of the injection session.</li> <li><code>campaign</code> - a sender-provided label that can be used to logically group a set   of related messages, perhaps generated from the same campaign.</li> <li>destination domain - the site where the email will be routed</li> <li><code>routing_domain</code> - (Since: Version 2023.08.22-4d895015) overrides the destination domain   for routing purposes.</li> </ul> <p>These three pieces of information are combined to produce the name of the queue in the form <code>campaign:tenant@domain</code>. You don't need to explicitly assign a campaign or a tenant. The queue name will be formed based on what is set:</p> <code>tenant</code> set? <code>campaign</code> set? <code>routing_domain</code> set? Resulting queue name yes yes no <code>campaign:tenant@domain</code> yes yes yes <code>campaign:tenant@domain!routing_domain</code> yes no no <code>tenant@domain</code> yes no yes <code>tenant@domain!routing_domain</code> no yes no <code>campaign:@domain</code> no yes yes <code>campaign:@domain!routing_domain</code> no no no <code>domain</code> no no yes <code>domain!routing_domain</code> <p>At reception, in your smtp_server_message_received event, you have the opportunity to set <code>tenant</code> and <code>campaign</code> meta values, if desired. By default, the queue associated with the message will be formed from those values as described above.</p> <p>You may also explicitly set the queue meta value directly.</p> <p>This is useful in some special cases. For example, there is a special <code>null</code> queue that simply discards any messages assigned to it, which is useful when implementing a sink for testing purposes:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  -- Accept and discard all messages\n  msg:set_meta('queue', 'null')\nend)\n</code></pre> <p>Note</p> <p>The <code>null</code> queue isn't an actual queue but rather a special name that is checked for only at the time a message is received. If the <code>queue</code> meta value is set to <code>null</code> prior to the insertion of the message into the queue system, it will discard the message.</p> <p>If you are considering eliminating a message after it has been received and placed into the queue system, assigning it to the <code>null</code> queue will not immediately eliminate the message from the spool.</p>"},{"location":"reference/queues/#egress-sources-and-pools","title":"Egress Sources and Pools","text":"<p>Once assigned to a Scheduled Queue, the system will attempt to deliver it. The first stage is to resolve the configuration for the queue by triggering the get_queue_config event.</p> <p>One of the queue configuration parameters is the name of the Egress Pool which should be used when delivering messages.</p> <p>A pool is a group of Egress Sources. Each source can be associated with a local IP address or configured to use an alternative destination port (and in the future: use the HAProxy protocol) as the source of the outgoing traffic to the destination domain.</p> <pre><code>local SOURCES = {\n  ['ip-1'] = {\n    source_address = '10.0.0.1',\n  },\n  ['ip-2'] = {\n    source_address = '10.0.0.2',\n  },\n  ['ip-3'] = {\n    source_address = '10.0.0.3',\n  },\n}\n\nlocal POOLS = {\n  ['pool1'] = {\n    { name = 'ip-1' },\n  },\n  ['pool2'] = {\n    { name = 'ip-2', weight = 2 },\n    -- we're warming up ip-3, so use it less frequently than ip-2\n    { name = 'ip-3', weight = 1 },\n  },\n}\n\nlocal TENANT_TO_POOL = {\n  ['tenant-1'] = 'pool1',\n  ['tenant-2'] = 'pool2',\n  ['tenant-3'] = 'pool1',\n}\n\nkumo.on('get_egress_pool', function(pool_name)\n  local pool = {\n    name = pool_name,\n    entries = POOLS[pool_name],\n  }\n  return kumo.make_egress_pool(pool)\nend)\n\nkumo.on('get_egress_source', function(source_name)\n  local params = SOURCES[source_name]\n  params.name = source_name\n  return kumo.make_egress_source(params)\nend)\n\nkumo.on(\n  'get_queue_config',\n  function(domain_name, tenant, campaign, routing_domain)\n    return kumo.make_queue_config {\n      egress_pool = TENANT_TO_POOL[tenant],\n    }\n  end\n)\n</code></pre> <p>When a message in a given queue is ready for delivery, it will use the configured pool to set up an Egress Path for the message to reach its destination. It will pick a source using weighted round robin from the entries in the pool, and call your get_egress_path_config event to resolve options to control how it will do that.</p> <p>The parameters to that event are:</p> <ul> <li>domain - the destination domain name</li> <li>egress_source - the selected egress source</li> <li>site_name - a string deterministically derived from the MX record for domain.</li> </ul> <p>The site_name concept allows managing traffic more effectively for domains that have several or even a great many aliases. Rather than treating each domain as a separate destination, the traffic can be grouped together and managed more closely to how the receiving site sees it: as one source.</p> <p>With that in mind, the egress path is internally identified by the combination of the egress_source and the site_name.</p> <pre><code>-- Build a mapping from a domain name to the \"site name\"\n-- You'll likely want this to list the major domains for which there are\n-- several aliases. You only need populate entries for the big aliased\n-- domains; you needn't specify any of the aliases here.\nlocal SITE_OF = {}\nfor _, domain in ipairs { 'gmail.com', 'yahoo.com' } do\n  SITE_OF[domain] = kumo.dns.lookup_mx(domain).site_name\nend\n-- SITE_OF is now equivalent to:\n-- local SITE_OF = {\n--   [\"gmail.com\"] = \"(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com\",\n--   [\"yahoo.com\"] = \"(mta5|mta6|mta7).am0.yahoodns.net\"\n-- }\n\n-- This table is keyed by either site name or domain name.\n-- Site names are looked up first, then domain names.\nlocal SHAPE_BY_DOMAIN = {\n  [SITE_OF['gmail.com']] = {\n    -- appropriate general configuration when communicating\n    -- with any domain that shares gmail.com's MXs\n    max_connection_rate = '1000/hr',\n  },\n  ['example.com'] = {\n    -- appropriate general configuration when communicating\n    -- specifically with example.com\n    max_connection_rate = '10/hr',\n  },\n}\n\n-- This table is keyed by the tuple of (site_name, source) or (domain, source).\n-- Site names are looked up first, then domain names.\n-- Values override/overlay those in SHAPE_BY_DOMAIN.\nlocal SHAPE_BY_SOURCE = {\n  [{ SITE_OF['gmail.com'], 'ip-1' }] = {\n    -- appropriate configuration for your source when communicating\n    -- with any domain that shares gmail.com's MXs\n    max_message_rate = '1000/hr',\n  },\n}\n\nfunction merge_into(src, dest)\n  for k, v in pairs(src) do\n    dest[k] = v\n  end\nend\n\nkumo.on('get_egress_path_config', function(domain, egress_source, site_name)\n  -- resolve parameters first based on the site, if any,\n  -- then based on the domain, if any,\n  -- otherwise use the system defaults\n  local domain_params = SHAPE_BY_DOMAIN[site_name]\n    or SHAPE_BY_DOMAIN[domain]\n    or {}\n  local source_params = SHAPE_BY_SOURCE[{ site_name, egress_source }]\n    or SHAPE_BY_SOURCE[{ domain, egress_source }]\n    or {}\n  -- compose the source params over the domain params\n  local params = {}\n  merge_into(domain_params, params)\n  merge_into(source_params, params)\n  return kumo.make_egress_path(params)\nend)\n</code></pre>"},{"location":"reference/queues/#message-flow","title":"Message Flow","text":"<pre><code>graph TD\n   SQ[\"Scheduled Queue: campaign:tenant\\@domain.com\"]\n   SMTPL[\"ESMTP Listener\"]\n   HTTPI[\"Injection API\"]\n   RQ1[\"Ready Queue: 10.0.0.1-&gt;MX(domain.com)\"]\n   RQ2[\"Ready Queue: 10.0.0.2-&gt;MX(domain.com)\"]\n   POOL[\"egress pool\"]\n   IP1[\"Source: 10.0.0.1\"]\n   IP2[\"Source: 10.0.0.2\"]\n   MAINT[\"Queue Maintainer\"]\n   DESTSITE[\"domain.com\"]\n\n   SMTPL --&gt; SQ\n   HTTPI --&gt; SQ\n   SQ --&gt; MAINT\n   IP1 --&gt; POOL\n   IP2 --&gt; POOL\n   POOL -- per tenant:domain config --&gt; MAINT\n   MAINT -- throttle per tenant:domain config --&gt; RQ1\n   MAINT -- throttle per tenant:domain config --&gt; RQ2\n   RQ1 -- throttle per source:domain config&lt;br&gt;connect via 10.0.0.1 --&gt; DESTSITE\n   RQ2 -- throttle per source:domain config&lt;br&gt;connect via 10.0.0.2 --&gt; DESTSITE</code></pre>"},{"location":"reference/smtp_server_events/","title":"SMTP Server Events","text":"<p>The following sequence diagram shows the ordering of the various SMTP server Lua events that are triggered by the SMTP listener in response to SMTP commands issued by the client.</p> <pre><code>sequenceDiagram\n  participant C as Client\n  participant S as SMTP Listener\n  participant Lua\n\n  C-&gt;&gt;S: establish TCP connection\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_connection_accepted\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_get_dynamic_parameters\n  Note right of S: Listener parameters&lt;br&gt;are now decided\n  S-&gt;&gt;C: 250 banner\n\n  C-&gt;&gt;S: EHLO example.com\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_ehlo\n  S-&gt;&gt;C: 250 OK\n\n  C-&gt;&gt;S: MAIL FROM: &lt;sender@example.com&gt;\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_mail_from\n  S-&gt;&gt;C: 250 OK\n\n  C-&gt;&gt;S: RCPT TO: &lt;recip@example.com&gt;\n  S&lt;&lt;-&gt;&gt;Lua: get_listener_domain(MAIL FROM)\n  S&lt;&lt;-&gt;&gt;Lua: get_listener_domain(RCPT TO)\n  Note right of S: check relaying\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_rcpt_to\n  S-&gt;&gt;C: 250 OK\n\n  C-&gt;&gt;S: DATA\n  S-&gt;&gt;C: 354 send message\n  C-&gt;&gt;S: message / CRLF.CRLF\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_data\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_split_transaction\n  Note right of S: following steps are per split message\n  Note right of S: add trace/supplemental headers\n  S&lt;&lt;-&gt;&gt;Lua: smtp_server_message_received\n  S&lt;&lt;-&gt;&gt;Lua: get_listener_domain(MAIL FROM)\n  S&lt;&lt;-&gt;&gt;Lua: get_listener_domain(RCPT TO)\n  Note right of S: check relaying\n  S&lt;&lt;-&gt;&gt;Lua: get_queue_config\n  Note right of S: insert into queue\n  Note right of S: return overall status across&lt;br&gt;all split messages\n  S-&gt;&gt;C: 250 OK</code></pre> <p>Note</p> <p>While the diagram above shows <code>Lua</code> as a single actor, each lua event callout is likely to run in a distinct, separate, lua context.</p> <p>Here's a list of links to the docs for the various events in the diagram above, listed in the same sequence as the diagram:</p> <ul> <li>smtp_server_connection_accepted</li> <li>smtp_server_get_dynamic_parameters</li> <li>smtp_server_ehlo</li> <li>smtp_server_mail_from</li> <li>get_listener_domain</li> <li>smtp_server_rcpt_to</li> <li>smtp_server_data</li> <li>smtp_server_split_transaction</li> <li>smtp_server_message_received</li> <li>get_queue_config</li> </ul>"},{"location":"reference/address/","title":"EnvelopeAddress object","text":"<p>Represents a sender or recipient of a message.</p> <p>Note that you can use <code>tostring(address)</code> to get the address as a string.</p>"},{"location":"reference/address/domain/","title":"domain","text":"<pre><code>local domain = address.domain\n</code></pre> <p>Returns the domain portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>address.domain</code> will evaluate as <code>\"example.com\"</code>.</p> <p>See also address.user.</p>"},{"location":"reference/address/email/","title":"email","text":"<pre><code>local email = address.email\n</code></pre> <p>Returns the full user@domain version of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>address.email</code> will evaluate as <code>\"first.last@example.com\"</code>.</p> <p>See also address.user.</p>"},{"location":"reference/address/user/","title":"user","text":"<pre><code>local user = address.user\n</code></pre> <p>Returns the mailbox portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>address.user</code> will evaluate as <code>\"first.last\"</code>.</p> <p>See also address.domain.</p>"},{"location":"reference/addressheader/","title":"AddressHeader object","text":"<p>Represents the parsed form of an email header that holds email addresses, such as <code>\"From\"</code> and <code>\"To\"</code> headers.</p> <p>As these headers can contain lists of addresses and groups of addresses, care needs to be taken when processing them.</p> <p>Convenience accessors for the common case of a single address are provided, but they will raise an error when used on an address that is not a simple single address.</p> <p>The addressheader.list field can be used to safely operate on the parsed out set of addresses, regardless of how many are present.</p> <p>Note that you can use <code>tostring(address)</code> to get a JSON rendition of the parsed address information.</p>"},{"location":"reference/addressheader/domain/","title":"domain","text":"<pre><code>local domain = addressheader.domain\n</code></pre> <p>If the address header consists of a single simple address, returns the domain portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>addressheader.domain</code> will evaluate as <code>\"example.com\"</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>See also addressheader.user, addressheader.name.</p>"},{"location":"reference/addressheader/email/","title":"email","text":"<pre><code>local email = addressheader.email\n</code></pre> <p>If the address header consists of a single simple address, returns the email address portion of the address. For example, if the address is <code>\"John Smith &lt;first.last@example.com&gt;</code>, <code>addressheader.email</code> will evaluate as <code>first.last@example.com</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>If the address header is a single simple address, but has no email address, returns <code>nil</code>.</p>"},{"location":"reference/addressheader/list/","title":"list","text":"<pre><code>local list = addressheader.list\n</code></pre> <p>Returns a lua table consisting of one entry per address in the header. Each entry is a single simple address object that has <code>domain</code>, <code>user</code>, <code>email</code> and <code>name</code> fields with the same semantics as <code>addressheader</code>.</p> <pre><code>for _, address in ipairs(msg:to_header().list) do\n  print('to entry', address)\n  -- prints something like:\n  -- to entry      {\"name\":null,\"address\":\"user@example.com\"}\n  -- to entry      {\"name\":\"John Smith\",\"address\":\"john.smith@example.com\"}\nend\n</code></pre>"},{"location":"reference/addressheader/name/","title":"name","text":"<pre><code>local name = addressheader.name\n</code></pre> <p>If the address header consists of a single simple address, returns the display name portion of the address. For example, if the address is <code>\"John Smith &lt;first.last@example.com&gt;</code>, <code>addressheader.name</code> will evaluate as <code>\"John Smith\"</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>If the address header is a single simple address, but has no display name, returns <code>nil</code>.</p> <p>See also addressheader.user, addressheader.domain.</p>"},{"location":"reference/addressheader/user/","title":"user","text":"<pre><code>local user = addressheader.user\n</code></pre> <p>If the address header consists of a single simple address, returns the mailbox portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>addressheader.domain</code> will evaluate as <code>\"first.last\"</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>See also addressheader.domain, addressheader.name.</p>"},{"location":"reference/events/get_acl_definition/","title":"get_acl_definition","text":"<pre><code>kumo.on('get_acl_definition', function(resource) end)\n</code></pre> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>This event is called when the system is performing an authorization check.  Its purpose is to provide the definition of an Access Control List (ACL) for the requested resource.</p> <p>If the event returns <code>nil</code>, or doesn't return any explicit value, or is not defined, then the default behavior will be to consider the product default ACL Map and use the definition provided by that map, if any.</p>","tags":["aaa"]},{"location":"reference/events/get_acl_definition/#augmenting-the-default-acl","title":"Augmenting the default ACL","text":"<p>The following example shows how you might define your own augmented ACL definitions in a file named <code>/opt/kumomta/etc/custom_acl.toml</code> that will be refreshed every 5 minutes (to pick up any changes):</p> <pre><code>local get_acl_map = kumo.memoize(function()\n  return kumo.aaa.load_acl_map '/opt/kumomta/etc/custom_acl.toml'\nend, {\n  name = 'acl_map_cache',\n  ttl = '5 minutes',\n  capacity = 4,\n})\n\nkumo.on('get_acl_definition', function(resource)\n  return get_acl_map():get(resource)\nend)\n</code></pre> <p>Entries that you define in your custom ACL file will take the place of entries in the product default ACL for a given resource; there is no merging of entries.</p> <p>See also: kumo.aaa.load_acl_map.</p>","tags":["aaa"]},{"location":"reference/events/get_acl_definition/#replacing-the-default-acl","title":"Replacing the default ACL","text":"<p>The following is essentially the same as the example above, except that it disables the fall back to the product default ACL map</p> <pre><code>local get_acl_map = kumo.memoize(function()\n  return kumo.aaa.load_acl_map '/opt/kumomta/etc/custom_acl.toml'\nend, {\n  name = 'acl_map_cache',\n  ttl = '5 minutes',\n  capacity = 4,\n})\n\nkumo.on('get_acl_definition', function(resource)\n  return get_acl_map():get(resource)\nend)\n\nkumo.on('pre_init', function()\n  -- the `custom_acl.toml` is now considered to be the exhaustive,\n  -- definitive source of ACL definitions.  The product default\n  -- definitions will not be considered\n  kumo.aaa.set_fall_back_to_acl_map(false)\nend)\n</code></pre> <p>See also: kumo.aaa.load_acl_map.</p>","tags":["aaa"]},{"location":"reference/events/get_acl_definition/#advanced-acl-building","title":"Advanced ACL Building","text":"<p>You don't have to load ACLs using the TOML file syntax, you can instead build up rules entirely in lua code.</p> <p>The following example builds an ACL for a hypothetical <code>/api/admin/baz</code> HTTP endpoint:</p> <pre><code>kumo.on('get_acl_definition', function(resource)\n  if resource == 'http_listener/*/api/admin/baz' then\n    return kumo.aaa.make_access_control_list {\n      {\n        criteria = {\n          Identity = { Group = 'kumomta:http-listener-trusted-ip' },\n        },\n        privilege = 'GET',\n        access = 'Allow',\n      },\n    }\n  end\n  -- Use the product default for everything else\n  return nil\nend)\n</code></pre> <p>See also: kumo.aaa.make_access_control_list.</p>","tags":["aaa"]},{"location":"reference/events/get_egress_path_config/","title":"get_egress_path_config","text":"<pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name) end\n)\n</code></pre> <p>The <code>routing_domain</code> parameter corresponds to the effective <code>routing_domain</code> of the originating scheduled queue.  This will be the same as the recipient domain unless the message had set the <code>routing_domain</code> meta value.</p> <p>An implementation for this event can be provided only once.</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      enable_tls = 'OpportunisticInsecure',\n    }\n  end\n)\n</code></pre> <p>See also kumo.make_egress_path.</p>"},{"location":"reference/events/get_egress_pool/","title":"get_egress_pool","text":"<pre><code>kumo.on('get_egress_pool', function(pool_name) end)\n</code></pre> <p>Called by the system to determine the composition of a specific named egress pool.</p> <pre><code>kumo.on('get_egress_pool', function(pool_name)\n  return kumo.make_egress_pool {\n    name = pool_name,\n    entries = {\n      { name = 'ip-1' },\n    },\n  }\nend)\n</code></pre> <p>See also kumo.make_egress_source.</p>"},{"location":"reference/events/get_egress_source/","title":"get_egress_source","text":"<pre><code>kumo.on('get_egress_source', function(source_name) end)\n</code></pre> <p>Called by the system to determine the composition of a specific named egress source.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  return kumo.make_egress_source {\n    name = source_name,\n    -- other fields here\n  }\nend)\n</code></pre> <p>See also kumo.make_egress_source.</p>"},{"location":"reference/events/get_listener_domain/","title":"get_listener_domain","text":"<pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta) end)\n</code></pre> <p>This event is triggered by the SMTP server to retrieve information about either a source or destination domain to help determine whether the message should be accepted/logged/relayed.</p> <p>The listener parameter is the listener endpoint on which the message is being delivered.  You can use this to vary behavior depending on the listener address.</p> <p>When the SMTP <code>RCPT TO</code> command is issued by the client, the destination domain is passed as the domain parameter to this event.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>The event is expected to return a listener-domain object constructed by a call to kumo.make_listener_domain, or a <code>nil</code> value to indicate that there is no explicit configuration.</p> <p>If none of <code>log_relay</code>, <code>log_oob</code> or <code>log_arf</code> are set in the returned listener-domain object to a value that allows the reception of a message, then the <code>RCPT TO</code> command is rejected.</p> <p>Once the <code>DATA</code> stage has transmitted the message content, and after the smtp_server_message_received event has been processed, and the reception logged (which is where OOB and FBL data is parsed and logged), the recipient domain is passed to this event as the domain parameter. If <code>relay_to</code> is <code>false</code> in the returned listener-domain object, then the message will not be spooled and that will be the end of its processing.</p> <p>See kumo.make_listener_domain for some more examples.</p>"},{"location":"reference/events/get_queue_config/","title":"get_queue_config","text":"<pre><code>kumo.on(\n  'get_queue_config',\n  function(domain, tenant, campaign, routing_domain) end\n)\n</code></pre> <p>The parameters correspond to the <code>domain</code>, <code>tenant</code>, <code>campaign</code> and <code>routing_domain</code> fields from the scheduled queue name, as discussed in Queues.</p> <pre><code>kumo.on(\n  'get_queue_config',\n  function(domain_name, tenant, campaign, routing_domain)\n    return kumo.make_queue_config {\n      max_retry_interval = '20 minutes',\n    }\n  end\n)\n</code></pre> <p>See also kumo.make_queue_config.</p> <p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>It is now possible to use <code>kumo.on</code> to register multiple handlers for this event.  The handlers will be called in the order that they were registered.  If a handler returns <code>nil</code> then the next handler will be called. Conversely, if a handler returns a queue configuration object, no further handlers will be called.</p> <p>This behavior is intended to make it easier to compose multiple helpers or lua modules together.</p>"},{"location":"reference/events/http_message_generated/","title":"http_message_generated","text":"<pre><code>kumo.on('http_message_generated', function(message, auth_info) end)\n</code></pre> <p>Called by the HTTP injection API endpoint after generating a message, but prior to injecting it into the queue.</p> <p>The event handler will be passed a Message object, as well as an AuthInfo (Since: Dev Builds Only) that can be used to implement more granular access control policies.</p> <p>The HTTP injector does not add a <code>Received</code> header, but it will pre-set the following meta values in the message:</p> <ul> <li><code>\"http_auth\"</code> - will hold either the authenticated username or the peer IP   address that satisfied the authentication check for the endpoint.</li> </ul> <p>This event is the best place to carry out a number of important policy decisions:</p> <ul> <li>DKIM signing via message:dkim_sign.</li> <li>Assigning the <code>\"campaign\"</code>, <code>\"tenant\"</code> and/or <code>\"queue\"</code> meta values via msg:set_meta</li> </ul> <p>You may use kumo.reject to raise an error to prevent this message from being queued for delivery.</p> <pre><code>kumo.on('http_message_generated', function(msg, auth_info)\n  local signer = kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.pem',\n  }\n  msg:dkim_sign(signer)\nend)\n</code></pre>"},{"location":"reference/events/http_server_validate_auth_basic/","title":"http_server_validate_auth_basic","text":"<pre><code>kumo.on('http_server_validate_auth_basic', function(USER, PASSWORD) end)\n</code></pre> <p>Called by the HTTP listener to validate HTTP Basic authentication credentials provided by the client.</p> <p>At the time of writing KumoMTA doesn't provide a general authentication solution, but through the use of this callback, you have some flexibility.</p> <p>The event handler receives the username and password provided by the client. Note that the password may be empty or missing if the client provided only a user name.</p> <p>The HTTP server expects the event handler to return a bool value; if it returns <code>true</code> then it considers the credentials to be valid and will allow the client to access the endpoint. If it returns <code>false</code> then it will consider the credentials to be invalid and return a authorization error. Other return values, or raising an error, will return an error status to the client.</p> <p>This example shows how to implement a very simple inline password database using a lua table:</p> <pre><code>-- Use this to lookup and confirm a user/password credential\n-- used with the http endpoint\nkumo.on('http_server_validate_auth_basic', function(user, password)\n  -- This is just an example of how to populate the return value,\n  -- not a recommended way to handle passwords in production!\n  -- In particular, it is an absolutely terrible idea to hard code\n  -- a password here in plain text!\n  local password_database = {\n    ['daniel'] = 'tiger',\n  }\n  if password == '' then\n    return false\n  end\n  return password_database[user] == password\nend)\n</code></pre>"},{"location":"reference/events/http_server_validate_auth_basic/#reasoning-about-the-authorized-identity","title":"Reasoning about the authorized identity","text":"<p>When using auth to grant access to the HTTP injection API, the authorization identity will be made available in the generated message by setting the <code>http_auth</code> meta key.  It can have one of the following values:</p> <ul> <li>When HTTP Basic auth is used (and validated via the   <code>http_server_validate_auth_basic</code> event), it will be set to the provided   username</li> <li>When no HTTP auth is used, access is granted based on the   trusted_hosts. In this case,   <code>http_auth</code> will be set to the peer address that matched the <code>trusted_hosts</code></li> </ul> <p>If you wish to enforce or restrict some capability based on identity, you might use logic along the lines of:</p> <pre><code>kumo.on('http_message_generated', function(msg)\n  local auth = msg:get_meta 'http_auth'\n  if auth ~= 'some.one' then\n    error 'only some.one is allowed to inject'\n  end\nend)\n</code></pre>"},{"location":"reference/events/http_server_validate_auth_basic/#returning-group-and-identity-information","title":"Returning Group and identity Information","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Rather than just returning a boolean to indicate whether authentication was successful, you may now return an AuthInfo object holding additional information.  Here's an expanded version of the example above that shows how you can return group membership:</p> <pre><code>-- This is just an example of how to populate the return value,\n-- not a recommended way to handle passwords in production!\n-- In particular, it is an absolutely terrible idea to hard code\n-- a password here in plain text!\n\nlocal password_database = {\n  ['daniel'] = {\n    password = 'tiger',\n    groups = { 'group1', 'group2' },\n  },\n}\n\nkumo.on('http_server_validate_auth_basic', function(user, password)\n  local entry = password_database[user]\n  if not entry then\n    return false\n  end\n  if entry.password ~= password then\n    return false\n  end\n\n  -- Return an AuthInfo that lists out the identity and group\n  -- membership\n  return {\n    identities = {\n      { identity = user, context = 'HttpBasicAuth' },\n    },\n    groups = entry.groups,\n  }\nend)\n</code></pre>"},{"location":"reference/events/init/","title":"init","text":"<pre><code>kumo.on('init', function() end)\n</code></pre> <p>The <code>init</code> event is triggered once when the <code>kumod</code> process initializes. The intent is that you use this event to define the spool storage and listeners for your environment.</p> <p>The event handler is not passed any parameters, and does not expect any particular return value.</p> <pre><code>-- Called on startup to initialize the system\nkumo.on('init', function()\n  -- Define a listener.\n  -- Can be used multiple times with different parameters to\n  -- define multiple listeners!\n  kumo.start_esmtp_listener {\n    listen = '0.0.0.0:2025',\n  }\n\n  kumo.configure_local_logs {\n    log_dir = '/var/tmp/kumo-logs',\n  }\n\n  kumo.start_http_listener {\n    listen = '0.0.0.0:8000',\n    -- allowed to access any http endpoint without additional auth\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\n\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/tmp/kumo-spool/data',\n  }\n\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/tmp/kumo-spool/meta',\n  }\nend)\n</code></pre>"},{"location":"reference/events/pre_init/","title":"pre_init","text":"<pre><code>kumo.on('pre_init', function() end)\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>The <code>pre_init</code> event is triggered once when the <code>kumod</code> process initializes, prior to triggering the init event.</p> <p><code>pre_init</code> can be registered multiple times.</p> <p>The intended purpose of this event is to be used by lua helper modules to aid in building up optional modular functionality.</p>"},{"location":"reference/events/proxy_init/","title":"proxy_init","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>The <code>proxy_init</code> event is triggered when the proxy server starts up.</p> <p>Note</p> <p>This event is only available to the <code>proxy-server</code> executable.</p> <p>This is where you should configure your proxy listeners and any other initialization tasks for the proxy server.</p> <pre><code>local kumo = require 'kumo'\nlocal proxy = require 'proxy'\n\nkumo.on('proxy_init', function()\n  -- Start SOCKS5 proxy listener\n  proxy.start_proxy_listener {\n    listen = '0.0.0.0:1080',\n    timeout = '60 seconds',\n  }\n\n  -- Start HTTP listener for metrics and administration\n  proxy.start_http_listener {\n    listen = '0.0.0.0:8080',\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\nend)\n</code></pre>"},{"location":"reference/events/proxy_server_auth_rfc1929/","title":"proxy_server_auth_rfc1929","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.on(\n  'proxy_server_auth_rfc1929',\n  function(username, password, conn_meta) end\n)\n</code></pre> <p>Called by the proxy server when a client attempts RFC 1929 username/password authentication.</p> <p>Note</p> <p>This event is only available to the <code>proxy-server</code> executable.</p> <p>This event is triggered when require_auth is enabled on the proxy listener, or when a client offers username/password authentication even if not required.</p> <p>The event handler receives the following parameters:</p> <ul> <li>username - the username provided by the client</li> <li>password - the password provided by the client</li> <li>conn_meta - a table containing connection metadata:<ul> <li><code>peer_address</code> - the client's socket address (IP and port)</li> <li><code>local_address</code> - the server's socket address (IP and port)</li> </ul> </li> </ul> <p>The proxy server expects the event handler to return either a bool value or an <code>AuthInfo</code> value.</p> <p>If it returns <code>true</code> then it considers the credentials to be valid and will allow the client to use the proxy. If it returns <code>false</code> then the authentication attempt is considered to have failed and the connection will be closed.</p> <p>This example shows how to implement a simple inline password database:</p> <pre><code>kumo.on('proxy_server_auth_rfc1929', function(username, password, conn_meta)\n  -- This is just an example of how to populate the return value,\n  -- not a recommended way to handle passwords in production!\n  local password_database = {\n    ['proxyuser'] = 'secretpassword',\n  }\n  if password == '' then\n    return false\n  end\n  return password_database[username] == password\nend)\n</code></pre>"},{"location":"reference/events/proxy_server_auth_rfc1929/#returning-group-and-identity-information","title":"Returning Group and Identity Information","text":"<p>Rather than just returning a boolean to indicate whether authentication was successful, you may return an AuthInfo object holding additional information. Here's an expanded version of the example above that shows how you can return group membership:</p> <pre><code>local password_database = {\n  ['proxyuser'] = {\n    password = 'secretpassword',\n    groups = { 'proxy-users', 'premium-tier' },\n  },\n}\n\nkumo.on('proxy_server_auth_rfc1929', function(username, password, conn_meta)\n  local entry = password_database[username]\n  if not entry then\n    return false\n  end\n  if entry.password ~= password then\n    return false\n  end\n\n  -- Return an AuthInfo that lists the identity and group membership\n  return {\n    identities = {\n      { identity = username, context = 'ProxyAuthRfc1929' },\n    },\n    groups = entry.groups,\n  }\nend)\n</code></pre>"},{"location":"reference/events/rebind_message/","title":"rebind_message","text":"<pre><code>kumo.on('rebind_message', function(message, data) end)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>This event is triggered when processing a rebind request that was triggered by the /api/admin/rebind/v1 HTTP endpoint (which is is what is used by the <code>kcli rebind</code> command).</p> <p>This event is only triggered when <code>trigger_rebind_event</code> is set in the incoming request.</p> <p>The purpose of the event is for you to perform an optional, site-specific modification to the message and/or its metadata in response to the rebind request.</p> <p>The <code>data</code> parameter is the verbatim <code>data</code> field from the request.</p> <pre><code>kumo.on('rebind_message', function(msg, data)\n  if some_condition then\n    msg:set_meta('queue', data.queue)\n  end\nend)\n</code></pre>"},{"location":"reference/events/requeue_message/","title":"requeue_message","text":"<pre><code>kumo.on(\n  'requeue_message',\n  function(\n    message,\n    smtp_response,\n    insert_context,\n    increment_attempts,\n    delay\n  )\n  end\n)\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>This event was actually added in <code>2024.06.10-84e84b89</code> but under the erroneous name <code>message_requeued</code>, and with a broken event registration that prevented it from working. That was corrected in the version shown above when the <code>smtp_response</code> parameter was added.</p> <p>This event is triggered when a message encountered a transient failure and will be re-inserted into an appropriate scheduled queue.</p> <p>Its purpose is to allow you to re-bind the message to an alternative queue, perhaps to relay it via an alternate tier or to use an alternative pool for egress.</p> <p>This event has evolved to include more context over time.  The meaning of each parameter, along with the version in which it was introduced, is shown below:</p> <ul> <li><code>message</code> - is the Message object which is being re-queued.</li> <li><code>smtp_response</code> is a one-line rendition of the SMTP response that resulted      in the message being requeued. There are a couple of internal triggers for      a requeue that are not directly caused by an SMTP response. Those      responses have <code>KumoMTA internal:</code> prefixed the to textual portion of the      response.</li> <li> <p><code>insert_context</code> (Since: Dev Builds Only) is an array holding the      reason(s) why the message is being inserted into the queue manager.  There      will typically be 1 reason, but it is possible to have multiple reasons to      indicate eg: that we just received or loaded a message from spool and then      encountered a transient failure.  Each element of the array is a string.      Possible reasons include:</p> <ul> <li><code>\"Received\"</code> - Message was just received.</li> <li><code>\"Enumerated\"</code> - Message was just loaded from spool</li> <li><code>\"ScheduledForLater\"</code> - Message had its due time explicitly set.</li> <li><code>\"ReadyQueueWasSuspended\"</code></li> <li><code>\"MessageRateThrottle\"</code></li> <li><code>\"ThrottledByThrottleInsertReadyQueue\"</code></li> <li><code>\"ReadyQueueWasFull\"</code></li> <li><code>\"FailedToInsertIntoReadyQueue\"</code></li> <li><code>\"MessageGetQueueNameFailed\"</code></li> <li><code>\"AdminRebind\"</code></li> <li><code>\"DueTimeWasReached\"</code></li> <li><code>\"MaxReadyWasReducedByConfigUpdate\"</code></li> <li><code>\"ReadyQueueWasDelayedDueToLowMemory\"</code></li> <li><code>\"FailedDueToNullMx\"</code></li> <li><code>\"MxResolvedToZeroHosts\"</code></li> <li><code>\"MxWasProhibited\"</code></li> <li><code>\"MxWasSkipped\"</code></li> <li><code>\"TooManyConnectionFailures\"</code></li> <li><code>\"TooManyRecipients\"</code></li> <li><code>\"ConnectionRateThrottle\"</code></li> <li><code>\"LoggedTransientFailure\"</code> - There was a TransientFailure logged to      explain what really happened.  The information contained in the reason      may not represent the full extent of the situation.</li> </ul> </li> <li> <p><code>increment_attempts</code> (Since: Dev Builds Only) - a boolean value      that will be set to <code>true</code> if the number of attempts on the message      would be incremented as part of normal processing of the requeue      event.  Not every requeue situation will increment this counter.</p> </li> <li><code>delay</code> (Since: Dev Builds Only) a TimeDelta      object indicating a suggested delay to be applied to the message.      This will typically be <code>nil</code> which indicates that the usual retry      parameters for the associated queue should be used, but in some      cases (eg: throttling) it may be set to a duration indicating      when the throttle may open back up.</li> </ul> <p>Multiple instances of the <code>requeue_message</code> event can be registered, and they will be called in the order in which they were registered, until all registered events are called, or until one explicitly returns <code>nil</code> to signal that no more should be triggered.</p> <p>The event is triggered prior to incrementing the number of attempts, so <code>message:num_attempts()</code> will return one less than the current number.</p> <p>In order to re-bind the message you will typically alter one or more of the meta values of the message that impact the queue name:</p> <ul> <li><code>queue</code></li> <li><code>routing_domain</code></li> <li><code>tenant</code></li> <li><code>campaign</code></li> </ul> <p>See Queues for more information.</p> <p>If the effective queue name for the message is changed as a result of dispatching the <code>requeue_message</code> event, then the message will be immediately eligible for delivery in the context of its new queue, however, if the message has scheduling constraints set via msg:set_scheduling those will remain in effect unless you explicitly clear them.  The reason for this is that kumod doesn't have any implicit knowledge of the semantics of the queue, so it doesn't know whether the scheduling constraints should remain in force or not.</p> <p>In the example below, a message is re-routed to a smart host after the third attempt to send it encounters a transient failure.</p> <pre><code>local SMART_HOST = '[10.0.0.1]'\n\nkumo.on(\n  'requeue_message',\n  function(msg, smtp_response, insert_context, increment_attempts, delay)\n    local queue = msg:queue_name()\n    if queue ~= SMART_HOST and msg:num_attempts() &gt;= 2 then\n      -- Re-route to alternative infra to manage the rest of the send\n      msg:set_meta('queue', SMART_HOST)\n      -- clear any scheduling constraints, as they do not apply\n      -- when sending via a smart host\n      msg:set_scheduling(nil)\n    end\n  end\n)\n</code></pre> <p>Calling kumo.reject to raise an error in your event handler (regardless of the code parameter passed to <code>kumo.reject</code>) will cause the message to bounced; a <code>Bounce</code> record will be logged and the message will be removed from the spool.</p> <p>Any other kind of error raised by the event handler will cause the error to be logged to the diagnostic log, and the message returned to its original scheduled queue.</p>"},{"location":"reference/events/should_enqueue_log_record/","title":"should_enqueue_log_record","text":"<pre><code>kumo.on('should_enqueue_log_record', function(message, hook_name) end)\n</code></pre> <p>This event is triggered when kumo.configure_log_hook has been used to enable it.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The hook_name parameter was added. It corresponds to the name field that was passed to <code>kumo.configure_log_hook</code> and is present to allow you to decide whether a given message should get queued for a given hook instance.</p> <p>When enabled, each log record will generate a new Message object with the following attributes:</p> <ul> <li>Sender will be set to the sender of the originating message</li> <li>Recipient will be set to the recipient of the originating message</li> <li>the <code>log_record</code> meta value will be set to the   Log Record that is being logged</li> <li>The message body/data will be set to the textual representation of the log   record. By default this will be the JSON serialization of the log record, but   if you have enabled templating using the <code>per_record</code> parameter to   kumo.configure_log_hook then it will be   whatever your template evaluated to for that record.</li> <li>The <code>reception_protocol</code> meta value will be set to <code>\"LogRecord\"</code></li> </ul> <p>That log message is passed to the <code>should_enqueue_log_record</code> hook, which must return a boolean value that indicates whether the log message should be queued and acted upon (return true), or whether the log message should be discarded.</p> <pre><code>kumo.on('should_enqueue_log_record', function(msg, hook_name)\n  local log_record = msg:get_meta 'log_record'\n  -- avoid an infinite loop caused by logging that we logged that we logged...\n  -- Check the log record: if the record was destined for the webhook queue\n  -- then it was a record of the webhook delivery attempt and we must not\n  -- log its outcome via the webhook.\n  if log_record.queue ~= 'webhook' then\n    -- was some other event that we want to log via the webhook\n    msg:set_meta('queue', 'webhook')\n    return true\n  end\n  return false\nend)\n\n-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- It returns a lua connection object that can be used to \"send\"\n-- messages to their destination.\nkumo.on('make.webhook', function(domain, tenant, campaign)\n  local connection = {}\n  local client = kumo.http.build_client {}\n  function connection:send(message)\n    local response = client\n      :post(string.format('http://127.0.0.1:%d/log', WEBHOOK_PORT))\n      :header('Content-Type', 'application/json')\n      :body(message:get_data())\n      :send()\n\n    local disposition = string.format(\n      '%d %s: %s',\n      response:status_code(),\n      response:status_reason(),\n      response:text()\n    )\n\n    if response:status_is_success() then\n      return disposition\n    end\n\n    -- Signal that the webhook request failed.\n    -- In this case the 500 status prevents us from retrying\n    -- the webhook call again, but you could be more sophisticated\n    -- and analyze the disposition to determine if retrying it\n    -- would be useful and generate a 400 status instead.\n    -- In that case, the message will be retried later, until\n    -- it reached its expiration.\n    kumo.reject(500, disposition)\n  end\n  return connection\nend)\n\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'webhook' then\n    -- Use the `make.webhook` event to handle delivery\n    -- of webhook log records\n    return kumo.make_queue_config {\n      protocol = {\n        custom_lua = {\n          constructor = 'make.webhook',\n        },\n      },\n    }\n  end\n  return kumo.make_queue_config {}\nend)\n</code></pre> <p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>It is now possible to use <code>kumo.on</code> to register multiple handlers for this event.  The handlers will be called in the order that they were registered.  If a handler returns <code>nil</code> then the next handler will be called. Conversely, if a handler returns either <code>true</code> or <code>false</code>, its return value is taken as the definitive outcome and no further handlers will be called.</p> <p>This behavior is intended to make it easier to compose multiple helpers or lua modules together.</p>","tags":["logging"]},{"location":"reference/events/shutdown_logging/","title":"shutdown_logging","text":"<pre><code>kumo.on('shutdown_logging', function() end)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Called by <code>kumod</code> as part of shutdown, just prior to shutting down all loggers.</p> <p>The intended use case is for you to be able to <code>close</code> any mpsc queues that you might have defined in your policy, which in turn allows for a more graceful shutdown:</p> <pre><code>local kumo = require 'kumo'\n\nkumo.on('init', function()\n  kumo.spawn_task {\n    event_name = 'logger',\n    args = {},\n  }\nend)\n\nkumo.on('logger', function(args)\n  local q = kumo.mpsc.define 'queue'\n  while true do\n    local batch = q:recv_many(100)\n    if not batch then\n      print 'logger loop done; shutting down'\n      return\n    end\n  end\nend)\n\nkumo.on('shutdown_logging', function()\n  local q = kumo.mpsc.define 'queue'\n  q:close()\nend)\n</code></pre>"},{"location":"reference/events/smtp_client_rewrite_delivery_status/","title":"smtp_client_rewrite_delivery_status","text":"<pre><code>kumo.on(\n  'smtp_client_rewrite_delivery_status',\n  function(response, domain, tenant, campaign, routing_domain) end\n)\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This event is triggered by the SMTP client if a message is rejected by a destination SMTP server.</p> <p>Rejected means one of:</p> <ul> <li><code>MAIL FROM</code> or <code>RCPT TO</code> got a non-2xx response</li> <li><code>DATA</code> got a non-354 response</li> <li>The final <code>CRLF.CRLF</code> got a non-250 response</li> </ul> <p>In that circumstance, the SMTP response is formatted into a single line (replacing CRLF with the literal <code>\\r\\n</code> sequence) and the queue name parameters are extracted in order to call the <code>smtp_client_rewrite_delivery_status</code> event.</p> <p>The purpose of the event is to enable you to make a policy decision to optionally rewrite the status code.  For example, you may wish to treat a full mailbox as a permanent failure if the nature of the message is some kind of bulk notification that won't be missed.</p> <p>The event can return the its own version of the SMTP status code which will be used when considering what to do with the message.</p> <p>For instance, if the event returns a 500 code when the original code was a 400 code, the message will be logged as a <code>Bounce</code> and then removed from the spool.</p> <p>If the event returns <code>null</code>, or the same value as the original response, then the message is processed as normal.</p> <p>Otherwise, the response string will have <code>(kumomta: status was rewritten from 400 -&gt; 500)</code> appended to it, so that it is clear from the logs that a rewrite occurred.</p> <p>This example shows how to build up a mapping table from a json file with contents like this:</p> <pre><code>{\n  \"4\\\\.2\\\\.1 &lt;.+&gt;: Recipient address rejected: this mailbox is inactive and has been disabled\": 500,\n  \"4\\\\.2\\\\.2 The email account that you tried to reach is over quota\\\\.\": 500\n}\n</code></pre> <pre><code>-- Compile a classifier from the json file; refresh it it every 5 minutes\nlocal get_dsn_classifier = kumo.memoize(function()\n  local data = kumo.json_load '/tmp/dsn_rewrite.json'\n  return kumo.regex_set_map.new(data)\nend, {\n  name = 'dsn_rewrite',\n  ttl = '5 minutes',\n  capacity = 1,\n})\n\n-- This example ignores the queue name parameters, but you could get more\n-- sophisticated and use those to define rules on a per-domain/tenant/campaign basis\n-- if required\nkumo.on(\n  'smtp_client_rewrite_delivery_status',\n  function(response, domain, tenant, campaign, routing_domain)\n    local map = get_dsn_classifier()\n    -- Match the classifier against the response.\n    -- This will return the rewritten code if any, or null otherwise.\n    -- We can simply return the result of the lookup directly.\n    return map[response]\n  end\n)\n</code></pre> <p>See also:</p> <ul> <li>kumo.memoize</li> <li>kumo.regex_set_map.new</li> </ul>"},{"location":"reference/events/smtp_server_auth_plain/","title":"smtp_server_auth_plain","text":"<pre><code>kumo.on(\n  'smtp_server_auth_plain',\n  function(authz, authc, password, conn_meta) end\n)\n</code></pre> <p>Called by the ESMTP server in response to the client issuing an <code>\"AUTH PLAIN\"</code> authentication attempt.</p> <p>KumoMTA will only allow <code>AUTH PLAIN</code> once STARTTLS has been successfully enabled for the session.</p> <p>At the time of writing KumoMTA doesn't provide a general authentication solution, but through the use of this callback, you have some flexibility.</p> <p>The event handler receives the following parameters:</p> <ul> <li>authz - the authorization identity which the client wishes to act as</li> <li>authc - the authentication identity which identifies the client for the   purposes of validating who the client claims to be.  authc is paired   with the password parameter.</li> <li>password - the password which belongs to the claimed authc</li> <li>conn_meta - represents the connection metadata and     can be used to share state between the various SMTP listener     event handlers. See Connection Metadata     for more information.</li> </ul> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_metadata parameter is new as of this release.</p> <p>Note that PLAIN SASL allows for authz to be empty.  KumoMTA will assume the same value as authc in that case, so this event will always be triggered with that value.</p> <p>The SMTP server expects the event handler to return a bool value; if it returns true then it considers the credentials to be valid and will associated the claimed identities with the session, and yield an SMTP <code>235</code> successful authentication response to the client.  The authz and authc parameters will be set in the message meta object as <code>\"authz_id\"</code> and <code>\"authn_id\"</code> respectively.</p> <p>If it returns false then the authentication attempt is considered to have failed and will yield an SMTP <code>535</code> failed authentication response to the client.</p> <p>This example shows how to implement a very simple inline password database using a lua table:</p> <pre><code>-- Use this to lookup and confirm a user/password credential\nkumo.on('smtp_server_auth_plain', function(authz, authc, password, conn_meta)\n  -- This is just an example of how to populate the return value,\n  -- not a recommended way to handle passwords in production!\n  -- In particular, it is an absolutely terrible idea to hard code\n  -- a password here in plain text!\n  local password_database = {\n    ['daniel'] = 'tiger',\n  }\n  if password == '' then\n    return false\n  end\n  return password_database[authc] == password\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_auth_plain/#returning-group-and-identity-information","title":"Returning Group and identity Information","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Rather than just returning a boolean to indicate whether authentication was successful, you may now return an AuthInfo object holding additional information.  Here's an expanded version of the example above that shows how you can return group membership:</p> <pre><code>-- This is just an example of how to populate the return value,\n-- not a recommended way to handle passwords in production!\n-- In particular, it is an absolutely terrible idea to hard code\n-- a password here in plain text!\n\nlocal password_database = {\n  ['daniel'] = {\n    password = 'tiger',\n    groups = { 'group1', 'group2' },\n  },\n}\n\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\n  local entry = password_database[authc]\n  if not entry then\n    return false\n  end\n  if entry.password ~= password then\n    return false\n  end\n\n  -- Return an AuthInfo that lists out the identity and group\n  -- membership\n  return {\n    identities = {\n      { identity = authz, context = 'SmtpAuthPlainAuthorization' },\n      { identity = authc, context = 'SmtpAuthPlainAuthentication' },\n    },\n    groups = entry.groups,\n  }\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_connection_accepted/","title":"smtp_server_connection_accepted","text":"<pre><code>kumo.on('smtp_server_connection_accepted', function(conn_meta) end)\n</code></pre> Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Called by the ESMTP server when a new server session has accepted a connection from a client.</p> <p>This event is triggered before sending the initial banner response, giving you the opportunity to decide whether to reject the connection, or continue.</p> <p>If you do not reject the connection, then the server will continue with returning the banner to the client as normal.</p> <p>The Connection Metadata object is passed as the only parameter, which can be used to determine information about the peer, and can be modified to track additional context throughout the lifetime of this particular connection.</p> <pre><code>kumo.on('smtp_server_connection_accepted', function(conn_meta)\n  local peer = conn_meta:get_meta 'received_from'\n  -- is_peer_deny_listed is some hypothetical function you\n  -- define that will check to see if you want to allow this\n  -- connection to continue\n  if is_peer_deny_listed(peer) then\n    kumo.reject(421, string.format('service not accepted from %s', peer))\n  end\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_data/","title":"smtp_server_data","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>kumo.on('smtp_server_data', function(message, conn_meta) end)\n</code></pre> <p>Called by the ESMTP server after receiving the message data, but before responding to the client in the live SMTP session.</p> <p>The message content will be exactly the data passed to the server via the <code>DATA</code> command; no trace or other headers will have been added at this stage.</p> <p>The event handler will be passed a Message object.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>If the client issued multiple <code>\"RCPT TO\"</code> commands in the same transaction, each one will result in a recipient being added to the recipient list in the message, which you can review and/or modify via Message::recipient_list and Message::set_recipient.</p> <p>This event is the best place to carry out policy that:</p> <ul> <li>Validates/mutates message content/headers, regardless of the recipient list</li> <li>Validates/modifies the recipient list for eg: alias expansion, legal capture</li> </ul> <p>It is NOT recommended to perform recipient-oriented actions at this stage; instead you should put those in smtp_server_message_received which will be called once <code>smtp_server_data</code> completes.</p>"},{"location":"reference/events/smtp_server_ehlo/","title":"smtp_server_ehlo","text":"<pre><code>kumo.on('smtp_server_ehlo', function(domain, conn_meta) end)\n</code></pre> <p>Called by the ESMTP server in response to the client issuing either a <code>\"HELO\"</code> or <code>\"EHLO\"</code> command.  The event handler is passed the domain parameter from the <code>HELO/EHLO</code> command.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>You may choose to reject the connection via kumo.reject.</p> <pre><code>-- Called to validate the helo and/or ehlo domain\nkumo.on('smtp_server_ehlo', function(domain, conn_meta)\n  -- Use kumo.reject to return an error to the EHLO command\n  if domain == 'bad.actor' then\n    kumo.reject(420, 'go away')\n  end\nend)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>The signature of the call has been extended to receive the list of SMTP extensions that will be reported by the EHLO command. You can optionally return a list of extensions to replace that list.</p> <p>This example shows how to advertise support for a hypothetical \"X-SOMETHING\" extension:</p> <pre><code>kumo.on('smtp_server_ehlo', function(domain, conn_meta, extensions)\n  table.insert(extensions, 'X-SOMETHING')\n  return extensions\nend)\n</code></pre> <p>If you return <code>nil</code> or otherwise omit to return anything, the standard set of extensions will be returned.</p> <p>You can filter out or add whatever strings you wish from the <code>extensions</code> parameter, but it is worth noting that what you add/remove from this list has no impact on what kumomta actually supports, and does not otherwise change its behavior.</p>"},{"location":"reference/events/smtp_server_get_dynamic_parameters/","title":"smtp_server_get_dynamic_parameters","text":"<pre><code>kumo.on(\n  'smtp_server_get_dynamic_parameters',\n  function(listener, conn_meta) end\n)\n</code></pre> Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Note</p> <p>This option is primarily intended to be used together with a wildcard <code>listen</code> value of <code>0.0.0.0</code> for an IPv4 listener or <code>::</code> for an IPv6 listener where you desire to dynamically configure IP based virtual MTA service.</p> <p>Called by the ESMTP server when a new server session has accepted a connection from a client, and offers a chance to update the configuration for the listener dynamically.  This event triggers before smtp_server_connection_accepted.</p> <p>The parameters are:</p> <ul> <li><code>listener</code> - the stringified version of the listener address, such as <code>0.0.0.0:25</code></li> <li><code>conn_meta</code> - the Connection Metadata object</li> </ul> <p>The return value must be a table holding ESMTP listener parameter overrides that you wish to apply to the existing listener parameters for this connection. The fields that you specify in the return value will override the fields that were already configured.  Almost every field described under kumo.start_esmtp_listener can be used; those that cannot will indicate it in their individual documentation pages.</p> <p>The following example is equivalent to the via example, except that rather than the <code>via</code> parameters being statically configured during the <code>init</code> event, they are computed for every new connection:</p> <pre><code>kumo.on('init', function()\n  kumo.start_esmtp_listener {\n    listen = '0.0.0.0:25',\n  }\nend)\n\nkumo.on('smtp_server_get_dynamic_parameters', function(listener, conn_meta)\n  return {\n    via = {\n      -- When clients connect to this server via its 10.0.0.1 IP\n      -- address, we will use the hostname and TLS parameters\n      -- defined in this block\n      ['10.0.0.1'] = {\n        hostname = 'mx.example-customer.com',\n        tls_certificate = '/path/to/customer1.cert',\n        tls_private_key = '/path/to/customer1.key',\n      },\n      -- When clients connect to this server via its 10.0.0.2 IP\n      -- address, we will use the hostname and TLS parameters\n      -- defined in this block\n      ['10.0.0.2'] = {\n        hostname = 'mx.other-customer.com',\n        tls_certificate = '/path/to/customer2.cert',\n        tls_private_key = '/path/to/customer2.key',\n      },\n    },\n  }\nend)\n</code></pre> <p>This late binding of the configuration can be used to aid in dynamically updating the set of listeners on a wildcard port.</p> <p>For example, you could put the listener overrides into a TOML or JSON file that has the same shape as the listener parameters:</p> <pre><code>[via.'10.0.0.1']\nhostname = 'mx.example-customer.com'\ntls_certificate = '/path/to/customer1.cert'\ntls_private_key = '/path/to/customer1.key'\n\n[via.'10.0.0.2']\nhostname = 'mx.other-customer.com'\ntls_certificate = '/path/to/customer2.cert'\ntls_private_key = '/path/to/customer2.key'\n</code></pre> <p>Then change the policy code to load it:</p> <pre><code>kumo.on('init', function()\n  kumo.start_esmtp_listener {\n    listen = '0.0.0.0:25',\n  }\nend)\n\nkumo.on('smtp_server_get_dynamic_parameters', function(listener, conn_meta)\n  return kumo.serde.toml_load '/opt/kumometa/etc/policy/listener_params.toml'\nend)\n</code></pre> <p>Depending upon the size of the data you are loading, and especially if you choose to load data from an external service, you should consider using kumo.memoize to cache the data.</p>"},{"location":"reference/events/smtp_server_mail_from/","title":"smtp_server_mail_from","text":"<pre><code>kumo.on('smtp_server_mail_from', function(sender, conn_meta) end)\n</code></pre> <p>Called by the ESMTP server in response to the client issuing a <code>\"MAIL FROM\"</code> command.  The event handler is passed the sender address parameter from the <code>MAIL FROM</code> command.</p> <p>The sender address is an EnvelopeAddress object.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>You may choose to reject the connection via kumo.reject.</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  if sender.domain == 'bad.domain' then\n    kumo.reject(420, 'not thanks')\n  end\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_message_deferred_inject/","title":"smtp_server_message_deferred_inject","text":"<pre><code>kumo.on(\n  'smtp_server_message_deferred_inject',\n  function(message, conn_meta) end\n)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>When deferred_queue is enabled, this is called by after accepting the message data and responding to the client.</p> <p>If the client issued multiple <code>\"RCPT TO\"</code> commands in the same transaction, each one will result in a separate message being created, and this event will be triggered for each of them.</p> <p>The event handler will be passed a Message object. The Message will always have a <code>Received</code> header prepended that captures trace information about the sender.</p> <p>The conn_meta parameter represents the connection metadata, but it is synthesized from the metadata in the message.  It is provided as a type-compatible way to reference the metadata for functions like SPF and DMARC that accept connection metadata. While it is possible to update/set values in this metadata object, they will not persist once the <code>smtp_server_message_deferred_inject</code> event handler returns.  See Connection Metadata for more information.</p> <p>You can and should use this event to process things that you would normally have done in the <code>smtp_server_message_received</code> event handler, such as:</p> <ul> <li>DKIM signing via message:dkim_sign.</li> <li>Assigning the <code>\"campaign\"</code>, <code>\"tenant\"</code> and/or <code>\"queue\"</code> meta values via msg:set_meta</li> </ul> <pre><code>kumo.on('smtp_server_message_deferred_inject', function(msg)\n  local signer = kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.pem',\n  }\n  msg:dkim_sign(signer)\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_message_received/","title":"smtp_server_message_received","text":"<pre><code>kumo.on('smtp_server_message_received', function(message, conn_meta) end)\n</code></pre> <p>Called by the ESMTP server after receiving the message data, but before responding to the client in the live SMTP session.</p> <p>If the client issued multiple <code>\"RCPT TO\"</code> commands in the same transaction, each one will result in a separate message being created, and this event will be triggered for each of them.</p> <p>The event handler will be passed a Message object. Depending on the start_esmtp_listener.trace_headers configuration, the Message will have a <code>Received</code> header prepended that captures trace information about the sender.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>This event is the best place to carry out a number of important policy decisions:</p> <ul> <li>DKIM signing via message:dkim_sign.</li> <li>Assigning the <code>\"campaign\"</code>, <code>\"tenant\"</code> and/or <code>\"queue\"</code> meta values via msg:set_meta</li> </ul> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\n  local signer = kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.pem',\n  }\n  msg:dkim_sign(signer)\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_rcpt_to/","title":"smtp_server_rcpt_to","text":"<pre><code>kumo.on('smtp_server_rcpt_to', function(recipient, conn_meta) end)\n</code></pre> <p>Called by the ESMTP server in response to the client issuing a <code>\"RCPT TO\"</code> command.  The event handler is passed the recipient address parameter from the <code>RCPT TO</code> command.</p> <p>The recipient address is an EnvelopeAddress object.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>You may choose to reject the connection via kumo.reject.</p> <pre><code>kumo.on('smtp_server_rcpt_to', function(recipient)\n  if recipient.domain == 'bad.domain' then\n    kumo.reject(420, 'not thanks')\n  end\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_rewrite_response/","title":"smtp_server_rewrite_response","text":"<pre><code>kumo.on(\n  'smtp_server_rewrite_response',\n  function(status, response, command, conn_meta) end\n)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This event is triggered by the SMTP server just prior to sending a response to the connected client.  It enables you to adjust the response that is sent back to the client.</p> <p>The parameters are:</p> <ul> <li><code>status</code> - the SMTP status code (eg: 250, 400, etc.)</li> <li><code>response</code> - the response message text that will be sent to the client. (eg: <code>\"OK\"</code>, <code>\"4.4.5 data_processing_timeout exceeded\"</code>)</li> <li><code>command</code> - the SMTP command that is being responded to. This may be <code>nil</code>   for unknown commands, or for unilateral responses.</li> <li><code>conn_meta</code> - the Connection Metadata object for the connection</li> </ul> <p>The return value is expected to be a two-tuple consisting of:</p> <ul> <li>The revised <code>status</code> value, or <code>nil</code> to retain the current status.</li> <li>The revised <code>response</code> value, or <code>nil</code> to retain the current response.</li> </ul> <p>Not explicitly returning anything is equivalent to returning <code>nil, nil</code> and preserving the current status and response.</p> <p>The <code>response</code> string may be multi-line, separated by <code>\\n</code>.  Multiline responses in this context do not include the SMTP status code as a prefix; KumoMTA will insert any SMTP continuation as appropriate so that you can focus on just the textual content in the response string.</p> <p>Any errors raised within the <code>smtp_server_rewrite_response</code> will be logged, but will otherwise be treated as though <code>nil, nil</code> was returned and leave the status unchanged.  In particular, this means that you cannot use <code>kumo.reject</code> to break the connection at this stage.</p> <p>Danger</p> <p>While you can change the status code that is returned to the client through this event, you should avoid changing the semantics of the transaction. For example, if you edit the DATA response from 250 to a failure code, that will not change the fact that the system has spooled and queued the message for delivery, and that particular status change will likely cause the client to retry delivery later, leading to duplicate delivery.</p> <p>Changing the <code>status</code> to <code>421</code> will cause the connection to be closed on the client.</p>"},{"location":"reference/events/smtp_server_rewrite_response/#example-amending-the-data-response","title":"Example: amending the DATA response","text":"<p>This example prefixes <code>\"super fantastic!\"</code> to the successful SMTP DATA response case, but leaves every other status as-is.</p> <pre><code>kumo.on(\n  'smtp_server_rewrite_response',\n  function(status, response, command, conn_meta)\n    if command == 'DATA' and status == 250 then\n      return 250, 'super fantastic!\\n' .. response\n    end\n\n    -- leave the status and response unchanged\n  end\n)\n</code></pre> <p>Results in something like this being sent back to the client in the SMTP session:</p> <pre><code>250-super fantastic!\n250 OK ids=edd8d788b4a111f098b2cc28aa0a5c5a\n</code></pre>"},{"location":"reference/events/smtp_server_split_transaction/","title":"smtp_server_split_transaction","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>kumo.on('smtp_server_split_transaction', function(message, conn_meta) end)\n</code></pre> <p>Called by the ESMTP server to decide whether and how to split the recipient list into groups of recipients at the same destination site.</p> <p>SMTP messages can have an envelope that includes multiple recipients.  Each recipient will receive a copy of the message.  If multiple recipients share the same mailbox provider then it is advantageous from a bandwidth and efficiency perspective to relay that message to that provider as a single message with a list of multiple recipients, rather than sending one distinct copy per recipient.</p> <p>This event gives you control over how the incoming transaction is split and the recipients are grouped together.</p> <p>You do not need to implement this event handler in the vast majority of cases! Look at start_esmtp_listener.batch_handling for a much simpler way to express the most common choices.</p> <p>You can use message:recipient_list to retrieve the recipient list from the message.  That might give you something like:</p> <pre><code>{ 'fred@gmail.com', 'pete@gmail.com', 'joe@hotmail.com' }\n</code></pre> <p>(but each element is an EnvelopeAddress rather than a string).</p> <p>The return value must be an array of arrays of addresses.  For example, if you wish to recreate the <code>batch_handling = \"BifurcateAlways\"</code> mode of operation, the shape of the result will look like this:</p> <pre><code>{\n    { 'fred@gmail.com' },\n    { 'pete@gmail.com' },\n    { 'joe@hotmail.com' }\n}\n</code></pre> <p>If you wish to recreate the <code>batch_handling = \"BatchByDomain\"</code> mode of operation, it will instead look like this, with all of the gmail addresses in the same top level array:</p> <pre><code>{\n    { 'fred@gmail.com', 'pete@gmail.com' },\n    { 'joe@hotmail.com' }\n}\n</code></pre> <p>Returning <code>nil</code> (or not explicitly returning anything) from <code>smtp_server_split_transaction</code> will cause the <code>batch_handling</code> option to be consulted to decide how splitting/batching will occur.</p> <p>When a multi-recipient message is routed onwards, the domain of the first recipient is used to resolve the MX and decide which host to connect to.  In the example above, <code>fred@gmail.com</code> will be used to resolve routing for the first batch, while <code>joe@hotmail.com</code> will be used to resolve routing for the second batch.</p> <p>Warning</p> <p>While you can create arbitrary batches with this event handler, if you create non-sensical batches you should expect for messages to fail to deliver.  For example, if you group <code>user@gmail.com</code> together with <code>other.user@hotmail.com</code> then when the message is attempted, gmail (from the first recipient) will likely reject the hotmail address because gmail is not responsible for and may choose not to relay the hotmail recipient.</p> <p>Note</p> <p>This event is called even if the recipient list has a single entry</p> <p>It is technically possible to synthesize additional recipients by including them in the returned list of batches, but it is recommended that you perform recipient list modification in the smtp_server_data event rather than this event.</p>"},{"location":"reference/events/smtp_server_split_transaction/#example-equivalent-to-batch_handlingbifurcatealways","title":"Example: equivalent to batch_handling=BifurcateAlways","text":"<p>Every incoming recipient is placed into a separate batch and tracked separately.</p> <pre><code>kumo.on('smtp_server_split_transaction', function(message, conn_meta)\n  local split = {}\n  for _, recip in ipairs(message:recipient_list()) do\n    table.insert(split, { recip })\n  end\n  return split\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_split_transaction/#example-equivalent-to-batch_handlingbatchbydomain","title":"Example: equivalent to batch_handling=BatchByDomain","text":"<p>Recipients with exactly the same domain portion are grouped together.</p> <pre><code>kumo.on('smtp_server_split_transaction', function(message, conn_meta)\n  local by_domain = {}\n  for _, recip in ipairs(message:recipient_list()) do\n    local domain = recip.domain:lower()\n    if not by_domain[domain] then\n      by_domain[domain] = {}\n    end\n    table.insert(by_domain[domain], recip)\n  end\n  return by_domain\nend)\n</code></pre>"},{"location":"reference/events/spool_message_enumerated/","title":"spool_message_enumerated","text":"<pre><code>kumo.on('spool_message_enumerated', function(message) end)\n</code></pre> <p>Called by the spool layer during spool enumeration during server startup.</p> <p>When kumod starts, after the <code>init</code> event has triggered, the spool subsystem begins enumeration of messages to build up the queues.</p> <p>For each message discovered in the spool, the <code>spool_message_enumerated</code> event will fire prior to inserting the message into a queue.</p> <p>This event gives the operator the ability to handle situations such as the removal of a queues/paths/sources by allowing you to re-assign the queue meta value to place the message into a different queue from that the one that was selected during the original reception of the message.</p> <p>Errors raised during the evaluation of this hook will prevent the server from completing startup.</p>"},{"location":"reference/events/throttle_insert_ready_queue/","title":"throttle_insert_ready_queue","text":"<pre><code>kumo.on('throttle_insert_ready_queue', function(message) end)\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>This event was actually added in <code>2024.06.10-84e84b89</code> but with a broken event registration that prevented it from working. That was corrected in the version shown above.</p> <p>This event is triggered when a message is ready to move from its containing scheduled queue and into a ready queue.</p> <p>Its purpose is to allow you to evaluate any throttles defined by your policy; see kumo.make_throttle() for more information on throttles.</p> <p>Multiple instances of the <code>throttle_insert_ready_queue</code> event can be registered, and they will be called in the order in which they were registered, until all registered events are called, or until one explicitly returns <code>nil</code> to signal that no more should be triggered.</p> <p>The example below will limit each tenant to send no more than <code>1000</code> messages per hour:</p> <pre><code>kumo.on('throttle_insert_ready_queue', function(msg)\n  -- limit each tenant to 1000/hr\n  local tenant = msg:get_meta 'tenant'\n  local throttle = kumo.make_throttle(\n    string.format('tenant-send-limit-%s', tenant),\n    '1000/hr'\n  )\n  throttle:delay_message_if_throttled(msg)\nend)\n</code></pre> <p>This example allows each tenant to have an individual limit; you could load the limits from a data file or database if you prefer.</p> <pre><code>local function per_tenant_throttle(tenant_name)\n  -- default to 1000/hr unless otherwise overridden\n  local rate = '1000/hr'\n  if tenant_name == 'tenant_1' then\n    -- Allow increased rate for this tenant\n    rate = '10000/hr'\n  end\n  return kumo.make_throttle(\n    string.format('tenant-send-limit-%s', tenant_name),\n    rate\n  )\nend\n\nkumo.on('throttle_insert_ready_queue', function(msg)\n  local tenant = msg:get_meta 'tenant'\n  local throttle = per_tenant_throttle(tenant)\n  throttle:delay_message_if_throttled(msg)\nend)\n</code></pre>"},{"location":"reference/events/tsa_init/","title":"tsa_init","text":"<pre><code>kumo.on('tsa_init', function() end)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The <code>tsa_init</code> event is triggered once when the <code>tsa-daemon</code> process initializes. The intent is that you use this event to define the database storage location and listeners for your environment.</p> <p>The event handler is not passed any parameters, and does not expect any particular return value.</p> <pre><code>local tsa = require 'tsa'\nlocal kumo = require 'kumo'\n\n-- Called on startup to initialize the system\nkumo.on('tsa_init', function()\n  -- This is the default, so you needn't specify this.\n  -- But if you wanted to change the path, you must do it\n  -- before you start the listener\n  tsa.configure_tsa_db_path '/var/spool/kumomta/tsa.db'\n\n  tsa.start_http_listener {\n    listen = '0.0.0.0:8008',\n    -- allowed to access any http endpoint without additional auth\n    -- You will likely want to include your LAN CIDR here if\n    -- you are running multiple nodes\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\nend)\n</code></pre>"},{"location":"reference/events/tsa_load_shaping_data/","title":"tsa_load_shaping_data","text":"<pre><code>kumo.on('tsa_load_shaping_data', function() end)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Called by the <code>tsa-daemon</code> whenever it is going to evaluate a newly received log record.</p> <p>The event must return a <code>Shaping</code> object, as can be obtained via kumo.shaping.load.</p> <p>It is recommended that you use the same list of filenames that you would use with the shaping helper so that the two services have a consensus on the shaping configuration.</p> <p><code>tsa-daemon</code> is only really concerned with automation rules defined by the shaping configuration.</p> <pre><code>local tsa = require 'tsa'\nlocal kumo = require 'kumo'\n\nkumo.on('tsa_init', function()\n  tsa.start_http_listener {\n    listen = '0.0.0.0:8008',\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\nend)\n\nlocal cached_load_shaping_data = kumo.memoize(kumo.shaping.load, {\n  name = 'tsa_load_shaping_data',\n  ttl = '5 minutes',\n  capacity = 4,\n})\n\nkumo.on('tsa_load_shaping_data', function()\n  local shaping = cached_load_shaping_data {\n    -- This is the default file used by the shaping helper\n    -- in KumoMTA, which references the community shaping rules\n    '/opt/kumomta/share/policy-extras/shaping.toml',\n\n    -- and maybe you have your own rules\n    '/opt/kumomta/policy/shaping.toml',\n  }\n  return shaping\nend)\n</code></pre>"},{"location":"reference/events/xfer_message_received/","title":"xfer_message_received","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>kumo.on('xfer_message_received', function(message, auth_info) end)\n</code></pre> <p>Called during reception of a message transfer (xfer) from another kumomta, just prior to inserting the message into the appropriate queue.</p> <p>This event provides the opportunity to assess and otherwise update the message metadata to make it suitable for processing on the current node.</p> <p>For example, you may choose to alter queue related metadata items to match the current state of the world on the receiving server.</p> <p>Any errors that are raised by the event handler will cause the message xfer to transiently fail; the sending side will retry it according to its retry schedule.</p> <p>The <code>auth_info</code> parameter is an AuthInfo object that can be used to implement more granular access policies. (Since: Dev Builds Only)</p>"},{"location":"reference/header/","title":"The Header Object","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p>"},{"location":"reference/header/address_list/","title":"address_list","text":"<pre><code>local address_list = header.address_list\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>address_list</code> field will attempt to interpret the contents of the header as an AddressList.</p> <p>If the header value is not compatible with this representation, a lua error will be raised.</p>"},{"location":"reference/header/authentication_results/","title":"authentication_results","text":"<pre><code>local authentication_results = header.authentication_results\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>authentication_results</code> field will attempt to interpret the contents of the header as an Authentication Result.</p> <p>If the header value is not compatible with this representation, a lua error will be raised.</p>"},{"location":"reference/header/mailbox_list/","title":"mailbox_list","text":"<pre><code>local mailbox_list = header.mailbox_list\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>mailbox_list</code> field will attempt to interpret the contents of the header as an MailboxList.</p> <p>If the header value is not compatible with this representation, a lua error will be raised.</p>"},{"location":"reference/header/message_id/","title":"message_id","text":"<pre><code>local message_id = header.message_id\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>message_id</code> field will attempt to interpret the contents of the header as a <code>Message-Id</code> header.</p> <p>If the header value is not compatible with this representation, a lua error will be raised.</p>"},{"location":"reference/header/message_id_list/","title":"message_id_list","text":"<pre><code>local message_id_list = header.message_id_list\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>message_id_list</code> field will attempt to interpret the contents of the header as list of <code>Message-Id</code> header values.</p> <p>If the header value is not compatible with this representation, a lua error will be raised.</p>"},{"location":"reference/header/mime_params/","title":"mime_params","text":"<pre><code>local params = header.mime_params\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>mime_params</code> field will attempt to interpret the contents of the header as a MimeParams.</p> <p>If the header value is not compatible with this representation, a lua error will be raised.</p>"},{"location":"reference/header/name/","title":"name","text":"<pre><code>local name = header.name\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Returns the name of the header, as a string.</p>"},{"location":"reference/header/raw_value/","title":"raw_value","text":"<pre><code>local raw_value = header.raw_value\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Returns the raw value of the header, as encoded in header text in the formatted email message, as a string.</p>"},{"location":"reference/header/unstructured/","title":"unstructured","text":"<pre><code>local unstructured = header.unstructured\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Reading the <code>unstructured</code> field will interpret the header value as an unstructured field and return the resulting string.</p>"},{"location":"reference/header/value/","title":"value","text":"<pre><code>local value = header.value\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Depending on the header name, returns one of the structured representations of the header value.</p> <p>If there is no defined header name and structured representation, the fallback behavior is to return the same value that you'd see if you accessed header.unstructured.</p> <p>Note</p> <p>For the sake of forwards compatibility, it is possible that we will add support for names and structured representations in future versions.  In that scenario, if you were using <code>header.value</code> and relying on it returning the same value as <code>header.unstructured</code> then your logic may be broken by upgrading.</p> <p>With that in mind, we recommend that you explicitly use <code>header.unstructured</code> in your code for headers that are not included in the table below, rather than relying on the fallback behavior.</p>"},{"location":"reference/header/value/#supported-header-names-and-types","title":"Supported Header Names and Types","text":"<p>If the <code>Since</code> column is blank, it is assumed to be since the inception of <code>header.value</code>, which is the version shown at the top of this page.</p> Name Equivalent field accessor Since Authentication-Results authentication_results Bcc address_list Cc address_list Comments unstructured Content-Disposition mime_params Content-Id message_id Content-Transfer-Encoding mime_params Content-Type mime_params From mailbox_list Message-ID message_id Mime-Version unstructured References message_id_list Reply-To address_list Resent-Bcc address_list Resent-Cc address_list Resent-From mailbox_list Resent-Sender mailbox Resent-To address_list Sender mailbox Subject unstructured To address_list"},{"location":"reference/headermap/","title":"The HeaderMap Object","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Represents the parsed state of the set of headers in a MimePart.</p> <p>The headermap provides access to the headers and allows modification of the set of headers.</p> <p>Note</p> <p>While the map allows modification of the set of headers, the individual header objects that it returns are copies of the parsed headers; if you wish to modify the headers, you must explicitly use the methods of the header map to apply those changes to the headermap.</p> <p>Info</p> <p>Printing or otherwise explicitly converting a <code>HeaderMap</code> object as a string will produce the RFC 5322 representation of the headers contained in that map.</p>"},{"location":"reference/headermap/#associated-data-types","title":"Associated Data Types","text":"<p>The following data types/representations are associated with both the <code>HeaderMap</code> and <code>Header</code> objects that can be obtained through it.  <code>HeaderMap</code> provides accessors for fields by name/type/function which return the following data types from the getter functions (eg: headermap:to) and accept them as parameters in the setter functions (eg: headermap:set_to).</p>"},{"location":"reference/headermap/#address","title":"Address","text":"<p>Represents an email address, which can be either a Mailbox or a Group, both shown below.</p> <pre><code>-- This is an example of a `Mailbox`, which is valid as an `Address`\nlocal address = {\n  name = 'John Smith',\n  address = {\n    local_part = 'john.smith',\n    domain = 'example.com',\n  },\n}\n</code></pre>"},{"location":"reference/headermap/#addresslist","title":"AddressList","text":"<p>Represents a list of <code>Address</code>es (either <code>Mailbox</code> or <code>Group</code>); it is mapped to lua as an array style table listing out the addresses.  A list can have 0 or more entries.</p> <pre><code>local addresses = {\n  -- The first entry is a mailbox\n  {\n    name = 'John Smith',\n    address = {\n      local_part = 'john.smith',\n      domain = 'example.com',\n    },\n  },\n\n  -- The second entry is also a mailbox\n  {\n    name = 'Joe Bloggs',\n    address = {\n      local_part = 'joe.bloggs',\n      domain = 'example.com',\n    },\n  },\n\n  -- The third entry is a group\n  {\n    name = 'The A Team',\n    entries = {\n      {\n        name = 'Bodie',\n        address = {\n          local_part = 'bodie',\n          domain = 'example.com',\n        },\n      },\n      {\n        address = {\n          local_part = 'doyle',\n          domain = 'example.com',\n        },\n      },\n      {\n        address = {\n          local_part = 'tiger',\n          domain = 'example.com',\n        },\n      },\n      {\n        address = {\n          local_part = 'the.jewellery.man',\n          domain = 'example.com',\n        },\n      },\n    },\n  },\n}\n</code></pre>"},{"location":"reference/headermap/#group","title":"Group","text":"<p>Represents the group addressing syntax; groups are typically shown, by default, in the MUA collapsed down to just the <code>name</code> portion, making the overall distribution list less overwhelming in its default presentation.</p> <pre><code>-- This is an example of a `Group`, which is valid as an `Address`\nlocal group = {\n  name = 'The A Team', -- the display name for the group\n  entries = { -- `entries`, rather than `address` is what distinguishes this from a mailbox\n    {\n      name = 'Bodie',\n      address = {\n        local_part = 'bodie',\n        domain = 'example.com',\n      },\n    },\n    {\n      address = {\n        local_part = 'doyle',\n        domain = 'example.com',\n      },\n    },\n    {\n      address = {\n        local_part = 'tiger',\n        domain = 'example.com',\n      },\n    },\n    {\n      address = {\n        local_part = 'the.jewellery.man',\n        domain = 'example.com',\n      },\n    },\n  },\n}\n</code></pre>"},{"location":"reference/headermap/#mailbox","title":"Mailbox","text":"<p>Represents an individual mailbox (email address)</p> <pre><code>-- This is an example of a `Mailbox`\nlocal mailbox = {\n  name = 'John Smith', -- an optional string holding the display name\n  address = {\n    local_part = 'john.smith',\n    domain = 'example.com',\n  },\n}\n</code></pre>"},{"location":"reference/headermap/#mailboxlist","title":"MailboxList","text":"<p>Represents a list of <code>Mailbox</code>es; it is mapped to lua as an array style table listing out the mailboxes.  A list can have 0 or more entries.</p> <pre><code>local mailboxes = {\n  -- The first entry\n  {\n    name = 'John Smith',\n    address = {\n      local_part = 'john.smith',\n      domain = 'example.com',\n    },\n  },\n\n  -- The second entry\n  {\n    name = 'Joe Bloggs',\n    address = {\n      local_part = 'joe.bloggs',\n      domain = 'example.com',\n    },\n  },\n}\n</code></pre>"},{"location":"reference/headermap/#mimeparams","title":"MimeParams","text":"<p>Represents a structured RFC 2047 (MIME) header.  For example, a header like <code>Content-Type: text/plain; charset=utf-8</code> would be returned as:</p> <pre><code>local mime_params = {\n  value = 'text/plain',\n  parameters = {\n    charset = 'utf8',\n  },\n}\n</code></pre>"},{"location":"reference/headermap/append/","title":"append","text":"<pre><code>headers:append(NAME, VALUE)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Constructs a new header with <code>NAME</code> and <code>VALUE</code> and appends it to the header map.</p> <p>If the header value is ascii then it will be soft wrapped at whitespace around 75 columns, and hard-wrapped regardless of whitespace at 900 columns.</p> <p>If the header value is non-ascii then it will be quoted printable encoded using RFC 2047 header encoding.</p> <pre><code>headers:append('X-Something', 'Some value')\n</code></pre>"},{"location":"reference/headermap/bcc/","title":"bcc","text":"<pre><code>local bcc = headers:bcc()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Bcc</code> header from the headermap and returns the corresponding AddressList representation of the header.</p>"},{"location":"reference/headermap/cc/","title":"cc","text":"<pre><code>local cc = headers:cc()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Cc</code> header from the headermap and returns the corresponding AddressList representation of the header.</p>"},{"location":"reference/headermap/comments/","title":"comments","text":"<pre><code>local comments = headers:comments()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Comments</code> header and returns the unstructured representation of the header.</p>"},{"location":"reference/headermap/content_disposition/","title":"content_disposition","text":"<pre><code>local content_disposition = headers:content_disposition()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Content-Disposition</code> header and returns it in MimeParams representation.</p>"},{"location":"reference/headermap/content_id/","title":"content_id","text":"<pre><code>local content_id = headers:content_id()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Content-Id</code> header and returns it as a string.</p>"},{"location":"reference/headermap/content_transfer_encoding/","title":"content_transfer_encoding","text":"<pre><code>local content_transfer_encoding = headers:content_transfer_encoding()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Content-Transfer-Encoding</code> header and returns it in MimeParams representation.</p>"},{"location":"reference/headermap/content_type/","title":"content_type","text":"<pre><code>local content_type = headers:content_type()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Content-Type</code> header and returns it in MimeParams representation.</p>"},{"location":"reference/headermap/from/","title":"from","text":"<pre><code>local from = headers:from()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>From</code> header and returns it in mailboxlist representation.</p>"},{"location":"reference/headermap/get_first_named/","title":"get_first_named","text":"<pre><code>headers:get_first_named(NAME)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Gets the first header whose name equals <code>NAME</code> (case insensitive) and return the Header object for that header.</p> <p>Returns <code>nil</code> if no matching header could be found.</p>"},{"location":"reference/headermap/iter/","title":"iter","text":"<pre><code>headers:iter(OPTIONAL_NAME)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Produces an iterator over the headers.  If <code>OPTIONAL_NAME</code> is omitted, all headers are iterated in the order in which they appear in the message. If <code>OPTIONAL_NAME</code> is specified, then all headers that equal the name, case insensitively, will be iterated in the order in which they appear in the message.</p>"},{"location":"reference/headermap/iter/#iterating-all-headers","title":"Iterating all headers","text":"<pre><code>for hdr in headers:iter() do\n  print('got header', hdr.name)\nend\n</code></pre>"},{"location":"reference/headermap/iter/#iterating-just-the-authentication-results-headers","title":"Iterating just the authentication results headers","text":"<pre><code>for hdr in headers:iter 'Authentication-Results' do\n  print('got auth result', hdr.name, hdr.value)\nend\n</code></pre>"},{"location":"reference/headermap/message_id/","title":"message_id","text":"<pre><code>local message_id = headers:message_id()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Message-Id</code> header, and if present, returns the id string. Returns <code>nil</code> if <code>Message-Id</code> is not present.</p>"},{"location":"reference/headermap/mime_version/","title":"mime_version","text":"<pre><code>local mime_version = headers:mime_version()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Mime-Version</code> header, and if present, returns it as a string. Returns <code>nil</code> if <code>Mime-Version</code> is not present.</p>"},{"location":"reference/headermap/prepend/","title":"prepend","text":"<pre><code>headers:prepend(NAME, VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new header with <code>NAME</code> and <code>VALUE</code> and prepends it to the header map.</p> <p>If the header value is ascii then it will be soft wrapped at whitespace around 75 columns, and hard-wrapped regardless of whitespace at 900 columns.</p> <p>If the header value is non-ascii then it will be quoted printable encoded using RFC 2047 header encoding.</p> <pre><code>headers:prepend('X-Something', 'Some value')\n</code></pre>"},{"location":"reference/headermap/references/","title":"references","text":"<pre><code>local references = headers:references()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>References</code> header, if present, returning an array style table (list) of <code>Message-Id</code> strings to which this message refers.</p> <p>Returns <code>nil</code> if no <code>References</code> header is present.</p>"},{"location":"reference/headermap/remove_all_named/","title":"remove_all_named","text":"<pre><code>headers:remove_all_named(NAME)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Removes all headers which equal (case insensitively) <code>NAME</code> from the header map.</p>"},{"location":"reference/headermap/reply_to/","title":"reply_to","text":"<pre><code>local to = headers:reply_to()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Reply-To</code> header and returns it in AddressList representation.</p>"},{"location":"reference/headermap/resent_bcc/","title":"resent_bcc","text":"<pre><code>local resent_bcc = headers:resent_bcc()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Resent-Bcc</code> header and returns it in AddressList representation.</p>"},{"location":"reference/headermap/resent_cc/","title":"resent_cc","text":"<pre><code>local resent_cc = headers:to()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Resent-Cc</code> header and returns it in AddressList representation.</p>"},{"location":"reference/headermap/resent_from/","title":"resent_from","text":"<pre><code>local from = headers:resent_from()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Resent-From</code> header and returns it in MailboxList representation.</p>"},{"location":"reference/headermap/resent_sender/","title":"resent_sender","text":"<pre><code>local resent_sender = headers:resent_sender()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Resent-Sender</code> header and returns it in Mailbox representation.</p>"},{"location":"reference/headermap/sender/","title":"sender","text":"<pre><code>local sender = headers:sender()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Sender</code> header and returns it in Mailbox representation.</p>"},{"location":"reference/headermap/set_bcc/","title":"set_bcc","text":"<pre><code>headers:set_bcc(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign the <code>VALUE</code> to the <code>Bcc</code> header.</p> <p><code>VALUE</code> may be either a <code>string</code> or be an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_cc/","title":"set_cc","text":"<pre><code>headers:set_cc(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign the <code>VALUE</code> to the <code>Cc</code> header.</p> <p><code>VALUE</code> may be either a <code>string</code> or be an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_comments/","title":"set_comments","text":"<pre><code>headers:set_comments(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> (a string) to the <code>Comments</code> header.</p>"},{"location":"reference/headermap/set_content_disposition/","title":"set_content_disposition","text":"<pre><code>headers:set_content_disposition(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign the <code>VALUE</code> to the <code>Content-Disposition</code> header.</p> <p><code>VALUE</code> may be either a <code>string</code> or be an MimeParams.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with MimeParams before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_content_id/","title":"set_content_id","text":"<pre><code>headers:set_content_id(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign the <code>VALUE</code> (a string) to the <code>Content-Id</code> header.</p>"},{"location":"reference/headermap/set_content_transfer_encoding/","title":"set_content_transfer_encoding","text":"<pre><code>headers:set_content_transfer_encoding(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign the <code>VALUE</code> to the <code>Content-Transfer-Encoding</code> header.</p> <p><code>VALUE</code> may be either a <code>string</code> or be an MimeParams.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with MimeParams before allowing the assigment to proceed.</p> <p>Danger</p> <p>Changing the <code>Content-Transfer-Encoding</code> header may result in an inconsistent representation of the message and should be avoided.  We recommend limiting changes to just the parameter portion of the header rather than the overall encoding.</p>"},{"location":"reference/headermap/set_content_type/","title":"set_content_type","text":"<pre><code>headers:set_content_type(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign the <code>VALUE</code> to the <code>Content-Type</code> header.</p> <p><code>VALUE</code> may be either a <code>string</code> or be an MimeParams.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with MimeParams before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_from/","title":"set_from","text":"<pre><code>headers:set_from(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>From</code> header.</p> <p><code>VALUE</code> may be either a string or a MailboxList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with MailboxList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_message_id/","title":"set_message_id","text":"<pre><code>headers:set_message_id(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> (a string) to the <code>Message-Id</code> header.</p>"},{"location":"reference/headermap/set_mime_version/","title":"set_mime_version","text":"<pre><code>headers:set_mime_version(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Mime-Version</code> header.</p>"},{"location":"reference/headermap/set_references/","title":"set_references","text":"<pre><code>headers:set_references(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>References</code> header.</p> <p><code>VALUE</code> may be either a string or an array style table of Message-Id strings.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with the <code>References</code> header before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_reply_to/","title":"set_reply_to","text":"<pre><code>headers:set_reply_to(TO)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Reply-To</code> header.</p> <p><code>VALUE</code> may be either a string or an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_resent_bcc/","title":"set_resent_bcc","text":"<pre><code>headers:set_resent_bcc(TO)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Resent-Bcc</code> header.</p> <p><code>VALUE</code> may be either a string or an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_resent_cc/","title":"set_resent_cc","text":"<pre><code>headers:set_resent_cc(TO)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Resent-Cc</code> header.</p> <p><code>VALUE</code> may be either a string or an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_resent_from/","title":"set_resent_from","text":"<pre><code>headers:set_resent_from(FROM)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Resent-From</code> header.</p> <p><code>VALUE</code> may be either a string or an MailboxList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with MailboxList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_resent_sender/","title":"set_resent_sender","text":"<pre><code>headers:set_resent_sender(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Resent-Sender</code> header.</p> <p><code>VALUE</code> may be either a string or a Mailbox.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with Mailbox before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_resent_to/","title":"set_resent_to","text":"<pre><code>headers:set_resent_to(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Resent-To</code> header.</p> <p><code>VALUE</code> may be either a string or an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_sender/","title":"set_sender","text":"<pre><code>headers:set_sender(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>Sender</code> header.</p> <p><code>VALUE</code> may be either a string or a Mailbox.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with Mailbox before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/set_subject/","title":"set_subject","text":"<pre><code>headers:set_subject(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> (a string) to the <code>Subject</code> header.</p>"},{"location":"reference/headermap/set_to/","title":"set_to","text":"<pre><code>headers:set_to(VALUE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Assign <code>VALUE</code> to the <code>To</code> header.</p> <p><code>VALUE</code> may be either a string or an AddressList.</p> <p>If you assign using a string, the string will be parsed and validated as being compatible with AddressList before allowing the assigment to proceed.</p>"},{"location":"reference/headermap/subject/","title":"subject","text":"<pre><code>local subject = headers:subject()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>Subject</code> header and returns the unstructured representation of the header.</p>"},{"location":"reference/headermap/to/","title":"to","text":"<pre><code>local to = headers:to()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Parses the <code>To</code> header and returns it in AddressList representation.</p>"},{"location":"reference/http/kumod/","title":"kumod HTTP API","text":"<p>HTTP service is configured via kumo.start_http_listener.</p>"},{"location":"reference/http/kumod/#authentication","title":"Authentication","text":"<p>All HTTP endpoints require that the client satisfy one of the follow conditions:</p> <ul> <li>Trusted IP - Connecting from a host covered by the   trusted_hosts defined for the   HTTP listener</li> <li>Authenticated - Provide HTTP Basic authentication credentials that are   validated successfully by the   http_server_validate_auth_basic   event handler</li> </ul>"},{"location":"reference/http/kumod/api_admin_bounce_v1_delete/","title":"DELETE /api/admin/bounce/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to delete an administrative bounce entry by its id.</p> <p>This API endpoint is used by the kcli bounce-cancel command.</p>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_delete/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). </li> </ul>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_delete/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_delete/#responses","title":"Responses","text":"","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_delete/#status-200","title":"Status 200","text":"<p>Removed the requested bounce id</p>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_delete/#status-404","title":"Status 404","text":"<p>The requested bounce id is no longer, or never was, valid</p>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_get/","title":"GET /api/admin/bounce/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to list all currently active administrative bounces that have been configured.</p> <p>This API endpoint is used by the kcli bounce-list command.</p>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_get/#responses","title":"Responses","text":"","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_get/#status-200","title":"Status 200","text":"<p>Returned information about current admin bounces</p> <p><code>Content-Type: application/json</code></p> <p>This is an array of type BounceV1ListEntry. There are no constraints on the size of the array.</p>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_get/#examples","title":"Examples","text":"<pre><code>[\n  {\n    \"bounced\": {\n      \"gmail.com\": 200,\n      \"yahoo.com\": 100\n    },\n    \"campaign\": \"campaign_name\",\n    \"domain\": \"example.com\",\n    \"duration\": \"string\",\n    \"id\": \"552016f1-08e7-4e90-9da3-fd5c25acd069\",\n    \"reason\": \"cleaning up a bad send\",\n    \"routing_domain\": \"routing_domain.com\",\n    \"tenant\": \"tenant_name\",\n    \"total_bounced\": 42\n  }\n]\n</code></pre>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_post/","title":"POST /api/admin/bounce/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to administratively bounce messages that match certain criteria, or if no criteria are provided, ALL messages.</p> <p>This API endpoint is used by the kcli bounce command.</p> <p>Danger</p> <p>There is no way to undo the actions carried out by this request!</p>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>Describes which messages should be bounced. The criteria apply to the scheduled queue associated with a given message.</p> <p>Danger</p> <p>If you specify none of <code>domain</code>, <code>campaign</code>, <code>tenant</code>, <code>routing_domain</code> or <code>queue</code>, then ALL queues will be bounced.</p> <p>With great power comes great responsibility!</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>duration</code> - optional nullable <code>string</code>. Defaults to \"5m\". Specifies how long this bounce directive remains active.     While active, newly injected messages that match the bounce criteria     will also be bounced.</p> </li> <li> <p><code>expires</code> - optional nullable <code>string</code> (<code>date-time</code>). instead of specifying the duration, you can set an explicit     expiration timestamp</p> </li> <li> <p><code>queue_names</code> - optional array of <code>string</code>. If present, queue_names takes precedence over <code>campaign</code>,     <code>tenant</code>, and <code>domain</code> and specifies the exact set of     scheduled queue names to which the bounce applies.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will be bounced     with an AdminBounce record unless you suppress logging.     The reason will also be shown in the list of currently active admin     bounces.</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain name to match. If omitted, any routing_domain will match.     (Since: Version 2023.08.22-4d895015)</p> </li> <li> <p><code>suppress_logging</code> - optional <code>boolean</code>. If true, do not generate AdminBounce delivery logs for matching     messages.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant to match. If omitted, any tenant will match.</p> </li> </ul>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"20m\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"queue_names\": [\n    \"campaign_name:tenant_name@example.com\"\n  ],\n  \"reason\": \"Cleaning up a bad send\",\n  \"routing_domain\": \"routing_domain.com\",\n  \"suppress_logging\": false,\n  \"tenant\": \"tenant_name\"\n}\n</code></pre>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_post/#responses","title":"Responses","text":"","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_post/#status-200","title":"Status 200","text":"<p>Bounce added successfully</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>bounced</code> - required <code>object</code>. Deprecated: this field is no longer populated, as bounces     are now always asynchronous. In earlier versions the following     applies:</p> <p>A map of queue name to number of bounced messages that were processed as part of the initial sweep. Additional bounces may be generated if/when other messages that match the rule are discovered, but those obviously cannot be reported in the context of the initial request.</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the bounce rule that was registered.     This can be used later to delete the rule if desired.</p> </li> <li> <p><code>total_bounced</code> - required <code>integer</code>. Deprecated: this field is no longer populated, as bounces are     now always asynchronous. In earlier versions the following applies:</p> <p>The sum of the number of bounced messages reported by the <code>bounced</code> field.</p> </li> </ul>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bounce_v1_post/#examples_1","title":"Examples","text":"<pre><code>{\n  \"bounced\": {\n    \"gmail.com\": 200,\n    \"yahoo.com\": 100\n  },\n  \"id\": \"552016f1-08e7-4e90-9da3-fd5c25acd069\",\n  \"total_bounced\": 300\n}\n</code></pre>","tags":["bounce"]},{"location":"reference/http/kumod/api_admin_bump_config_epoch_post/","title":"POST /api/admin/bump-config-epoch","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to trigger a configuration epoch bump, which causes various configs that are using the Epoch strategy to be re-evaluated by triggering the appropriate callbacks.</p>","tags":["config"]},{"location":"reference/http/kumod/api_admin_bump_config_epoch_post/#responses","title":"Responses","text":"","tags":["config"]},{"location":"reference/http/kumod/api_admin_bump_config_epoch_post/#status-200","title":"Status 200","text":"<p>bump successful</p>","tags":["config"]},{"location":"reference/http/kumod/api_admin_inspect_message_v1_get/","title":"GET /api/admin/inspect-message/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Retrieve information about a message given its spool id.</p> <p>This API endpoint is used by the kcli inspect-message command.</p>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_message_v1_get/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>id</code> - required SpoolId. The spool identifier for the message whose information     is being requested</li> <li><code>want_body</code> - optional <code>boolean</code>. If true, return the message body in addition to the     metadata</li> </ul>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_message_v1_get/#responses","title":"Responses","text":"","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_message_v1_get/#status-200","title":"Status 200","text":"<p>Obtained message information</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>id</code> - required SpoolId. The spool identifier of the message</p> </li> <li> <p><code>message</code> - required MessageInformation. The message information</p> </li> </ul>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_message_v1_get/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n  \"message\": {\n    \"data\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n    \"due\": \"1990-12-31T23:59:60Z\",\n    \"meta\": {},\n    \"num_attempts\": 42,\n    \"recipient\": \"recipient@example.com\",\n    \"scheduling\": {},\n    \"sender\": \"sender@sender.example.com\"\n  }\n}\n</code></pre>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_sched_q_v1_get/","title":"GET /api/admin/inspect-sched-q/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Retrieve information about messages in a scheduled queue.</p> <p>This API endpoint is used by the kcli inspect-sched-q command.</p>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_sched_q_v1_get/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>queue_name</code> - required <code>string</code>. The name of the scheduled queue</li> <li><code>want_body</code> - optional <code>boolean</code>. If true, return the message body in addition to the     metadata</li> <li><code>limit</code> - optional nullable <code>integer</code>. Return up to <code>limit</code> messages in the queue sample.     Depending on the strategy configured for the queue,     messages may not be directly reachable via this endpoint.     If no limit is provided, all messages in the queue will     be sampled.</li> </ul>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_sched_q_v1_get/#responses","title":"Responses","text":"","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_sched_q_v1_get/#status-200","title":"Status 200","text":"<p>Obtained queue information</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>delayed_metric</code> - required <code>integer</code>. </p> </li> <li> <p><code>last_changed</code> - required <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>messages</code> - required array of InspectMessageV1Response. </p> </li> <li> <p><code>now</code> - required <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>num_scheduled</code> - required <code>integer</code>. </p> </li> <li> <p><code>queue_config</code> - required <code>object</code>. </p> </li> <li> <p><code>queue_name</code> - required <code>string</code>. </p> </li> </ul>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_inspect_sched_q_v1_get/#examples","title":"Examples","text":"<pre><code>{\n  \"delayed_metric\": 42,\n  \"last_changed\": \"1990-12-31T23:59:60Z\",\n  \"messages\": [\n    {\n      \"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n      \"message\": {\n        \"data\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n        \"due\": \"1990-12-31T23:59:60Z\",\n        \"meta\": {},\n        \"num_attempts\": 42,\n        \"recipient\": \"recipient@example.com\",\n        \"scheduling\": {},\n        \"sender\": \"sender@sender.example.com\"\n      }\n    }\n  ],\n  \"now\": \"1990-12-31T23:59:60Z\",\n  \"num_scheduled\": 42,\n  \"queue_config\": {},\n  \"queue_name\": \"campaign_name:tenant_name@example.com\"\n}\n</code></pre>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_memory_stats_get/","title":"GET /api/admin/memory/stats","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns information about the system memory usage in an unstructured human readable format.  The output is not machine parseable and may change without notice between versions of kumomta.</p>","tags":["memory"]},{"location":"reference/http/kumod/api_admin_memory_stats_get/#responses","title":"Responses","text":"","tags":["memory"]},{"location":"reference/http/kumod/api_admin_memory_stats_get/#status-200","title":"Status 200","text":"<p>stats were returned</p>","tags":["memory"]},{"location":"reference/http/kumod/api_admin_ready_q_states_v1_get/","title":"GET /api/admin/ready-q-states/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Retrieve information about the states that apply to a set of ready queues, or all queues if no specific queues were named in the request.</p> <p>This API endpoint is used by the kcli queue-summary command.</p>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_ready_q_states_v1_get/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>queues</code> - optional array of <code>string</code>. Which queues to request. If empty, request all queue states.</li> </ul>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_ready_q_states_v1_get/#responses","title":"Responses","text":"","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_ready_q_states_v1_get/#status-200","title":"Status 200","text":"<p>Obtained state information</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li><code>states_by_ready_queue</code> - required <code>object</code>. </li> </ul>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_ready_q_states_v1_get/#examples","title":"Examples","text":"<pre><code>{\n  \"states_by_ready_queue\": {}\n}\n</code></pre>","tags":["inspect"]},{"location":"reference/http/kumod/api_admin_rebind_v1_post/","title":"POST /api/admin/rebind/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to administratively rebind messages. Rebinding can target queues that match certain criteria, or if no criteria are provided, ALL queues. Rebinding is moving a message from one scheduled queue into another. Queue selection is based upon the envelope recipient and message metadata as described in Queues</p> <p>This API endpoint is used by the kcli rebind command.</p>","tags":["rebind"]},{"location":"reference/http/kumod/api_admin_rebind_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>Describes which messages should be rebound. The criteria apply to the scheduled queue associated with a given message.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>always_flush</code> - optional <code>boolean</code>. If true, make all matched messages immediately eligible for     delivery.  When false, (the default), only messages whose     queue has changed will be made immediately eligible.</p> </li> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>data</code> - required <code>object</code>. The data, a json object with string keys AND values to pass to the     rebind operation</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will log     with an AdminRebind record unless you suppress logging.</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain name to match. If omitted, any routing_domain will match.</p> </li> <li> <p><code>suppress_logging</code> - optional <code>boolean</code>. If true, do not generate AdminRebind delivery logs for matching     messages.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant to match. If omitted, any tenant will match.</p> </li> <li> <p><code>trigger_rebind_event</code> - optional <code>boolean</code>. If true, a <code>rebind</code> event will be triggered and passed each     message and the supplied data.     If false, no event will be triggered and each field in data     will be applied to the msg metadata, overwriting any previous     value for that key.</p> </li> </ul>","tags":["rebind"]},{"location":"reference/http/kumod/api_admin_rebind_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"always_flush\": false,\n  \"campaign\": \"string\",\n  \"data\": {},\n  \"domain\": \"example.com\",\n  \"reason\": \"Cleaning up a bad send\",\n  \"routing_domain\": \"string\",\n  \"suppress_logging\": false,\n  \"tenant\": \"string\",\n  \"trigger_rebind_event\": false\n}\n</code></pre>","tags":["rebind"]},{"location":"reference/http/kumod/api_admin_rebind_v1_post/#responses","title":"Responses","text":"","tags":["rebind"]},{"location":"reference/http/kumod/api_admin_rebind_v1_post/#status-200","title":"Status 200","text":"<p>Rebind added successfully</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with no properties.</p>","tags":["rebind"]},{"location":"reference/http/kumod/api_admin_rebind_v1_post/#examples_1","title":"Examples","text":"<pre><code>{}\n</code></pre>","tags":["rebind"]},{"location":"reference/http/kumod/api_admin_set_diagnostic_log_filter_v1_post/","title":"POST /api/admin/set_diagnostic_log_filter/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Changes the diagnostic log filter dynamically. See kumo.set_diagnostic_log_filter for more information on diagnostic log filters.</p> <p>This API endpoint is used by the kcli set-log-filter command.</p>","tags":["logging"]},{"location":"reference/http/kumod/api_admin_set_diagnostic_log_filter_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>filter</code> - required <code>string</code>. The diagnostic filter spec to use</li> </ul>","tags":["logging"]},{"location":"reference/http/kumod/api_admin_set_diagnostic_log_filter_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"filter\": \"kumod=trace\"\n}\n</code></pre>","tags":["logging"]},{"location":"reference/http/kumod/api_admin_set_diagnostic_log_filter_v1_post/#responses","title":"Responses","text":"","tags":["logging"]},{"location":"reference/http/kumod/api_admin_set_diagnostic_log_filter_v1_post/#status-200","title":"Status 200","text":"<p>Diagnostic level set successfully</p>","tags":["logging"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_delete/","title":"DELETE /api/admin/suspend-ready-q/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Remove a ready-queue suspension</p> <p>This API endpoint is used by the kcli suspend-ready-q-cancel command.</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_delete/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension to cancel</li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_delete/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_delete/#responses","title":"Responses","text":"","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_delete/#status-200","title":"Status 200","text":"<p>Removed the suspension</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_delete/#status-404","title":"Status 404","text":"<p>Suspension either expired or was never valid</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_get/","title":"GET /api/admin/suspend-ready-q/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>List the active ready-queue suspensions</p> <p>This API endpoint is used by the kcli suspend-ready-q-list command.</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_get/#responses","title":"Responses","text":"","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_get/#status-200","title":"Status 200","text":"<p>Suspended</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>duration</code> - required <code>string</code>. how long until this suspension expires and is automatically removed</p> </li> <li> <p><code>expires</code> - required <code>string</code> (<code>date-time</code>). The time at which the suspension will expire</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id for the suspension. Can be used to cancel the suspension.</p> </li> <li> <p><code>name</code> - required <code>string</code>. The name of the ready queue that is suspended</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_get/#examples","title":"Examples","text":"<pre><code>{\n  \"duration\": \"string\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\",\n  \"name\": \"source_name-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com@smtp_client\",\n  \"reason\": \"pause while working on resolving a block with the destination postmaster\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_post/","title":"POST /api/admin/suspend-ready-q/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Define a suspension for a ready queue</p> <p>This API endpoint is used by the kcli suspend-ready-q command.</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>duration</code> - optional nullable <code>string</code>. Specifies how long this suspension remains active.</p> </li> <li> <p><code>expires</code> - optional nullable <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>name</code> - required <code>string</code>. The name of the ready queue that should be suspended</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"duration\": \"string\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"name\": \"source_name-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com@smtp_client\",\n  \"reason\": \"pause while working on resolving a block with the destination postmaster\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_post/#responses","title":"Responses","text":"","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_post/#status-200","title":"Status 200","text":"<p>Suspended</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension. This can be used later to cancel     the suspension.</li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_ready_q_v1_post/#examples_1","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_delete/","title":"DELETE /api/admin/suspend/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Remove a scheduled-queue suspension</p> <p>This API endpoint is used by the kcli suspend-cancel command.</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_delete/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension to cancel</li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_delete/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_delete/#responses","title":"Responses","text":"","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_delete/#status-200","title":"Status 200","text":"<p>Removed the suspension</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_delete/#status-404","title":"Status 404","text":"<p>Suspension either expired or was never valid</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_get/","title":"GET /api/admin/suspend/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>List the active scheduled-queue suspensions</p> <p>This API endpoint is used by the kcli suspend-list command.</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_get/#responses","title":"Responses","text":"","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_get/#status-200","title":"Status 200","text":"<p>Suspended</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>duration</code> - required <code>string</code>. Specifies how long this suspension remains active.</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension. This can be used later to cancel     the suspension.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant name to match. If omitted, any tenant will match.</p> </li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_get/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"string\",\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\",\n  \"reason\": \"pause while working on resolving a deliverability issue\",\n  \"tenant\": \"tenant_name\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_post/","title":"POST /api/admin/suspend/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Define a suspension for a scheduled queue</p> <p>This API endpoint is used by the kcli suspend command.</p>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>duration</code> - optional nullable <code>string</code>. Specifies how long this suspension remains active.</p> </li> <li> <p><code>expires</code> - optional nullable <code>string</code> (<code>date-time</code>). instead of specifying the duration, you can set an explicit     expiration timestamp</p> </li> <li> <p><code>queue_names</code> - optional array of <code>string</code>. If present, queue_names takes precedence over <code>campaign</code>,     <code>tenant</code>, and <code>domain</code> and specifies the exact set of     scheduled queue names to which the suspension applies.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant name to match. If omitted, any tenant will match.</p> </li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"string\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"queue_names\": [\n    \"campaign_name:tenant_name@example.com\"\n  ],\n  \"reason\": \"pause while working on resolving a block with the destination postmaster\",\n  \"tenant\": \"tenant_name\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_post/#responses","title":"Responses","text":"","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_post/#status-200","title":"Status 200","text":"<p>Suspended</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension. This can be used later to cancel     the suspension.</li> </ul>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_suspend_v1_post/#examples_1","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>","tags":["suspend"]},{"location":"reference/http/kumod/api_admin_trace_smtp_client_v1_get/","title":"GET /api/admin/trace-smtp-client/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is a websocket endpoint that provides outbound SMTP tracing. It cannot be described via auto-generated docs extracted from the JSON Schema.</p> <p>This API endpoint is used by the kcli trace-smtp-client command.</p>","tags":["debugging"]},{"location":"reference/http/kumod/api_admin_trace_smtp_server_v1_get/","title":"GET /api/admin/trace-smtp-server/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is a websocket endpoint that provides inbound SMTP tracing. It cannot be described via auto-generated docs extracted from the JSON Schema.</p> <p>This API endpoint is used by the kcli trace-smtp-server command.</p>","tags":["debugging"]},{"location":"reference/http/kumod/api_admin_xfer_cancel_v1_post/","title":"POST /api/admin/xfer/cancel/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to stop a message transfer that was previously initiated via the <code>/api/admin/xfer/v1</code> API endpoint. The cancellation works by walking the xfer scheduled queue, reversing the metadata changes made as part of setting up the xfer (to restore the original scheduling information) and then re-inserting the message into an appropriate scheduled queue. The cancellation is \"instantaneous\" in the sense that it applies just once to the specified xfer scheduled queue.  Any other messages that are in-flight or imminently about to be reinserted into that scheduled queue will not be considered, so you may need to trigger the cancellation a few times over short time span to ensure that all messages are taken out of the xfer queue.</p> <p>Cancellation requests always complete asynchronously because they may operate on very large quantities of messages, and it is infeasible to wait for completion in the context of a single HTTP request.</p>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_cancel_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>queue_name</code> - required <code>string</code>. The name of the xfer scheduled queue</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will log     with an AdminRebind record to indicate that it was moved from     its containing queue, and this reason will be included in that record.</p> </li> </ul>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_cancel_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"queue_name\": \"string\",\n  \"reason\": \"Scaling down\"\n}\n</code></pre>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_cancel_v1_post/#responses","title":"Responses","text":"","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_cancel_v1_post/#status-200","title":"Status 200","text":"<p>Xfer added successfully</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with no properties.</p>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_cancel_v1_post/#examples_1","title":"Examples","text":"<pre><code>{}\n</code></pre>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_v1_post/","title":"POST /api/admin/xfer/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to transfer messages from the current node to some other target node. The transfer (xfer) can target queues that match certain criteria, or if no criteria are provided, ALL queues. Queue selection is based upon the envelope recipient and message metadata as described in Queues. Messages in the selected queues will be moved into an xfer queue whose name is based on the target specified by the transfer request.</p>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>Describes which messages should be transferred to another kumomta node. The criteria apply to the scheduled queue associated with a given message.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>target</code> - required <code>string</code> (<code>uri</code>). Expected to be an HTTP url prefix like:     <code>https://host.name:8008</code> <code>http://127.0.0.1:8000</code></p> </li> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>queue_names</code> - optional array of <code>string</code>. If present, queue_names takes precedence over <code>campaign</code>,     <code>tenant</code>, and <code>domain</code> and specifies the exact set of     scheduled queue names to which the xfer applies.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will log     with an AdminRebind record to indicate that it was moved from     its containing queue, and this reason will be included in that record.</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain name to match. If omitted, any routing_domain will match.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant to match. If omitted, any tenant will match.</p> </li> </ul>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"string\",\n  \"domain\": \"example.com\",\n  \"queue_names\": [\n    \"string\"\n  ],\n  \"reason\": \"Scaling down\",\n  \"routing_domain\": \"string\",\n  \"target\": \"http://127.0.0.1:8000\",\n  \"tenant\": \"string\"\n}\n</code></pre>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_v1_post/#responses","title":"Responses","text":"","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_v1_post/#status-200","title":"Status 200","text":"<p>Xfer added successfully</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with no properties.</p>","tags":["xfer"]},{"location":"reference/http/kumod/api_admin_xfer_v1_post/#examples_1","title":"Examples","text":"<pre><code>{}\n</code></pre>","tags":["xfer"]},{"location":"reference/http/kumod/api_check_liveness_v1_get/","title":"GET /api/check-liveness/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Useful for load balancers to determine when service is available and ready to receive messages</p>","tags":["liveness"]},{"location":"reference/http/kumod/api_check_liveness_v1_get/#responses","title":"Responses","text":"","tags":["liveness"]},{"location":"reference/http/kumod/api_check_liveness_v1_get/#status-200","title":"Status 200","text":"<p>ready to accept messages</p>","tags":["liveness"]},{"location":"reference/http/kumod/api_check_liveness_v1_get/#status-503","title":"Status 503","text":"<p>service is not currently available</p>","tags":["liveness"]},{"location":"reference/http/kumod/api_inject_v1_post/","title":"POST /api/inject/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Inject a message using a given message body, with template expansion, to a list of recipients. Both message assembly and templating are supported, and multiple recipients and template substitutions can be passed in a single request. The body of the post request must be a JSON object; here's a very basic example:</p> <pre><code>{\n    \"envelope_sender\": \"noreply@example.com\",\n    \"content\": \"Subject: hello\\n\\nHello there\",\n    \"recipients\": [\n        {\n            \"email\": \"recipient@example.com\",\n        }\n    ]\n}\n</code></pre> <p>The response will look something like:</p> <pre><code>{\n    \"success_count\": 1,\n    \"fail_count\": 0,\n    \"failed_recipients\": [],\n    \"errors\": []\n}\n</code></pre> <p>Note</p> <p>The <code>success_count</code> will always be reported as <code>0</code> when using <code>deferred_generation: true</code>.</p>","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#template-substitution","title":"Template Substitution","text":"<p>The injection API embeds the Mini Jinja templating engine, with some supplemental extensions.  The syntax and extensions are documented here.  You may use the <code>template_dialect</code> field to specify an alternative templating engine, or disable templating by setting the dialect to <code>\"Static\"</code>.</p> <p>For each recipient, the set of variables pre-defined in the template are:</p> <ul> <li> <p>The set of global substitutions defined by <code>request.substitutions</code></p> </li> <li> <p>The set of per-recipient substitutions, if any are defined in   <code>request.recipients[].substitutions</code>, are overlaid and take precedence over   any global substitutions</p> </li> <li> <p>The recipient <code>name</code> and <code>email</code> fields are assigned to the <code>\"name\"</code> and   <code>\"email\"</code> variables respectively.</p> </li> </ul> <p>Note</p> <p>Both sets of substitutions can use any JSON value for the values of the variables; they don't have to be strings.</p> <p>A very basic example of using templating:</p> <pre><code>{\n    \"envelope_sender\": \"noreply@example.com\",\n    \"content\": \"To: \\\"{{ name }}\\\" &lt;{{ email }}&gt;\\nSubject: hello\\n\\nHello {{ name }}!\",\n    \"recipients\": [\n        {\n            \"email\": \"recipient@example.com\",\n            \"name\": \"John Smith\"\n        }\n    ]\n}\n</code></pre> <p>would result in a message with the following content:</p> <pre><code>To: \"John Smith\" &lt;recipient@example.com&gt;\nSubject: hello\n\nHello John Smith!\n</code></pre>","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>content</code> - required Content. Specifies the message content. It can either be a string value or     a JSON object describing how to build a the message.</p> <p>If a simple string is provided, it must be an RFC822 compliant message.  If template substitutions are used in the request, then the entire RFC822 message string is used as-is for the template; no message parsing or decoding is performed as part of template expansion.</p> <p>Alternatively the content can be specified as a JSON object as demonstrated in the docs for the <code>Content</code> type.</p> <p>When building a message, template substitutions are applied to the <code>text_body</code>, <code>html_body</code>, <code>amp_html_body</code> and <code>headers</code> fields.</p> <p>Attachments are not subject to template substitution.</p> </li> <li> <p><code>deferred_generation</code> - optional <code>boolean</code>. (Since: Version 2024.11.08-d383b033)</p> <p>When set to true, the injection request will be queued and the actual generation and substitution will happen asynchronously with respect to the injection request. The default mode of operation is to respond to the injection request only once every message in the request has been enqueued to the internal queue system. This provides back pressure to the injection system and prevents the service from being overwhelmed if the rate of ingress exceeds the maximum rate of egress.</p> <p>The result of this back pressure is that the latency of the injection request depends on the load of the system.</p> <p>Setting <code>deferred_generation: true</code> in the request alters the processing flow: instead of immediately expanding the request into the desired number of messages and queueing them up, the injection request is itself queued up and processed asynchronously with respect to the incoming request.</p> <p>This <code>deferred_generation</code> submission is typically several orders of magnitude faster than the immediate generation mode, so it is possible to very very quickly queue up large batches of messages this way.</p> <p>The deferred generation requests are queued internally to a special queue named <code>generator.kumomta.internal</code> that will process them by spawning each request into the <code>httpinject</code> thread pool.</p> <p>You will likely want and need to configure shaping to accomodate this queue for best performance:</p> <pre><code>-- Locate this before any other helpers or modules that define\n-- `get_egress_path_config` event handlers in order for it to take effect\nkumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    if routing_domain == 'generator.kumomta.internal' then\n      return kumo.make_egress_path {\n        -- This is a good place to start, but you may want to\n        -- experiment with 1/2, 3/4, or 1.5 times this to find\n        -- what works best in your environment\n        connection_limit = kumo.available_parallelism(),\n        refresh_strategy = 'Epoch',\n        max_ready = 80000,\n      }\n    end\n  end\n)\n</code></pre> <p>Note</p> <p>It is possible to very quickly generate millions of queued messages when using <code>deferred_generation: true</code>. You may wish to look into configuring a rate limit to constrain the system appropriately for your environment. kumo.set_httpinject_recipient_rate_limit can be used for this purpose.</p> </li> <li> <p><code>deferred_spool</code> - optional <code>boolean</code>. (Since: Version 2024.11.08-d383b033)</p> <p>Danger</p> <p>Enabling deferred spooling may result in loss of accountability for messages.  You should satisfy yourself that your system is able to recognize and deal with that scenario if/when it arises.</p> <p>When set to <code>true</code>, the generated message(s) will not be written to the spool until it encounters its first transient failure.  This can improve injection rate but introduces the risk of loss of accountability for the message if the system were to crash before the message is delivered or written to spool, so use with caution!</p> <p>When used in conjunction with <code>deferred_generation</code>, both the queued generation request and the messages which it produces are subject to deferred spooling.</p> </li> <li> <p><code>envelope_sender</code> - required <code>string</code> (<code>email</code>). Specify the envelope sender that will be sent in the     MAIL FROM portion of SMTP.</p> </li> <li> <p><code>recipients</code> - required array of Recipient. Specifies the list of recipients to which message(s) will be sent.     When generating the message for the recipient, a suitable <code>To</code> header will be     constructed using the provided fields.</p> <p>If you also set a <code>To</code> header using the <code>headers</code> field, then the behavior depends on the version of kumomta:</p> Behavior Version The per-recipient <code>To</code> header will not be generated (Since: Dev Builds Only) Two <code>To</code> headers will be generated All previous versions </li> <li> <p><code>substitutions</code> - optional <code>object</code>. When using templating, this is the map of placeholder     name to replacement value that should be used by     the templating engine.  This map applies to all     recipients, with the per-recipient substitutions     taking precedence.</p> </li> <li> <p><code>template_dialect</code> - optional TemplateDialectWithSchema. (Since: Version 2025.12.02-67ee9e96)</p> <p>It is now possible to specify which template engine will be used for template expansion via the <code>template_dialect</code> field. It can have one of the following values:</p> <ul> <li><code>Jinja</code> - this is the implied default.  The Mini Jinja    template dialect will be parsed and evaluated.</li> <li><code>Static</code> - The content is treated as a static string and    no template expansion will be performed</li> <li><code>Handlebars</code> - The content will be evaluated by a handlebars    compatible template engine.</li> </ul> </li> <li> <p><code>trace_headers</code> - optional HttpTraceHeaders. (Since: Version 2024.11.08-d383b033)</p> <p>Controls the addition of tracing headers to received messages.</p> <p>KumoMTA can add two different headers to aid in later tracing:</p> <ul> <li> <p>The standard <code>\"Received\"</code> header which captures SMTP relay   hops on their path to the inbox</p> </li> <li> <p>A supplemental header which can be used to match feedback   reports back to the originating mailing</p> </li> </ul> <p>Prior to triggering the http_message_generated event the standard <code>\"Received\"</code> header will be added to the message.  Then, once the event completes and your policy has had the opportunity to alter the meta data associated with the message, the supplemental header will be added.</p> <pre><code>{\n  \"trace_headers\": {\n    // this is the default: do NOT add the Received: header\n    \"received_header\": false,\n\n    // this is the default: add the supplemental header\n    \"supplemental_header\": true,\n\n    // this is the default: the name of the supplemental header\n    \"header_name\": \"X-KumoRef\",\n\n    // names of additional meta data fields\n    // to include in the header. TAKE CARE! The header will be\n    // base64 encoded to prevent casual introspection, but the\n    // header is NOT encrypted and the values of the meta data\n    // fields included here should be considered to be public.\n    // The default is not to add any meta data fields, but you\n    // might consider setting something like:\n    // \"include_meta_names\": { \"tenant\", \"campaign\" },\n    \"include_meta_names\": {},\n  },\n}\n</code></pre> <p>Here's an example of a supplemental header from a message:</p> <pre><code>X-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\n</code></pre> <p>the decoded payload contains a magic marker key as well as the recipient of the original message:</p> <pre><code>{\"_@_\":\"\\\\_/\",\"recipient\":\"test@example.com\"}\n</code></pre> <p>Any meta data fields that were listed in <code>include_meta_names</code>, if the corresponding meta data was set in the message, would also be captured in the decoded payload.</p> <p>KumoMTA will automatically extract this supplemental trace header information from any <code>X-</code> header that is successfully parsed and has the magic marker key when processing the original message payload of an incoming ARF report.</p> </li> </ul>","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"content\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n  \"deferred_generation\": false,\n  \"deferred_spool\": false,\n  \"envelope_sender\": \"some.id@bounces.sender-example.com\",\n  \"recipients\": [\n    {\n      \"email\": \"john.smith@mailbox-example.com\",\n      \"name\": \"John Smith\",\n      \"substitutions\": {\n        \"age\": 42,\n        \"gender\": \"male\"\n      }\n    }\n  ],\n  \"substitutions\": {\n    \"campaign_title\": \"Fall Campaign\"\n  },\n  \"template_dialect\": \"Jinja\",\n  \"trace_headers\": {\n    \"header_name\": \"string\",\n    \"include_meta_names\": [\n      \"string\"\n    ],\n    \"received_header\": false,\n    \"supplemental_header\": false\n  }\n}\n</code></pre>","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#responses","title":"Responses","text":"","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#status-200","title":"Status 200","text":"<p>Message(s) injected successfully</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>errors</code> - required array of <code>string</code>. The list of error messages</p> </li> <li> <p><code>fail_count</code> - required <code>integer</code>. The number of messages that failed to inject</p> </li> <li> <p><code>failed_recipients</code> - required array of <code>string</code> (<code>email</code>). The list of failed recipients</p> </li> <li> <p><code>success_count</code> - required <code>integer</code>. The number of messages that were injected successfully</p> </li> </ul>","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#examples_1","title":"Examples","text":"<pre><code>{\n  \"errors\": [\n    \"string\"\n  ],\n  \"fail_count\": 42,\n  \"failed_recipients\": [\n    \"user@example.com\"\n  ],\n  \"success_count\": 42\n}\n</code></pre>","tags":["inject"]},{"location":"reference/http/kumod/api_inject_v1_post/#status-422","title":"Status 422","text":"<p>One or more fields in the content section have syntax errors</p>","tags":["inject"]},{"location":"reference/http/kumod/api_machine_info_get/","title":"GET /api/machine-info","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns information identifying this instance</p>","tags":["debugging"]},{"location":"reference/http/kumod/api_machine_info_get/#responses","title":"Responses","text":"","tags":["debugging"]},{"location":"reference/http/kumod/api_machine_info_get/#status-200","title":"Status 200","text":"<p>Machine information</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>container_runtime</code> - optional nullable <code>string</code>. If we detected that we're running in a container, the name     of the container runtime</p> </li> <li> <p><code>cpu_brand</code> - required <code>string</code>. Identifies the CPU.  If you have a mixture of different CPUs,     this will be a comma separated list of the different CPUs</p> </li> <li> <p><code>distribution</code> - required <code>string</code>. The OS distribution</p> </li> <li> <p><code>fingerprint</code> - required <code>string</code>. Additional metadata hash(es) that can identify the running machine.     For example, when running in AWS, the instance-id will be     included.</p> </li> <li> <p><code>hostname</code> - required <code>string</code>. The hostname of the system, as reported by <code>gethostname(2)</code></p> </li> <li> <p><code>kernel_version</code> - optional nullable <code>string</code>. The kernel version</p> </li> <li> <p><code>mac_address</code> - required <code>string</code>. The MAC address of the primary, non-loopback, network interface</p> </li> <li> <p><code>node_id</code> - required <code>string</code>. The NodeID of the system</p> </li> <li> <p><code>num_cores</code> - required <code>integer</code>. The number of available CPUs as reported by     https://docs.rs/num_cpus/latest/num_cpus/fn.get.html</p> </li> <li> <p><code>online_since</code> - required <code>string</code> (<code>date-time</code>). The date/time at which the process was last started</p> </li> <li> <p><code>os_version</code> - required <code>string</code>. The OS version (which often includes the distribution)</p> </li> <li> <p><code>platform</code> - required <code>string</code>. Identifies the running platform</p> </li> <li> <p><code>process_kind</code> - required <code>string</code>. Which process is running. eg: <code>kumod</code> vs <code>tsa-daemon</code> vs. <code>proxy-server</code>.</p> </li> <li> <p><code>total_memory_bytes</code> - required <code>integer</code> (<code>u-int64</code>). Total physical memory installed in the instance</p> </li> <li> <p><code>version</code> - required <code>string</code>. The version of KumoMTA that is running</p> </li> </ul>","tags":["debugging"]},{"location":"reference/http/kumod/api_machine_info_get/#examples","title":"Examples","text":"<pre><code>{\n  \"container_runtime\": \"string\",\n  \"cpu_brand\": \"Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz\",\n  \"distribution\": \"ubuntu\",\n  \"fingerprint\": \"aws_instance_id=i-09aebefac97cf0000,machine_uid=ec22130d1de33cf52413457ac040000\",\n  \"hostname\": \"mta1.example.com\",\n  \"kernel_version\": \"6.8.0-1016-aws\",\n  \"mac_address\": \"02:02:02:02:02:02\",\n  \"node_id\": \"9745bb48-14d7-48f2-a1fb-7df8d5844217\",\n  \"num_cores\": 64,\n  \"online_since\": \"1990-12-31T23:59:60Z\",\n  \"os_version\": \"Linux (Ubuntu 24.04)\",\n  \"platform\": \"linux/x86_64\",\n  \"process_kind\": \"kumod\",\n  \"total_memory_bytes\": 1003929600,\n  \"version\": \"2026.02.24-2d1a3174\"\n}\n</code></pre>","tags":["debugging"]},{"location":"reference/http/kumod/api_xfer_inject_v1_post/","title":"POST /api/xfer/inject/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Performs a message transfer.</p> <p>Warning</p> <p>This is considered to be an internal API and should not be used by external consumers.  It is intentionally under-specified in these auto-generated docs.</p> <p>You probably want to look at the /api/admin/xfer/v1 endpoint which is used to request that a specific queue should be re-routed via this XFER endpoint on the target node.</p>","tags":["xfer"]},{"location":"reference/http/kumod/api_xfer_inject_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>text/plain</code>.</p> <p>This is a string value.</p>","tags":["xfer"]},{"location":"reference/http/kumod/api_xfer_inject_v1_post/#examples","title":"Examples","text":"<pre><code>\"string\"\n</code></pre>","tags":["xfer"]},{"location":"reference/http/kumod/api_xfer_inject_v1_post/#responses","title":"Responses","text":"","tags":["xfer"]},{"location":"reference/http/kumod/api_xfer_inject_v1_post/#status-200","title":"Status 200","text":"<p>Message transferred successfully</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required SpoolId. Identifies a message within the spool of its host node.</li> </ul>","tags":["xfer"]},{"location":"reference/http/kumod/api_xfer_inject_v1_post/#examples_1","title":"Examples","text":"<pre><code>{\n  \"id\": \"d7ef132b5d7711eea8c8000c29c33806\"\n}\n</code></pre>","tags":["xfer"]},{"location":"reference/http/kumod/metrics.json_get/","title":"GET /metrics.json","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns the current set of metrics in a json representation. This is easier to consume than the Prometheus Exposition format, but is more resource intensive to produce and parse when the number of metrics is large, such as for a busy server.</p> <p>Note</p> <p>Metrics generally represent data at the current point in time, to be consumed by an external system (such as Prometheus) which then in turn can build time series data around those metrics.</p> <p>In addition, in order to avoid unbounded RAM usage for systems with many queues, a number of queue- or service-specific metrics will be automatically pruned away when the corresponding queue idles out for a period of time.</p> <p>In the default configuration, access to this endpoint requires Trusted IP authentication.  See the Authorization documentation for more information on adjusting ACLs.</p> <p>See also metrics.</p>","tags":[]},{"location":"reference/http/kumod/metrics.json_get/#metric-documentation","title":"Metric Documentation","text":"<ul> <li>Metrics exported by kumod</li> </ul>","tags":[]},{"location":"reference/http/kumod/metrics.json_get/#example-data","title":"Example Data","text":"<p>Here's an example of the shape of the data.  The precise set of counters will vary as we continue to enhance KumoMTA:</p> <pre><code>{\n  \"connection_count\": {\n    \"help\": \"number of active connections\",\n    \"type\": \"gauge\",\n    \"value\": {\n      \"service\": {\n        \"esmtp_listener\": 0.0,\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"scheduled_count\": {\n    \"help\": \"number of messages in the scheduled queue\",\n    \"type\": \"gauge\",\n    \"value\": {\n      \"queue\": {\n        \"example.com\": 0.0\n      }\n    }\n  },\n  \"lua_count\": {\n    \"help\": \"the number of lua contexts currently alive\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"lua_load_count\": {\n    \"help\": \"how many times the policy lua script has been loaded into a new context\",\n    \"type\": \"counter\",\n    \"value\": 1.0\n  },\n  \"lua_spare_count\": {\n    \"help\": \"the number of lua contexts available for reuse in the pool\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"memory_limit\": {\n    \"help\": \"soft memory limit measured in bytes\",\n    \"type\": \"gauge\",\n    \"value\": 101234377728.0\n  },\n  \"memory_usage\": {\n    \"help\": \"number of bytes of used memory\",\n    \"type\": \"gauge\",\n    \"value\": 185683968.0\n  },\n  \"message_count\": {\n    \"help\": \"total number of Message objects\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"message_data_resident_count\": {\n    \"help\": \"total number of Message objects with body data loaded\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"message_meta_resident_count\": {\n    \"help\": \"total number of Message objects with metadata loaded\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"ready_count\": {\n    \"help\": \"number of messages in the ready queue\",\n    \"type\": \"gauge\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client:source1-&gt;loopback.dummy-mx.example.com\": 46.0,\n        \"smtp_client:source2-&gt;loopback.dummy-mx.example.com\": 152.0,\n      }\n    }\n  },\n  \"total_connection_count\": {\n    \"help\": \"total number of active connections ever made\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"total_messages_delivered\": {\n    \"help\": \"total number of messages ever delivered\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"total_messages_fail\": {\n    \"help\": \"total number of message delivery attempts that permanently failed\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"total_messages_transfail\": {\n    \"help\": \"total number of message delivery attempts that transiently failed\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  }\n}\n</code></pre>","tags":[]},{"location":"reference/http/kumod/metrics.json_get/#responses","title":"Responses","text":"","tags":[]},{"location":"reference/http/kumod/metrics.json_get/#status-200","title":"Status 200","text":"<p><code>Content-Type: application/json</code></p>","tags":[]},{"location":"reference/http/kumod/metrics_get/","title":"GET /metrics","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns the current set of metrics in Prometheus Text Exposition Format.</p> <p>Note</p> <p>Metrics generally represent data at the current point in time, to be consumed by an external system (such as Prometheus) which then in turn can build time series data around those metrics.</p> <p>In addition, in order to avoid unbounded RAM usage for systems with many queues, a number of queue- or service-specific metrics will be automatically pruned away when the corresponding queue idles out for a period of time.</p> <p>In the default configuration, access to this endpoint requires Trusted IP authentication.  See the Authorization documentation for more information on adjusting ACLs.</p> <p>See also metrics.json.</p>","tags":[]},{"location":"reference/http/kumod/metrics_get/#metric-documentation","title":"Metric Documentation","text":"<ul> <li>Metrics exported by kumod</li> </ul>","tags":[]},{"location":"reference/http/kumod/metrics_get/#example-data","title":"Example Data","text":"<p>Here's an example of the shape of the data.  The precise set of counters will vary as we continue to enhance KumoMTA.</p> <p>You can see the current list by querying the endpoint with no arguments:</p> <pre><code>$ curl http://localhost:8000/metrics\n</code></pre> <pre><code># HELP connection_count number of active connections\n# TYPE connection_count gauge\nconnection_count{service=\"esmtp_listener\"} 0\n# HELP disk_free_bytes number of available bytes in a monitored location\n# TYPE disk_free_bytes gauge\ndisk_free_bytes{name=\"data spool\"} 15658725376\ndisk_free_bytes{name=\"log dir /var/log/kumomta\"} 15658725376\ndisk_free_bytes{name=\"meta spool\"} 15658725376\n# HELP disk_free_inodes number of available inodes in a monitored location\n# TYPE disk_free_inodes gauge\ndisk_free_inodes{name=\"data spool\"} 3056405\ndisk_free_inodes{name=\"log dir /var/log/kumomta\"} 3056405\ndisk_free_inodes{name=\"meta spool\"} 3056405\n# HELP disk_free_inodes_percent percentage of available inodes in a monitored location\n# TYPE disk_free_inodes_percent gauge\ndisk_free_inodes_percent{name=\"data spool\"} 94\ndisk_free_inodes_percent{name=\"log dir /var/log/kumomta\"} 94\ndisk_free_inodes_percent{name=\"meta spool\"} 94\n# HELP disk_free_percent percentage of available bytes in a monitored location\n# TYPE disk_free_percent gauge\ndisk_free_percent{name=\"data spool\"} 60\ndisk_free_percent{name=\"log dir /var/log/kumomta\"} 60\ndisk_free_percent{name=\"meta spool\"} 60\n# HELP log_submit_latency latency of log event submission operations\n# TYPE log_submit_latency histogram\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.005\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.01\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.025\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.05\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.1\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.25\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.5\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"1\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"2.5\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"5\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"10\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"+Inf\"} 0\nlog_submit_latency_sum{logger=\"dir-/var/log/kumomta\"} 0\nlog_submit_latency_count{logger=\"dir-/var/log/kumomta\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.005\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.01\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.025\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.05\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.1\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.25\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.5\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"1\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"2.5\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"5\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"10\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"+Inf\"} 0\nlog_submit_latency_sum{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\"} 0\nlog_submit_latency_count{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\"} 0\n# HELP lua_count the number of lua contexts currently alive\n# TYPE lua_count gauge\nlua_count 1\n# HELP lua_event_latency how long a given lua event callback took\n# TYPE lua_event_latency histogram\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.005\"} 0\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.01\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.025\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.05\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.1\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.25\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.5\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"1\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"2.5\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"5\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"10\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"+Inf\"} 3\nlua_event_latency_sum{event=\"context-creation\"} 0.017253747\nlua_event_latency_count{event=\"context-creation\"} 3\nlua_event_latency_bucket{event=\"init\",le=\"0.005\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.01\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.025\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.05\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.1\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.25\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.5\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"1\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"2.5\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"5\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"10\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"+Inf\"} 1\nlua_event_latency_sum{event=\"init\"} 0.442427973\nlua_event_latency_count{event=\"init\"} 1\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.005\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.01\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.025\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.05\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.1\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.25\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.5\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"1\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"2.5\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"5\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"10\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"+Inf\"} 0\nlua_event_latency_sum{event=\"kumo.tsa.suspension.subscriber\"} 0\nlua_event_latency_count{event=\"kumo.tsa.suspension.subscriber\"} 0\n# HELP lua_load_count how many times the policy lua script has been loaded into a new context\n# TYPE lua_load_count counter\nlua_load_count 3\n# HELP lua_spare_count the number of lua contexts available for reuse in the pool\n# TYPE lua_spare_count gauge\nlua_spare_count 0\n# HELP memory_limit soft memory limit measured in bytes\n# TYPE memory_limit gauge\nmemory_limit 1538067456\n# HELP memory_usage number of bytes of used memory\n# TYPE memory_usage gauge\nmemory_usage 320516096\n# HELP thread_pool_parked number of parked(idle) threads in a thread pool\n# TYPE thread_pool_parked gauge\nthread_pool_parked{pool=\"localset\"} 0\nthread_pool_parked{pool=\"logging\"} 1\n# HELP thread_pool_size number of threads in a thread pool\n# TYPE thread_pool_size gauge\nthread_pool_size{pool=\"localset\"} 1\nthread_pool_size{pool=\"logging\"} 1\n# HELP tokio_budget_forced_yield_count Returns the number of times that tasks have been forced to yield back to the scheduler after exhausting their task budgets.\n# TYPE tokio_budget_forced_yield_count counter\ntokio_budget_forced_yield_count 0\n# HELP tokio_elapsed Total amount of time elapsed since observing runtime metrics.\n# TYPE tokio_elapsed counter\ntokio_elapsed 1057.312763632\n# HELP tokio_injection_queue_depth The number of tasks currently scheduled in the runtime\u2019s injection queue.\n# TYPE tokio_injection_queue_depth gauge\ntokio_injection_queue_depth 0\n# HELP tokio_io_driver_ready_count Returns the number of ready events processed by the runtime\u2019s I/O driver.\n# TYPE tokio_io_driver_ready_count counter\ntokio_io_driver_ready_count 0\n# HELP tokio_num_remote_schedules The number of tasks scheduled from outside of the runtime.\n# TYPE tokio_num_remote_schedules counter\ntokio_num_remote_schedules 0\n# HELP tokio_total_busy_duration The amount of time worker threads were busy.\n# TYPE tokio_total_busy_duration counter\ntokio_total_busy_duration 0\n# HELP tokio_total_local_queue_depth The total number of tasks currently scheduled in workers\u2019 local queues.\n# TYPE tokio_total_local_queue_depth gauge\ntokio_total_local_queue_depth 0\n# HELP tokio_total_local_schedule_count The number of tasks scheduled from worker threads.\n# TYPE tokio_total_local_schedule_count counter\ntokio_total_local_schedule_count 0\n# HELP tokio_total_noop_count The number of times worker threads unparked but performed no work before parking again.\n# TYPE tokio_total_noop_count counter\ntokio_total_noop_count 0\n# HELP tokio_total_overflow_count The number of times worker threads saturated their local queues.\n# TYPE tokio_total_overflow_count counter\ntokio_total_overflow_count 0\n# HELP tokio_total_park_count The number of times worker threads parked.\n# TYPE tokio_total_park_count counter\ntokio_total_park_count 0\n# HELP tokio_total_polls_count The number of tasks that have been polled across all worker threads.\n# TYPE tokio_total_polls_count counter\ntokio_total_polls_count 0\n# HELP tokio_total_steal_count The number of tasks worker threads stole from another worker thread.\n# TYPE tokio_total_steal_count counter\ntokio_total_steal_count 0\n# HELP tokio_total_steal_operations The number of times worker threads stole tasks from another worker thread.\n# TYPE tokio_total_steal_operations counter\ntokio_total_steal_operations 0\n# HELP tokio_workers_count The number of worker threads used by the runtime.\n# TYPE tokio_workers_count gauge\ntokio_workers_count 1\n# HELP total_connections_denied total number of connections rejected due to load shedding or concurrency limits\n# TYPE total_connections_denied counter\ntotal_connections_denied{service=\"esmtp_listener\"} 0\n</code></pre>","tags":[]},{"location":"reference/http/kumod/metrics_get/#responses","title":"Responses","text":"","tags":[]},{"location":"reference/http/kumod/metrics_get/#status-200","title":"Status 200","text":"<p><code>Content-Type: text/plain</code></p>","tags":[]},{"location":"reference/http/kumod/schemas/","title":"API Types for kumod service","text":"<p>The following types are defined for the kumod service:</p>"},{"location":"reference/http/kumod/schemas/Attachment/","title":"Attachment","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>base64</code> - optional <code>boolean</code>. If true, the <code>data</code> field must be encoded as base64</p> </li> <li> <p><code>content_id</code> - optional nullable <code>string</code>. Optional <code>Content-ID</code> header for this attachment.     If specified, this attachment will be added as an     inline attachment and a multipart/related MIME     container will be generated in the message to hold     it and the textual content.</p> </li> <li> <p><code>content_type</code> - required <code>string</code>. The MIME <code>Content-Type</code> header that should be     set for this attachment.</p> </li> <li> <p><code>data</code> - required <code>string</code>. The content of the payload.     This is interpreted as UTF-8 text unless the     <code>base64</code> field is set to <code>true</code>.</p> </li> <li> <p><code>file_name</code> - optional nullable <code>string</code>. The the preferred filename for the attachment</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/Attachment/#examples","title":"Examples","text":"<p><pre><code>{\n  \"base64\": false,\n  \"content_id\": \"string\",\n  \"content_type\": \"string\",\n  \"data\": \"string\",\n  \"file_name\": \"string\"\n}\n</code></pre> <pre><code>{\n  \"base64\": true,\n  \"content_id\": \"my-image\",\n  \"content_type\": \"image/gif\",\n  \"data\": \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\",\n  \"file_name\": \"pixel.gif\"\n}\n</code></pre></p>"},{"location":"reference/http/kumod/schemas/BounceV1CancelRequest/","title":"BounceV1CancelRequest","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). </li> </ul>"},{"location":"reference/http/kumod/schemas/BounceV1CancelRequest/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/BounceV1ListEntry/","title":"BounceV1ListEntry","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>bounced</code> - required <code>object</code>. A map of queue name to number of bounced messages that     were processed by this entry since it was created.</p> </li> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign field of the original request, if any.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain field of the original request, if any.</p> </li> <li> <p><code>duration</code> - required <code>string</code>. The time remaining until this entry expires and is automatically     removed.</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of this bounce rule. Corresponds to the <code>id</code> field     returned by the originating request that set up the bounce,     and can be used to identify this particular entry if you     wish to delete it later.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason field of the original request</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain field of the original request, if any.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant field of the original request, if any.</p> </li> <li> <p><code>total_bounced</code> - required <code>integer</code>. The sum of the number of bounced messages reported by     the <code>bounced</code> field.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/BounceV1ListEntry/#examples","title":"Examples","text":"<pre><code>{\n  \"bounced\": {\n    \"gmail.com\": 200,\n    \"yahoo.com\": 100\n  },\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"string\",\n  \"id\": \"552016f1-08e7-4e90-9da3-fd5c25acd069\",\n  \"reason\": \"cleaning up a bad send\",\n  \"routing_domain\": \"routing_domain.com\",\n  \"tenant\": \"tenant_name\",\n  \"total_bounced\": 42\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/BounceV1Request/","title":"BounceV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Describes which messages should be bounced. The criteria apply to the scheduled queue associated with a given message.</p> <p>Danger</p> <p>If you specify none of <code>domain</code>, <code>campaign</code>, <code>tenant</code>, <code>routing_domain</code> or <code>queue</code>, then ALL queues will be bounced.</p> <p>With great power comes great responsibility!</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>duration</code> - optional nullable <code>string</code>. Defaults to \"5m\". Specifies how long this bounce directive remains active.     While active, newly injected messages that match the bounce criteria     will also be bounced.</p> </li> <li> <p><code>expires</code> - optional nullable <code>string</code> (<code>date-time</code>). instead of specifying the duration, you can set an explicit     expiration timestamp</p> </li> <li> <p><code>queue_names</code> - optional array of <code>string</code>. If present, queue_names takes precedence over <code>campaign</code>,     <code>tenant</code>, and <code>domain</code> and specifies the exact set of     scheduled queue names to which the bounce applies.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will be bounced     with an AdminBounce record unless you suppress logging.     The reason will also be shown in the list of currently active admin     bounces.</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain name to match. If omitted, any routing_domain will match.     (Since: Version 2023.08.22-4d895015)</p> </li> <li> <p><code>suppress_logging</code> - optional <code>boolean</code>. If true, do not generate AdminBounce delivery logs for matching     messages.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant to match. If omitted, any tenant will match.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/BounceV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"20m\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"queue_names\": [\n    \"campaign_name:tenant_name@example.com\"\n  ],\n  \"reason\": \"Cleaning up a bad send\",\n  \"routing_domain\": \"routing_domain.com\",\n  \"suppress_logging\": false,\n  \"tenant\": \"tenant_name\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/BounceV1Response/","title":"BounceV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>bounced</code> - required <code>object</code>. Deprecated: this field is no longer populated, as bounces     are now always asynchronous. In earlier versions the following     applies:</p> <p>A map of queue name to number of bounced messages that were processed as part of the initial sweep. Additional bounces may be generated if/when other messages that match the rule are discovered, but those obviously cannot be reported in the context of the initial request.</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the bounce rule that was registered.     This can be used later to delete the rule if desired.</p> </li> <li> <p><code>total_bounced</code> - required <code>integer</code>. Deprecated: this field is no longer populated, as bounces are     now always asynchronous. In earlier versions the following applies:</p> <p>The sum of the number of bounced messages reported by the <code>bounced</code> field.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/BounceV1Response/#examples","title":"Examples","text":"<pre><code>{\n  \"bounced\": {\n    \"gmail.com\": 200,\n    \"yahoo.com\": 100\n  },\n  \"id\": \"552016f1-08e7-4e90-9da3-fd5c25acd069\",\n  \"total_bounced\": 300\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/Content/","title":"Content","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>The message content. Can either be a fully formed MIME message, or a json object describing the MIME structure that should be created.</p> <p>Can be one of the following shapes of data:</p>"},{"location":"reference/http/kumod/schemas/Content/#option-1","title":"Option 1","text":"<p>A complete MIME message string</p> <p>This is a string value.</p>"},{"location":"reference/http/kumod/schemas/Content/#option-2","title":"Option 2","text":"<p>Describe the MIME structure to be created</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>amp_html_body</code> - optional nullable <code>string</code>. If set, will be used to create a text/x-amp-html part.     This is available (Since: Dev Builds Only)</p> </li> <li> <p><code>attachments</code> - optional array of Attachment. Optional list of attachments.</p> </li> <li> <p><code>from</code> - optional nullable FromHeader. </p> </li> <li> <p><code>headers</code> - optional <code>object</code>. Optional map of headers to include in the message.     This is a map of header name to header value</p> </li> <li> <p><code>html_body</code> - optional nullable <code>string</code>. If set, will be used to create a text/html part</p> </li> <li> <p><code>reply_to</code> - optional nullable FromHeader. </p> </li> <li> <p><code>subject</code> - optional nullable <code>string</code>. Set the Subject: header</p> </li> <li> <p><code>text_body</code> - optional nullable <code>string</code>. If set, will be used to create a text/plain part</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/Content/#examples","title":"Examples","text":"<p><pre><code>\"From: user@example.com\\nSubject: Hello\\n\\nHello there\"\n</code></pre> <pre><code>{\n  \"amp_html_body\": \"&lt;!doctype html&gt;&lt;html amp4email&gt;...&lt;/html&gt;\",\n  \"attachments\": [\n    {\n      \"base64\": true,\n      \"content_id\": \"my-image\",\n      \"content_type\": \"image/gif\",\n      \"data\": \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\",\n      \"file_name\": \"pixel.gif\"\n    }\n  ],\n  \"from\": {\n    \"email\": \"sales@sender-example.com\",\n    \"name\": \"Sales\"\n  },\n  \"headers\": {\n    \"X-Tenant\": \"MyTenant\"\n  },\n  \"html_body\": \"&lt;p&gt;This is the &lt;b&gt;HTML&lt;/b&gt; part&lt;/p&gt;\",\n  \"reply_to\": {\n    \"email\": \"sales@sender-example.com\",\n    \"name\": \"Sales\"\n  },\n  \"subject\": \"string\",\n  \"text_body\": \"This is the plain text part\"\n}\n</code></pre></p>"},{"location":"reference/http/kumod/schemas/FromHeader/","title":"FromHeader","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>email</code> - required <code>string</code> (<code>email</code>). The email address of the sender</p> </li> <li> <p><code>name</code> - optional nullable <code>string</code>. The displayable name of the sender</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/FromHeader/#examples","title":"Examples","text":"<pre><code>{\n  \"email\": \"sales@sender-example.com\",\n  \"name\": \"Sales\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/HttpTraceHeaders/","title":"HttpTraceHeaders","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>The <code>HttpTraceHeaders</code> type is an alias for TraceHeaders</p>"},{"location":"reference/http/kumod/schemas/InjectV1Request/","title":"InjectV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>content</code> - required Content. Specifies the message content. It can either be a string value or     a JSON object describing how to build a the message.</p> <p>If a simple string is provided, it must be an RFC822 compliant message.  If template substitutions are used in the request, then the entire RFC822 message string is used as-is for the template; no message parsing or decoding is performed as part of template expansion.</p> <p>Alternatively the content can be specified as a JSON object as demonstrated in the docs for the <code>Content</code> type.</p> <p>When building a message, template substitutions are applied to the <code>text_body</code>, <code>html_body</code>, <code>amp_html_body</code> and <code>headers</code> fields.</p> <p>Attachments are not subject to template substitution.</p> </li> <li> <p><code>deferred_generation</code> - optional <code>boolean</code>. (Since: Version 2024.11.08-d383b033)</p> <p>When set to true, the injection request will be queued and the actual generation and substitution will happen asynchronously with respect to the injection request. The default mode of operation is to respond to the injection request only once every message in the request has been enqueued to the internal queue system. This provides back pressure to the injection system and prevents the service from being overwhelmed if the rate of ingress exceeds the maximum rate of egress.</p> <p>The result of this back pressure is that the latency of the injection request depends on the load of the system.</p> <p>Setting <code>deferred_generation: true</code> in the request alters the processing flow: instead of immediately expanding the request into the desired number of messages and queueing them up, the injection request is itself queued up and processed asynchronously with respect to the incoming request.</p> <p>This <code>deferred_generation</code> submission is typically several orders of magnitude faster than the immediate generation mode, so it is possible to very very quickly queue up large batches of messages this way.</p> <p>The deferred generation requests are queued internally to a special queue named <code>generator.kumomta.internal</code> that will process them by spawning each request into the <code>httpinject</code> thread pool.</p> <p>You will likely want and need to configure shaping to accomodate this queue for best performance:</p> <pre><code>-- Locate this before any other helpers or modules that define\n-- `get_egress_path_config` event handlers in order for it to take effect\nkumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    if routing_domain == 'generator.kumomta.internal' then\n      return kumo.make_egress_path {\n        -- This is a good place to start, but you may want to\n        -- experiment with 1/2, 3/4, or 1.5 times this to find\n        -- what works best in your environment\n        connection_limit = kumo.available_parallelism(),\n        refresh_strategy = 'Epoch',\n        max_ready = 80000,\n      }\n    end\n  end\n)\n</code></pre> <p>Note</p> <p>It is possible to very quickly generate millions of queued messages when using <code>deferred_generation: true</code>. You may wish to look into configuring a rate limit to constrain the system appropriately for your environment. https://docs.kumomta.com/reference/kumo/set_httpinject_recipient_rate_limit/ can be used for this purpose.</p> </li> <li> <p><code>deferred_spool</code> - optional <code>boolean</code>. (Since: Version 2024.11.08-d383b033)</p> <p>Danger</p> <p>Enabling deferred spooling may result in loss of accountability for messages.  You should satisfy yourself that your system is able to recognize and deal with that scenario if/when it arises.</p> <p>When set to <code>true</code>, the generated message(s) will not be written to the spool until it encounters its first transient failure.  This can improve injection rate but introduces the risk of loss of accountability for the message if the system were to crash before the message is delivered or written to spool, so use with caution!</p> <p>When used in conjunction with <code>deferred_generation</code>, both the queued generation request and the messages which it produces are subject to deferred spooling.</p> </li> <li> <p><code>envelope_sender</code> - required <code>string</code> (<code>email</code>). Specify the envelope sender that will be sent in the     MAIL FROM portion of SMTP.</p> </li> <li> <p><code>recipients</code> - required array of Recipient. Specifies the list of recipients to which message(s) will be sent.     When generating the message for the recipient, a suitable <code>To</code> header will be     constructed using the provided fields.</p> <p>If you also set a <code>To</code> header using the <code>headers</code> field, then the behavior depends on the version of kumomta:</p> Behavior Version The per-recipient <code>To</code> header will not be generated (Since: Dev Builds Only) Two <code>To</code> headers will be generated All previous versions </li> <li> <p><code>substitutions</code> - optional <code>object</code>. When using templating, this is the map of placeholder     name to replacement value that should be used by     the templating engine.  This map applies to all     recipients, with the per-recipient substitutions     taking precedence.</p> </li> <li> <p><code>template_dialect</code> - optional TemplateDialectWithSchema. (Since: Version 2025.12.02-67ee9e96)</p> <p>It is now possible to specify which template engine will be used for template expansion via the <code>template_dialect</code> field. It can have one of the following values:</p> <ul> <li><code>Jinja</code> - this is the implied default.  The Mini Jinja    template dialect will be parsed and evaluated.</li> <li><code>Static</code> - The content is treated as a static string and    no template expansion will be performed</li> <li><code>Handlebars</code> - The content will be evaluated by a handlebars    compatible template engine.</li> </ul> </li> <li> <p><code>trace_headers</code> - optional HttpTraceHeaders. (Since: Version 2024.11.08-d383b033)</p> <p>Controls the addition of tracing headers to received messages.</p> <p>KumoMTA can add two different headers to aid in later tracing:</p> <ul> <li> <p>The standard <code>\"Received\"</code> header which captures SMTP relay   hops on their path to the inbox</p> </li> <li> <p>A supplemental header which can be used to match feedback   reports back to the originating mailing</p> </li> </ul> <p>Prior to triggering the https://docs.kumomta.com/reference/events/http_message_generated/ event the standard <code>\"Received\"</code> header will be added to the message.  Then, once the event completes and your policy has had the opportunity to alter the meta data associated with the message, the supplemental header will be added.</p> <pre><code>{\n  \"trace_headers\": {\n    // this is the default: do NOT add the Received: header\n    \"received_header\": false,\n\n    // this is the default: add the supplemental header\n    \"supplemental_header\": true,\n\n    // this is the default: the name of the supplemental header\n    \"header_name\": \"X-KumoRef\",\n\n    // names of additional meta data fields\n    // to include in the header. TAKE CARE! The header will be\n    // base64 encoded to prevent casual introspection, but the\n    // header is NOT encrypted and the values of the meta data\n    // fields included here should be considered to be public.\n    // The default is not to add any meta data fields, but you\n    // might consider setting something like:\n    // \"include_meta_names\": { \"tenant\", \"campaign\" },\n    \"include_meta_names\": {},\n  },\n}\n</code></pre> <p>Here's an example of a supplemental header from a message:</p> <pre><code>X-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\n</code></pre> <p>the decoded payload contains a magic marker key as well as the recipient of the original message:</p> <pre><code>{\"_@_\":\"\\\\_/\",\"recipient\":\"test@example.com\"}\n</code></pre> <p>Any meta data fields that were listed in <code>include_meta_names</code>, if the corresponding meta data was set in the message, would also be captured in the decoded payload.</p> <p>KumoMTA will automatically extract this supplemental trace header information from any <code>X-</code> header that is successfully parsed and has the magic marker key when processing the original message payload of an incoming ARF report.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/InjectV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"content\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n  \"deferred_generation\": false,\n  \"deferred_spool\": false,\n  \"envelope_sender\": \"some.id@bounces.sender-example.com\",\n  \"recipients\": [\n    {\n      \"email\": \"john.smith@mailbox-example.com\",\n      \"name\": \"John Smith\",\n      \"substitutions\": {\n        \"age\": 42,\n        \"gender\": \"male\"\n      }\n    }\n  ],\n  \"substitutions\": {\n    \"campaign_title\": \"Fall Campaign\"\n  },\n  \"template_dialect\": \"Jinja\",\n  \"trace_headers\": {\n    \"header_name\": \"string\",\n    \"include_meta_names\": [\n      \"string\"\n    ],\n    \"received_header\": false,\n    \"supplemental_header\": false\n  }\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/InjectV1Response/","title":"InjectV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>errors</code> - required array of <code>string</code>. The list of error messages</p> </li> <li> <p><code>fail_count</code> - required <code>integer</code>. The number of messages that failed to inject</p> </li> <li> <p><code>failed_recipients</code> - required array of <code>string</code> (<code>email</code>). The list of failed recipients</p> </li> <li> <p><code>success_count</code> - required <code>integer</code>. The number of messages that were injected successfully</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/InjectV1Response/#examples","title":"Examples","text":"<pre><code>{\n  \"errors\": [\n    \"string\"\n  ],\n  \"fail_count\": 42,\n  \"failed_recipients\": [\n    \"user@example.com\"\n  ],\n  \"success_count\": 42\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/InspectMessageV1Response/","title":"InspectMessageV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>id</code> - required SpoolId. The spool identifier of the message</p> </li> <li> <p><code>message</code> - required MessageInformation. The message information</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/InspectMessageV1Response/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n  \"message\": {\n    \"data\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n    \"due\": \"1990-12-31T23:59:60Z\",\n    \"meta\": {},\n    \"num_attempts\": 42,\n    \"recipient\": \"recipient@example.com\",\n    \"scheduling\": {},\n    \"sender\": \"sender@sender.example.com\"\n  }\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/InspectQueueV1Response/","title":"InspectQueueV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>delayed_metric</code> - required <code>integer</code>. </p> </li> <li> <p><code>last_changed</code> - required <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>messages</code> - required array of InspectMessageV1Response. </p> </li> <li> <p><code>now</code> - required <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>num_scheduled</code> - required <code>integer</code>. </p> </li> <li> <p><code>queue_config</code> - required <code>object</code>. </p> </li> <li> <p><code>queue_name</code> - required <code>string</code>. </p> </li> </ul>"},{"location":"reference/http/kumod/schemas/InspectQueueV1Response/#examples","title":"Examples","text":"<pre><code>{\n  \"delayed_metric\": 42,\n  \"last_changed\": \"1990-12-31T23:59:60Z\",\n  \"messages\": [\n    {\n      \"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n      \"message\": {\n        \"data\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n        \"due\": \"1990-12-31T23:59:60Z\",\n        \"meta\": {},\n        \"num_attempts\": 42,\n        \"recipient\": \"recipient@example.com\",\n        \"scheduling\": {},\n        \"sender\": \"sender@sender.example.com\"\n      }\n    }\n  ],\n  \"now\": \"1990-12-31T23:59:60Z\",\n  \"num_scheduled\": 42,\n  \"queue_config\": {},\n  \"queue_name\": \"campaign_name:tenant_name@example.com\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/MachineInfoV1/","title":"MachineInfoV1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>container_runtime</code> - optional nullable <code>string</code>. If we detected that we're running in a container, the name     of the container runtime</p> </li> <li> <p><code>cpu_brand</code> - required <code>string</code>. Identifies the CPU.  If you have a mixture of different CPUs,     this will be a comma separated list of the different CPUs</p> </li> <li> <p><code>distribution</code> - required <code>string</code>. The OS distribution</p> </li> <li> <p><code>fingerprint</code> - required <code>string</code>. Additional metadata hash(es) that can identify the running machine.     For example, when running in AWS, the instance-id will be     included.</p> </li> <li> <p><code>hostname</code> - required <code>string</code>. The hostname of the system, as reported by <code>gethostname(2)</code></p> </li> <li> <p><code>kernel_version</code> - optional nullable <code>string</code>. The kernel version</p> </li> <li> <p><code>mac_address</code> - required <code>string</code>. The MAC address of the primary, non-loopback, network interface</p> </li> <li> <p><code>node_id</code> - required <code>string</code>. The NodeID of the system</p> </li> <li> <p><code>num_cores</code> - required <code>integer</code>. The number of available CPUs as reported by     https://docs.rs/num_cpus/latest/num_cpus/fn.get.html</p> </li> <li> <p><code>online_since</code> - required <code>string</code> (<code>date-time</code>). The date/time at which the process was last started</p> </li> <li> <p><code>os_version</code> - required <code>string</code>. The OS version (which often includes the distribution)</p> </li> <li> <p><code>platform</code> - required <code>string</code>. Identifies the running platform</p> </li> <li> <p><code>process_kind</code> - required <code>string</code>. Which process is running. eg: <code>kumod</code> vs <code>tsa-daemon</code> vs. <code>proxy-server</code>.</p> </li> <li> <p><code>total_memory_bytes</code> - required <code>integer</code> (<code>u-int64</code>). Total physical memory installed in the instance</p> </li> <li> <p><code>version</code> - required <code>string</code>. The version of KumoMTA that is running</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/MachineInfoV1/#examples","title":"Examples","text":"<pre><code>{\n  \"container_runtime\": \"string\",\n  \"cpu_brand\": \"Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz\",\n  \"distribution\": \"ubuntu\",\n  \"fingerprint\": \"aws_instance_id=i-09aebefac97cf0000,machine_uid=ec22130d1de33cf52413457ac040000\",\n  \"hostname\": \"mta1.example.com\",\n  \"kernel_version\": \"6.8.0-1016-aws\",\n  \"mac_address\": \"02:02:02:02:02:02\",\n  \"node_id\": \"9745bb48-14d7-48f2-a1fb-7df8d5844217\",\n  \"num_cores\": 64,\n  \"online_since\": \"1990-12-31T23:59:60Z\",\n  \"os_version\": \"Linux (Ubuntu 24.04)\",\n  \"platform\": \"linux/x86_64\",\n  \"process_kind\": \"kumod\",\n  \"total_memory_bytes\": 1003929600,\n  \"version\": \"2026.02.24-2d1a3174\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/MessageInformation/","title":"MessageInformation","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>data</code> - optional nullable <code>string</code>. If <code>want_body</code> was set in the original request,     holds the message body</p> </li> <li> <p><code>due</code> - optional nullable <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>meta</code> - required <code>object</code>. The message metadata</p> </li> <li> <p><code>num_attempts</code> - optional nullable <code>integer</code> (<code>u-int16</code>). </p> </li> <li> <p><code>recipient</code> - required array of <code>string</code> (<code>email</code>). The envelope-to address.     May be either an individual string or an array of strings     for multi-recipient messages.</p> </li> <li> <p><code>scheduling</code> - optional <code>object</code>. </p> </li> <li> <p><code>sender</code> - required <code>string</code>. The envelope sender</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/MessageInformation/#examples","title":"Examples","text":"<pre><code>{\n  \"data\": \"From: user@example.com\\nSubject: Hello\\n\\nHello there\",\n  \"due\": \"1990-12-31T23:59:60Z\",\n  \"meta\": {},\n  \"num_attempts\": 42,\n  \"recipient\": \"recipient@example.com\",\n  \"scheduling\": {},\n  \"sender\": \"sender@sender.example.com\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/QueueState/","title":"QueueState","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>context</code> - required <code>string</code>. </p> </li> <li> <p><code>since</code> - required <code>string</code> (<code>date-time</code>). </p> </li> </ul>"},{"location":"reference/http/kumod/schemas/QueueState/#examples","title":"Examples","text":"<pre><code>{\n  \"context\": \"TooManyLeases for queue\",\n  \"since\": \"1990-12-31T23:59:60Z\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/ReadyQueueStateResponse/","title":"ReadyQueueStateResponse","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>states_by_ready_queue</code> - required <code>object</code>. </li> </ul>"},{"location":"reference/http/kumod/schemas/ReadyQueueStateResponse/#examples","title":"Examples","text":"<pre><code>{\n  \"states_by_ready_queue\": {}\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/RebindV1Request/","title":"RebindV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Describes which messages should be rebound. The criteria apply to the scheduled queue associated with a given message.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>always_flush</code> - optional <code>boolean</code>. If true, make all matched messages immediately eligible for     delivery.  When false, (the default), only messages whose     queue has changed will be made immediately eligible.</p> </li> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>data</code> - required <code>object</code>. The data, a json object with string keys AND values to pass to the     rebind operation</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will log     with an AdminRebind record unless you suppress logging.</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain name to match. If omitted, any routing_domain will match.</p> </li> <li> <p><code>suppress_logging</code> - optional <code>boolean</code>. If true, do not generate AdminRebind delivery logs for matching     messages.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant to match. If omitted, any tenant will match.</p> </li> <li> <p><code>trigger_rebind_event</code> - optional <code>boolean</code>. If true, a <code>rebind</code> event will be triggered and passed each     message and the supplied data.     If false, no event will be triggered and each field in data     will be applied to the msg metadata, overwriting any previous     value for that key.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/RebindV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"always_flush\": false,\n  \"campaign\": \"string\",\n  \"data\": {},\n  \"domain\": \"example.com\",\n  \"reason\": \"Cleaning up a bad send\",\n  \"routing_domain\": \"string\",\n  \"suppress_logging\": false,\n  \"tenant\": \"string\",\n  \"trigger_rebind_event\": false\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/RebindV1Response/","title":"RebindV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with no properties.</p>"},{"location":"reference/http/kumod/schemas/RebindV1Response/#examples","title":"Examples","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/http/kumod/schemas/Recipient/","title":"Recipient","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>email</code> - required <code>string</code> (<code>email</code>). The email address of the recipient</p> </li> <li> <p><code>name</code> - optional nullable <code>string</code>. The optional displayable name of the recipient.     This field will be set as the <code>name</code> field when     processing template expansion.</p> </li> <li> <p><code>substitutions</code> - optional <code>object</code>. When using templating, this is the map of placeholder     name to replacement value that should be used by the     templating engine when processing just this recipient.     Note that <code>name</code> is implicitly set from the <code>name</code>     field, so you do not need to duplicate it here.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/Recipient/#examples","title":"Examples","text":"<pre><code>{\n  \"email\": \"john.smith@mailbox-example.com\",\n  \"name\": \"John Smith\",\n  \"substitutions\": {\n    \"age\": 42,\n    \"gender\": \"male\"\n  }\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SetDiagnosticFilterRequest/","title":"SetDiagnosticFilterRequest","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>filter</code> - required <code>string</code>. The diagnostic filter spec to use</li> </ul>"},{"location":"reference/http/kumod/schemas/SetDiagnosticFilterRequest/#examples","title":"Examples","text":"<pre><code>{\n  \"filter\": \"kumod=trace\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SpoolId/","title":"SpoolId","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Identifies a message within the spool of its host node.</p> <p>This is a string value.</p>"},{"location":"reference/http/kumod/schemas/SpoolId/#examples","title":"Examples","text":"<pre><code>\"d7ef132b5d7711eea8c8000c29c33806\"\n</code></pre>"},{"location":"reference/http/kumod/schemas/SuspendReadyQueueV1ListEntry/","title":"SuspendReadyQueueV1ListEntry","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>duration</code> - required <code>string</code>. how long until this suspension expires and is automatically removed</p> </li> <li> <p><code>expires</code> - required <code>string</code> (<code>date-time</code>). The time at which the suspension will expire</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id for the suspension. Can be used to cancel the suspension.</p> </li> <li> <p><code>name</code> - required <code>string</code>. The name of the ready queue that is suspended</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/SuspendReadyQueueV1ListEntry/#examples","title":"Examples","text":"<pre><code>{\n  \"duration\": \"string\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\",\n  \"name\": \"source_name-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com@smtp_client\",\n  \"reason\": \"pause while working on resolving a block with the destination postmaster\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SuspendReadyQueueV1Request/","title":"SuspendReadyQueueV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>duration</code> - optional nullable <code>string</code>. Specifies how long this suspension remains active.</p> </li> <li> <p><code>expires</code> - optional nullable <code>string</code> (<code>date-time</code>). </p> </li> <li> <p><code>name</code> - required <code>string</code>. The name of the ready queue that should be suspended</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/SuspendReadyQueueV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"duration\": \"string\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"name\": \"source_name-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com@smtp_client\",\n  \"reason\": \"pause while working on resolving a block with the destination postmaster\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SuspendV1CancelRequest/","title":"SuspendV1CancelRequest","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension to cancel</li> </ul>"},{"location":"reference/http/kumod/schemas/SuspendV1CancelRequest/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SuspendV1ListEntry/","title":"SuspendV1ListEntry","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>duration</code> - required <code>string</code>. Specifies how long this suspension remains active.</p> </li> <li> <p><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension. This can be used later to cancel     the suspension.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant name to match. If omitted, any tenant will match.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/SuspendV1ListEntry/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"string\",\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\",\n  \"reason\": \"pause while working on resolving a deliverability issue\",\n  \"tenant\": \"tenant_name\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SuspendV1Request/","title":"SuspendV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>duration</code> - optional nullable <code>string</code>. Specifies how long this suspension remains active.</p> </li> <li> <p><code>expires</code> - optional nullable <code>string</code> (<code>date-time</code>). instead of specifying the duration, you can set an explicit     expiration timestamp</p> </li> <li> <p><code>queue_names</code> - optional array of <code>string</code>. If present, queue_names takes precedence over <code>campaign</code>,     <code>tenant</code>, and <code>domain</code> and specifies the exact set of     scheduled queue names to which the suspension applies.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. The reason for the suspension</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant name to match. If omitted, any tenant will match.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/SuspendV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"campaign_name\",\n  \"domain\": \"example.com\",\n  \"duration\": \"string\",\n  \"expires\": \"1990-12-31T23:59:60Z\",\n  \"queue_names\": [\n    \"campaign_name:tenant_name@example.com\"\n  ],\n  \"reason\": \"pause while working on resolving a block with the destination postmaster\",\n  \"tenant\": \"tenant_name\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/SuspendV1Response/","title":"SuspendV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required <code>string</code> (<code>uuid</code>). The id of the suspension. This can be used later to cancel     the suspension.</li> </ul>"},{"location":"reference/http/kumod/schemas/SuspendV1Response/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"9511a32e-66f8-42aa-b151-ccb176df47d9\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/TemplateDialectWithSchema/","title":"TemplateDialectWithSchema","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This type is an enum with the following allowed values:</p> <ul> <li><code>\"Jinja\"</code></li> <li><code>\"Static\"</code></li> <li><code>\"Handlebars\"</code></li> </ul>"},{"location":"reference/http/kumod/schemas/TemplateDialectWithSchema/#examples","title":"Examples","text":"<pre><code>\"Jinja\"\n</code></pre>"},{"location":"reference/http/kumod/schemas/TraceHeaders/","title":"TraceHeaders","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>header_name</code> - optional <code>string</code>. The name of the supplemental trace header</p> </li> <li> <p><code>include_meta_names</code> - optional array of <code>string</code>. List of meta keys that should be included in the     supplemental header</p> </li> <li> <p><code>received_header</code> - optional <code>boolean</code>. Whether to add a Received: header</p> </li> <li> <p><code>supplemental_header</code> - optional <code>boolean</code>. Whether to add a supplemental trace header to encode     additional metadata</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/TraceHeaders/#examples","title":"Examples","text":"<pre><code>{\n  \"header_name\": \"string\",\n  \"include_meta_names\": [\n    \"string\"\n  ],\n  \"received_header\": false,\n  \"supplemental_header\": false\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/XferCancelV1Request/","title":"XferCancelV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>queue_name</code> - required <code>string</code>. The name of the xfer scheduled queue</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will log     with an AdminRebind record to indicate that it was moved from     its containing queue, and this reason will be included in that record.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/XferCancelV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"queue_name\": \"string\",\n  \"reason\": \"Scaling down\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/XferCancelV1Response/","title":"XferCancelV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with no properties.</p>"},{"location":"reference/http/kumod/schemas/XferCancelV1Response/#examples","title":"Examples","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/http/kumod/schemas/XferProtocol/","title":"XferProtocol","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>target</code> - required <code>string</code> (<code>uri</code>). Expected to be an HTTP url prefix like:     <code>https://host.name:8008</code> <code>http://127.0.0.1:8000</code></li> </ul>"},{"location":"reference/http/kumod/schemas/XferProtocol/#examples","title":"Examples","text":"<pre><code>{\n  \"target\": \"http://127.0.0.1:8000\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/XferResponseV1/","title":"XferResponseV1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>id</code> - required SpoolId. Identifies a message within the spool of its host node.</li> </ul>"},{"location":"reference/http/kumod/schemas/XferResponseV1/#examples","title":"Examples","text":"<pre><code>{\n  \"id\": \"d7ef132b5d7711eea8c8000c29c33806\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/XferV1Request/","title":"XferV1Request","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Describes which messages should be transferred to another kumomta node. The criteria apply to the scheduled queue associated with a given message.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>target</code> - required <code>string</code> (<code>uri</code>). Expected to be an HTTP url prefix like:     <code>https://host.name:8008</code> <code>http://127.0.0.1:8000</code></p> </li> <li> <p><code>campaign</code> - optional nullable <code>string</code>. The campaign name to match. If omitted, any campaign will match.</p> </li> <li> <p><code>domain</code> - optional nullable <code>string</code>. The domain name to match. If omitted, any domain will match.</p> </li> <li> <p><code>queue_names</code> - optional array of <code>string</code>. If present, queue_names takes precedence over <code>campaign</code>,     <code>tenant</code>, and <code>domain</code> and specifies the exact set of     scheduled queue names to which the xfer applies.</p> </li> <li> <p><code>reason</code> - required <code>string</code>. Reason to log in the delivery log. Each matching message will log     with an AdminRebind record to indicate that it was moved from     its containing queue, and this reason will be included in that record.</p> </li> <li> <p><code>routing_domain</code> - optional nullable <code>string</code>. The routing_domain name to match. If omitted, any routing_domain will match.</p> </li> <li> <p><code>tenant</code> - optional nullable <code>string</code>. The tenant to match. If omitted, any tenant will match.</p> </li> </ul>"},{"location":"reference/http/kumod/schemas/XferV1Request/#examples","title":"Examples","text":"<pre><code>{\n  \"campaign\": \"string\",\n  \"domain\": \"example.com\",\n  \"queue_names\": [\n    \"string\"\n  ],\n  \"reason\": \"Scaling down\",\n  \"routing_domain\": \"string\",\n  \"target\": \"http://127.0.0.1:8000\",\n  \"tenant\": \"string\"\n}\n</code></pre>"},{"location":"reference/http/kumod/schemas/XferV1Response/","title":"XferV1Response","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with no properties.</p>"},{"location":"reference/http/kumod/schemas/XferV1Response/#examples","title":"Examples","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/http/proxy-server/","title":"proxy-server HTTP API","text":"<ul> <li>POST /api/admin/bump-config-epoch</li> <li>GET /api/admin/memory/stats</li> <li>POST /api/admin/set_diagnostic_log_filter/v1</li> <li>GET /api/machine-info</li> <li>GET /metrics.json</li> <li>GET /metrics</li> <li>GET /proxy/status</li> <li>schemas</li> </ul>"},{"location":"reference/http/proxy-server/api_admin_bump_config_epoch_post/","title":"POST /api/admin/bump-config-epoch","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Allows the system operator to trigger a configuration epoch bump, which causes various configs that are using the Epoch strategy to be re-evaluated by triggering the appropriate callbacks.</p>","tags":["config"]},{"location":"reference/http/proxy-server/api_admin_bump_config_epoch_post/#responses","title":"Responses","text":"","tags":["config"]},{"location":"reference/http/proxy-server/api_admin_bump_config_epoch_post/#status-200","title":"Status 200","text":"<p>bump successful</p>","tags":["config"]},{"location":"reference/http/proxy-server/api_admin_memory_stats_get/","title":"GET /api/admin/memory/stats","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns information about the system memory usage in an unstructured human readable format.  The output is not machine parseable and may change without notice between versions of kumomta.</p>","tags":["memory"]},{"location":"reference/http/proxy-server/api_admin_memory_stats_get/#responses","title":"Responses","text":"","tags":["memory"]},{"location":"reference/http/proxy-server/api_admin_memory_stats_get/#status-200","title":"Status 200","text":"<p>stats were returned</p>","tags":["memory"]},{"location":"reference/http/proxy-server/api_admin_set_diagnostic_log_filter_v1_post/","title":"POST /api/admin/set_diagnostic_log_filter/v1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Changes the diagnostic log filter dynamically. See kumo.set_diagnostic_log_filter for more information on diagnostic log filters.</p> <p>This API endpoint is used by the kcli set-log-filter command.</p>","tags":["logging"]},{"location":"reference/http/proxy-server/api_admin_set_diagnostic_log_filter_v1_post/#request-body","title":"Request Body","text":"<p>The request body is required.</p> <p>The <code>Content-Type</code> header must be set to <code>application/json</code>.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>filter</code> - required <code>string</code>. The diagnostic filter spec to use</li> </ul>","tags":["logging"]},{"location":"reference/http/proxy-server/api_admin_set_diagnostic_log_filter_v1_post/#examples","title":"Examples","text":"<pre><code>{\n  \"filter\": \"kumod=trace\"\n}\n</code></pre>","tags":["logging"]},{"location":"reference/http/proxy-server/api_admin_set_diagnostic_log_filter_v1_post/#responses","title":"Responses","text":"","tags":["logging"]},{"location":"reference/http/proxy-server/api_admin_set_diagnostic_log_filter_v1_post/#status-200","title":"Status 200","text":"<p>Diagnostic level set successfully</p>","tags":["logging"]},{"location":"reference/http/proxy-server/api_machine_info_get/","title":"GET /api/machine-info","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns information identifying this instance</p>","tags":["debugging"]},{"location":"reference/http/proxy-server/api_machine_info_get/#responses","title":"Responses","text":"","tags":["debugging"]},{"location":"reference/http/proxy-server/api_machine_info_get/#status-200","title":"Status 200","text":"<p>Machine information</p> <p><code>Content-Type: application/json</code></p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>container_runtime</code> - optional nullable <code>string</code>. If we detected that we're running in a container, the name     of the container runtime</p> </li> <li> <p><code>cpu_brand</code> - required <code>string</code>. Identifies the CPU.  If you have a mixture of different CPUs,     this will be a comma separated list of the different CPUs</p> </li> <li> <p><code>distribution</code> - required <code>string</code>. The OS distribution</p> </li> <li> <p><code>fingerprint</code> - required <code>string</code>. Additional metadata hash(es) that can identify the running machine.     For example, when running in AWS, the instance-id will be     included.</p> </li> <li> <p><code>hostname</code> - required <code>string</code>. The hostname of the system, as reported by <code>gethostname(2)</code></p> </li> <li> <p><code>kernel_version</code> - optional nullable <code>string</code>. The kernel version</p> </li> <li> <p><code>mac_address</code> - required <code>string</code>. The MAC address of the primary, non-loopback, network interface</p> </li> <li> <p><code>node_id</code> - required <code>string</code>. The NodeID of the system</p> </li> <li> <p><code>num_cores</code> - required <code>integer</code>. The number of available CPUs as reported by     https://docs.rs/num_cpus/latest/num_cpus/fn.get.html</p> </li> <li> <p><code>online_since</code> - required <code>string</code> (<code>date-time</code>). The date/time at which the process was last started</p> </li> <li> <p><code>os_version</code> - required <code>string</code>. The OS version (which often includes the distribution)</p> </li> <li> <p><code>platform</code> - required <code>string</code>. Identifies the running platform</p> </li> <li> <p><code>process_kind</code> - required <code>string</code>. Which process is running. eg: <code>kumod</code> vs <code>tsa-daemon</code> vs. <code>proxy-server</code>.</p> </li> <li> <p><code>total_memory_bytes</code> - required <code>integer</code> (<code>u-int64</code>). Total physical memory installed in the instance</p> </li> <li> <p><code>version</code> - required <code>string</code>. The version of KumoMTA that is running</p> </li> </ul>","tags":["debugging"]},{"location":"reference/http/proxy-server/api_machine_info_get/#examples","title":"Examples","text":"<pre><code>{\n  \"container_runtime\": \"string\",\n  \"cpu_brand\": \"Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz\",\n  \"distribution\": \"ubuntu\",\n  \"fingerprint\": \"aws_instance_id=i-09aebefac97cf0000,machine_uid=ec22130d1de33cf52413457ac040000\",\n  \"hostname\": \"mta1.example.com\",\n  \"kernel_version\": \"6.8.0-1016-aws\",\n  \"mac_address\": \"02:02:02:02:02:02\",\n  \"node_id\": \"9745bb48-14d7-48f2-a1fb-7df8d5844217\",\n  \"num_cores\": 64,\n  \"online_since\": \"1990-12-31T23:59:60Z\",\n  \"os_version\": \"Linux (Ubuntu 24.04)\",\n  \"platform\": \"linux/x86_64\",\n  \"process_kind\": \"kumod\",\n  \"total_memory_bytes\": 1003929600,\n  \"version\": \"2026.02.24-2d1a3174\"\n}\n</code></pre>","tags":["debugging"]},{"location":"reference/http/proxy-server/metrics.json_get/","title":"GET /metrics.json","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns the current set of metrics in a json representation. This is easier to consume than the Prometheus Exposition format, but is more resource intensive to produce and parse when the number of metrics is large, such as for a busy server.</p> <p>Note</p> <p>Metrics generally represent data at the current point in time, to be consumed by an external system (such as Prometheus) which then in turn can build time series data around those metrics.</p> <p>In addition, in order to avoid unbounded RAM usage for systems with many queues, a number of queue- or service-specific metrics will be automatically pruned away when the corresponding queue idles out for a period of time.</p> <p>In the default configuration, access to this endpoint requires Trusted IP authentication.  See the Authorization documentation for more information on adjusting ACLs.</p> <p>See also metrics.</p>","tags":[]},{"location":"reference/http/proxy-server/metrics.json_get/#metric-documentation","title":"Metric Documentation","text":"<ul> <li>Metrics exported by kumod</li> </ul>","tags":[]},{"location":"reference/http/proxy-server/metrics.json_get/#example-data","title":"Example Data","text":"<p>Here's an example of the shape of the data.  The precise set of counters will vary as we continue to enhance KumoMTA:</p> <pre><code>{\n  \"connection_count\": {\n    \"help\": \"number of active connections\",\n    \"type\": \"gauge\",\n    \"value\": {\n      \"service\": {\n        \"esmtp_listener\": 0.0,\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"scheduled_count\": {\n    \"help\": \"number of messages in the scheduled queue\",\n    \"type\": \"gauge\",\n    \"value\": {\n      \"queue\": {\n        \"example.com\": 0.0\n      }\n    }\n  },\n  \"lua_count\": {\n    \"help\": \"the number of lua contexts currently alive\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"lua_load_count\": {\n    \"help\": \"how many times the policy lua script has been loaded into a new context\",\n    \"type\": \"counter\",\n    \"value\": 1.0\n  },\n  \"lua_spare_count\": {\n    \"help\": \"the number of lua contexts available for reuse in the pool\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"memory_limit\": {\n    \"help\": \"soft memory limit measured in bytes\",\n    \"type\": \"gauge\",\n    \"value\": 101234377728.0\n  },\n  \"memory_usage\": {\n    \"help\": \"number of bytes of used memory\",\n    \"type\": \"gauge\",\n    \"value\": 185683968.0\n  },\n  \"message_count\": {\n    \"help\": \"total number of Message objects\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"message_data_resident_count\": {\n    \"help\": \"total number of Message objects with body data loaded\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"message_meta_resident_count\": {\n    \"help\": \"total number of Message objects with metadata loaded\",\n    \"type\": \"gauge\",\n    \"value\": 1.0\n  },\n  \"ready_count\": {\n    \"help\": \"number of messages in the ready queue\",\n    \"type\": \"gauge\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client:source1-&gt;loopback.dummy-mx.example.com\": 46.0,\n        \"smtp_client:source2-&gt;loopback.dummy-mx.example.com\": 152.0,\n      }\n    }\n  },\n  \"total_connection_count\": {\n    \"help\": \"total number of active connections ever made\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"total_messages_delivered\": {\n    \"help\": \"total number of messages ever delivered\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"total_messages_fail\": {\n    \"help\": \"total number of message delivery attempts that permanently failed\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  },\n  \"total_messages_transfail\": {\n    \"help\": \"total number of message delivery attempts that transiently failed\",\n    \"type\": \"counter\",\n    \"value\": {\n      \"service\": {\n        \"smtp_client\": 0.0,\n        \"smtp_client:source2-&gt;\": 0.0\n      }\n    }\n  }\n}\n</code></pre>","tags":[]},{"location":"reference/http/proxy-server/metrics.json_get/#responses","title":"Responses","text":"","tags":[]},{"location":"reference/http/proxy-server/metrics.json_get/#status-200","title":"Status 200","text":"<p><code>Content-Type: application/json</code></p>","tags":[]},{"location":"reference/http/proxy-server/metrics_get/","title":"GET /metrics","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Returns the current set of metrics in Prometheus Text Exposition Format.</p> <p>Note</p> <p>Metrics generally represent data at the current point in time, to be consumed by an external system (such as Prometheus) which then in turn can build time series data around those metrics.</p> <p>In addition, in order to avoid unbounded RAM usage for systems with many queues, a number of queue- or service-specific metrics will be automatically pruned away when the corresponding queue idles out for a period of time.</p> <p>In the default configuration, access to this endpoint requires Trusted IP authentication.  See the Authorization documentation for more information on adjusting ACLs.</p> <p>See also metrics.json.</p>","tags":[]},{"location":"reference/http/proxy-server/metrics_get/#metric-documentation","title":"Metric Documentation","text":"<ul> <li>Metrics exported by kumod</li> </ul>","tags":[]},{"location":"reference/http/proxy-server/metrics_get/#example-data","title":"Example Data","text":"<p>Here's an example of the shape of the data.  The precise set of counters will vary as we continue to enhance KumoMTA.</p> <p>You can see the current list by querying the endpoint with no arguments:</p> <pre><code>$ curl http://localhost:8000/metrics\n</code></pre> <pre><code># HELP connection_count number of active connections\n# TYPE connection_count gauge\nconnection_count{service=\"esmtp_listener\"} 0\n# HELP disk_free_bytes number of available bytes in a monitored location\n# TYPE disk_free_bytes gauge\ndisk_free_bytes{name=\"data spool\"} 15658725376\ndisk_free_bytes{name=\"log dir /var/log/kumomta\"} 15658725376\ndisk_free_bytes{name=\"meta spool\"} 15658725376\n# HELP disk_free_inodes number of available inodes in a monitored location\n# TYPE disk_free_inodes gauge\ndisk_free_inodes{name=\"data spool\"} 3056405\ndisk_free_inodes{name=\"log dir /var/log/kumomta\"} 3056405\ndisk_free_inodes{name=\"meta spool\"} 3056405\n# HELP disk_free_inodes_percent percentage of available inodes in a monitored location\n# TYPE disk_free_inodes_percent gauge\ndisk_free_inodes_percent{name=\"data spool\"} 94\ndisk_free_inodes_percent{name=\"log dir /var/log/kumomta\"} 94\ndisk_free_inodes_percent{name=\"meta spool\"} 94\n# HELP disk_free_percent percentage of available bytes in a monitored location\n# TYPE disk_free_percent gauge\ndisk_free_percent{name=\"data spool\"} 60\ndisk_free_percent{name=\"log dir /var/log/kumomta\"} 60\ndisk_free_percent{name=\"meta spool\"} 60\n# HELP log_submit_latency latency of log event submission operations\n# TYPE log_submit_latency histogram\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.005\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.01\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.025\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.05\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.1\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.25\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"0.5\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"1\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"2.5\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"5\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"10\"} 0\nlog_submit_latency_bucket{logger=\"dir-/var/log/kumomta\",le=\"+Inf\"} 0\nlog_submit_latency_sum{logger=\"dir-/var/log/kumomta\"} 0\nlog_submit_latency_count{logger=\"dir-/var/log/kumomta\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.005\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.01\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.025\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.05\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.1\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.25\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"0.5\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"1\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"2.5\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"5\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"10\"} 0\nlog_submit_latency_bucket{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\",le=\"+Inf\"} 0\nlog_submit_latency_sum{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\"} 0\nlog_submit_latency_count{logger=\"hook-http://127.0.0.1:8008.tsa.kumomta\"} 0\n# HELP lua_count the number of lua contexts currently alive\n# TYPE lua_count gauge\nlua_count 1\n# HELP lua_event_latency how long a given lua event callback took\n# TYPE lua_event_latency histogram\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.005\"} 0\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.01\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.025\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.05\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.1\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.25\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"0.5\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"1\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"2.5\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"5\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"10\"} 3\nlua_event_latency_bucket{event=\"context-creation\",le=\"+Inf\"} 3\nlua_event_latency_sum{event=\"context-creation\"} 0.017253747\nlua_event_latency_count{event=\"context-creation\"} 3\nlua_event_latency_bucket{event=\"init\",le=\"0.005\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.01\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.025\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.05\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.1\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.25\"} 0\nlua_event_latency_bucket{event=\"init\",le=\"0.5\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"1\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"2.5\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"5\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"10\"} 1\nlua_event_latency_bucket{event=\"init\",le=\"+Inf\"} 1\nlua_event_latency_sum{event=\"init\"} 0.442427973\nlua_event_latency_count{event=\"init\"} 1\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.005\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.01\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.025\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.05\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.1\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.25\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"0.5\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"1\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"2.5\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"5\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"10\"} 0\nlua_event_latency_bucket{event=\"kumo.tsa.suspension.subscriber\",le=\"+Inf\"} 0\nlua_event_latency_sum{event=\"kumo.tsa.suspension.subscriber\"} 0\nlua_event_latency_count{event=\"kumo.tsa.suspension.subscriber\"} 0\n# HELP lua_load_count how many times the policy lua script has been loaded into a new context\n# TYPE lua_load_count counter\nlua_load_count 3\n# HELP lua_spare_count the number of lua contexts available for reuse in the pool\n# TYPE lua_spare_count gauge\nlua_spare_count 0\n# HELP memory_limit soft memory limit measured in bytes\n# TYPE memory_limit gauge\nmemory_limit 1538067456\n# HELP memory_usage number of bytes of used memory\n# TYPE memory_usage gauge\nmemory_usage 320516096\n# HELP thread_pool_parked number of parked(idle) threads in a thread pool\n# TYPE thread_pool_parked gauge\nthread_pool_parked{pool=\"localset\"} 0\nthread_pool_parked{pool=\"logging\"} 1\n# HELP thread_pool_size number of threads in a thread pool\n# TYPE thread_pool_size gauge\nthread_pool_size{pool=\"localset\"} 1\nthread_pool_size{pool=\"logging\"} 1\n# HELP tokio_budget_forced_yield_count Returns the number of times that tasks have been forced to yield back to the scheduler after exhausting their task budgets.\n# TYPE tokio_budget_forced_yield_count counter\ntokio_budget_forced_yield_count 0\n# HELP tokio_elapsed Total amount of time elapsed since observing runtime metrics.\n# TYPE tokio_elapsed counter\ntokio_elapsed 1057.312763632\n# HELP tokio_injection_queue_depth The number of tasks currently scheduled in the runtime\u2019s injection queue.\n# TYPE tokio_injection_queue_depth gauge\ntokio_injection_queue_depth 0\n# HELP tokio_io_driver_ready_count Returns the number of ready events processed by the runtime\u2019s I/O driver.\n# TYPE tokio_io_driver_ready_count counter\ntokio_io_driver_ready_count 0\n# HELP tokio_num_remote_schedules The number of tasks scheduled from outside of the runtime.\n# TYPE tokio_num_remote_schedules counter\ntokio_num_remote_schedules 0\n# HELP tokio_total_busy_duration The amount of time worker threads were busy.\n# TYPE tokio_total_busy_duration counter\ntokio_total_busy_duration 0\n# HELP tokio_total_local_queue_depth The total number of tasks currently scheduled in workers\u2019 local queues.\n# TYPE tokio_total_local_queue_depth gauge\ntokio_total_local_queue_depth 0\n# HELP tokio_total_local_schedule_count The number of tasks scheduled from worker threads.\n# TYPE tokio_total_local_schedule_count counter\ntokio_total_local_schedule_count 0\n# HELP tokio_total_noop_count The number of times worker threads unparked but performed no work before parking again.\n# TYPE tokio_total_noop_count counter\ntokio_total_noop_count 0\n# HELP tokio_total_overflow_count The number of times worker threads saturated their local queues.\n# TYPE tokio_total_overflow_count counter\ntokio_total_overflow_count 0\n# HELP tokio_total_park_count The number of times worker threads parked.\n# TYPE tokio_total_park_count counter\ntokio_total_park_count 0\n# HELP tokio_total_polls_count The number of tasks that have been polled across all worker threads.\n# TYPE tokio_total_polls_count counter\ntokio_total_polls_count 0\n# HELP tokio_total_steal_count The number of tasks worker threads stole from another worker thread.\n# TYPE tokio_total_steal_count counter\ntokio_total_steal_count 0\n# HELP tokio_total_steal_operations The number of times worker threads stole tasks from another worker thread.\n# TYPE tokio_total_steal_operations counter\ntokio_total_steal_operations 0\n# HELP tokio_workers_count The number of worker threads used by the runtime.\n# TYPE tokio_workers_count gauge\ntokio_workers_count 1\n# HELP total_connections_denied total number of connections rejected due to load shedding or concurrency limits\n# TYPE total_connections_denied counter\ntotal_connections_denied{service=\"esmtp_listener\"} 0\n</code></pre>","tags":[]},{"location":"reference/http/proxy-server/metrics_get/#responses","title":"Responses","text":"","tags":[]},{"location":"reference/http/proxy-server/metrics_get/#status-200","title":"Status 200","text":"<p><code>Content-Type: text/plain</code></p>","tags":[]},{"location":"reference/http/proxy-server/proxy_status_get/","title":"GET /proxy/status","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>Simple health check endpoint for the proxy. Returns basic status information.</p>","tags":["status"]},{"location":"reference/http/proxy-server/proxy_status_get/#responses","title":"Responses","text":"","tags":["status"]},{"location":"reference/http/proxy-server/proxy_status_get/#status-200","title":"Status 200","text":"<p>Proxy is healthy</p> <p><code>Content-Type: text/plain</code></p> <p>This is a string value.</p>","tags":["status"]},{"location":"reference/http/proxy-server/proxy_status_get/#examples","title":"Examples","text":"<pre><code>\"string\"\n</code></pre>","tags":["status"]},{"location":"reference/http/proxy-server/schemas/","title":"API Types for proxy-server service","text":"<p>The following types are defined for the proxy-server service:</p>"},{"location":"reference/http/proxy-server/schemas/MachineInfoV1/","title":"MachineInfoV1","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li> <p><code>container_runtime</code> - optional nullable <code>string</code>. If we detected that we're running in a container, the name     of the container runtime</p> </li> <li> <p><code>cpu_brand</code> - required <code>string</code>. Identifies the CPU.  If you have a mixture of different CPUs,     this will be a comma separated list of the different CPUs</p> </li> <li> <p><code>distribution</code> - required <code>string</code>. The OS distribution</p> </li> <li> <p><code>fingerprint</code> - required <code>string</code>. Additional metadata hash(es) that can identify the running machine.     For example, when running in AWS, the instance-id will be     included.</p> </li> <li> <p><code>hostname</code> - required <code>string</code>. The hostname of the system, as reported by <code>gethostname(2)</code></p> </li> <li> <p><code>kernel_version</code> - optional nullable <code>string</code>. The kernel version</p> </li> <li> <p><code>mac_address</code> - required <code>string</code>. The MAC address of the primary, non-loopback, network interface</p> </li> <li> <p><code>node_id</code> - required <code>string</code>. The NodeID of the system</p> </li> <li> <p><code>num_cores</code> - required <code>integer</code>. The number of available CPUs as reported by     https://docs.rs/num_cpus/latest/num_cpus/fn.get.html</p> </li> <li> <p><code>online_since</code> - required <code>string</code> (<code>date-time</code>). The date/time at which the process was last started</p> </li> <li> <p><code>os_version</code> - required <code>string</code>. The OS version (which often includes the distribution)</p> </li> <li> <p><code>platform</code> - required <code>string</code>. Identifies the running platform</p> </li> <li> <p><code>process_kind</code> - required <code>string</code>. Which process is running. eg: <code>kumod</code> vs <code>tsa-daemon</code> vs. <code>proxy-server</code>.</p> </li> <li> <p><code>total_memory_bytes</code> - required <code>integer</code> (<code>u-int64</code>). Total physical memory installed in the instance</p> </li> <li> <p><code>version</code> - required <code>string</code>. The version of KumoMTA that is running</p> </li> </ul>"},{"location":"reference/http/proxy-server/schemas/MachineInfoV1/#examples","title":"Examples","text":"<pre><code>{\n  \"container_runtime\": \"string\",\n  \"cpu_brand\": \"Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz\",\n  \"distribution\": \"ubuntu\",\n  \"fingerprint\": \"aws_instance_id=i-09aebefac97cf0000,machine_uid=ec22130d1de33cf52413457ac040000\",\n  \"hostname\": \"mta1.example.com\",\n  \"kernel_version\": \"6.8.0-1016-aws\",\n  \"mac_address\": \"02:02:02:02:02:02\",\n  \"node_id\": \"9745bb48-14d7-48f2-a1fb-7df8d5844217\",\n  \"num_cores\": 64,\n  \"online_since\": \"1990-12-31T23:59:60Z\",\n  \"os_version\": \"Linux (Ubuntu 24.04)\",\n  \"platform\": \"linux/x86_64\",\n  \"process_kind\": \"kumod\",\n  \"total_memory_bytes\": 1003929600,\n  \"version\": \"2026.02.24-2d1a3174\"\n}\n</code></pre>"},{"location":"reference/http/proxy-server/schemas/SetDiagnosticFilterRequest/","title":"SetDiagnosticFilterRequest","text":"<p>Info</p> <p>This page was generated by extracting information from a JSON Schema data file for the API.  It may be missing some information, or otherwise suggest approximate or placeholder values based on information in the schema file; this is due to limitations on how that data is extracted from the underlying Rust code and into the JSON Schema, and then again from there and into these docs.</p> <p>This is an object value, with the following properties:</p> <ul> <li><code>filter</code> - required <code>string</code>. The diagnostic filter spec to use</li> </ul>"},{"location":"reference/http/proxy-server/schemas/SetDiagnosticFilterRequest/#examples","title":"Examples","text":"<pre><code>{\n  \"filter\": \"kumod=trace\"\n}\n</code></pre>"},{"location":"reference/kcli/","title":"Command-Line Help for <code>kcli</code>","text":"<p>This document contains the help content for the <code>kcli</code> command-line program.</p>"},{"location":"reference/kcli/#kcli","title":"<code>kcli</code>","text":"<p>KumoMTA CLI.</p> <p>Interacts with a KumoMTA instance via its HTTP API endpoint. To use it, you must be running an HTTP listener.</p> <p>The default is to assume that KumoMTA is running a listener at http://127.0.0.1:8000 (which is in the default configuration), but otherwise you can override this either via the --endpoint parameter or KUMO_KCLI_ENDPOINT environment variable.</p> <p>Full docs available at: https://docs.kumomta.com</p> <p>Usage: <code>kcli [OPTIONS] &lt;COMMAND&gt;</code></p>"},{"location":"reference/kcli/#subcommands","title":"Subcommands:","text":"<ul> <li> <p><code>bounce</code> \u2014 Administratively bounce messages in matching queues</p> </li> <li> <p><code>bounce-list</code> \u2014 Returns list of current administrative bounce rules</p> </li> <li> <p><code>bounce-cancel</code> \u2014 Cancels an admin bounce entry</p> </li> <li> <p><code>rebind</code> \u2014 Rebind messages from matching queues into different queue(s)</p> </li> <li> <p><code>suspend</code> \u2014 Administratively suspend messages in matching queues</p> </li> <li> <p><code>suspend-list</code> \u2014 Returns list of current administrative suspend rules</p> </li> <li> <p><code>suspend-cancel</code> \u2014 Cancels an admin suspend entry</p> </li> <li> <p><code>suspend-ready-q</code> \u2014 Administratively suspend the ready queue for an egress path</p> </li> <li> <p><code>suspend-ready-q-list</code> \u2014 Returns list of current ready queue/egress path suspend rules</p> </li> <li> <p><code>suspend-ready-q-cancel</code> \u2014 Cancels an admin suspend entry for a ready queue/egress path</p> </li> <li> <p><code>set-log-filter</code> \u2014 Changes the diagnostic log filter</p> </li> <li> <p><code>inspect-message</code> \u2014 Returns information about a message in the spool</p> </li> <li> <p><code>inspect-sched-q</code> \u2014 Returns information about a scheduled queue</p> </li> <li> <p><code>provider-summary</code> \u2014 Prints a summary of the aggregate state of the queues from the perspective of the provider or destination site</p> </li> <li> <p><code>queue-summary</code> \u2014 Prints a summary of the state of the queues, for a human to read</p> </li> <li> <p><code>trace-smtp-client</code> \u2014 Trace outgoing sessions made by the SMTP service</p> </li> <li> <p><code>trace-smtp-server</code> \u2014 Trace incoming connections made to the SMTP service</p> </li> <li> <p><code>top</code> \u2014 Continually update and show what's happening in kumod</p> </li> <li> <p><code>xfer</code> \u2014 Transfer messages from matching queues to an alternative kumomta node</p> </li> <li> <p><code>xfer-cancel</code> \u2014 Cancels a message transfer that was initiated via the xfer subcommand.  You specify the name of the xfer queue associated with the transfer and matching messages will be taken out of that queue and returned to their originating queue</p> </li> </ul>"},{"location":"reference/kcli/#options","title":"Options","text":"<ul> <li><code>--endpoint &lt;ENDPOINT&gt;</code> \u2014 URL to reach the KumoMTA HTTP API. You may set KUMO_KCLI_ENDPOINT in the environment to specify this without explicitly using --endpoint. If not specified, http://127.0.0.1:8000 will be assumed</li> </ul>"},{"location":"reference/kcli/bounce-cancel/","title":"kcli bounce-cancel","text":"<p>Cancels an admin bounce entry.</p> <p>Cancelling the entry prevents it from matching new messages. It cannot retroactively un-bounce messages that it already matched and bounced.</p> <p>Usage: <code>kcli bounce-cancel --id &lt;ID&gt;</code></p>","tags":["bounce"]},{"location":"reference/kcli/bounce-cancel/#options","title":"Options","text":"<ul> <li><code>--id &lt;ID&gt;</code> \u2014 The id field of the bounce entry that you wish to cancel</li> </ul>","tags":["bounce"]},{"location":"reference/kcli/bounce-list/","title":"kcli bounce-list","text":"<p>Returns list of current administrative bounce rules.</p> <p>Returns the list of un-expired admin bounces that are currently in effect on the target instance.</p> <p>Usage: <code>kcli bounce-list [OPTIONS]</code></p>","tags":["bounce"]},{"location":"reference/kcli/bounce-list/#options","title":"Options","text":"<ul> <li><code>--json</code> \u2014 Instead of showing the human readable tabulated output, return the underlying json data</li> </ul>","tags":["bounce"]},{"location":"reference/kcli/bounce/","title":"kcli bounce","text":"<p>Administratively bounce messages in matching queues.</p> <p>Each individual message that is bounced will generate a log record capturing the event and then be removed from the spool.</p> <p>Make sure that you mean it, as there is no going back!</p> <p>The bounce will be applied immediately to queued messages, (asynchronously with respect to the command!) and the directive will remain in effect for the duration specified, causing newly received messages or messages that were in a transient state at the time the directive was received, to also be bounced as they are placed back into the matching queue(s).</p> <p>The totals printed by this command are often under-reported due to the asynchronous nature of the action.</p> <p>Usage: <code>kcli bounce [OPTIONS] --reason &lt;REASON&gt; &lt;--domain &lt;DOMAIN&gt;|--routing-domain &lt;ROUTING_DOMAIN&gt;|--campaign &lt;CAMPAIGN&gt;|--tenant &lt;TENANT&gt;|--everything|--queue &lt;QUEUE&gt;&gt;</code></p>","tags":["bounce"]},{"location":"reference/kcli/bounce/#options","title":"Options","text":"<ul> <li> <p><code>--domain &lt;DOMAIN&gt;</code> \u2014 The domain name to match. If omitted, any domains will match!</p> </li> <li> <p><code>--routing-domain &lt;ROUTING_DOMAIN&gt;</code> \u2014 The routing_domain name to match. If omitted, any routing domain will match!</p> </li> <li> <p><code>--campaign &lt;CAMPAIGN&gt;</code> \u2014 The campaign name to match. If omitted, any campaigns will match!</p> </li> <li> <p><code>--tenant &lt;TENANT&gt;</code> \u2014 The tenant name to match. If omitted, any tenant will match!</p> </li> <li> <p><code>--queue &lt;QUEUE&gt;</code> \u2014 Bounce specific scheduled queue names using their exact queue name(s). Can be specified multiple times</p> </li> <li> <p><code>--reason &lt;REASON&gt;</code> \u2014 The reason to log in the delivery logs (each matching message will bounce with an AdminBounce record) as well as in the list of bounces</p> </li> <li> <p><code>--everything</code> \u2014 Purge all queues</p> </li> <li> <p><code>--suppress-logging</code> \u2014 Do not generate AdminBounce delivery logs</p> </li> <li> <p><code>--duration &lt;DURATION&gt;</code> \u2014 The duration over which matching messages will continue to bounce. The default is '5m'</p> </li> </ul>","tags":["bounce"]},{"location":"reference/kcli/inspect-message/","title":"kcli inspect-message","text":"<p>Returns information about a message in the spool</p> <p>Usage: <code>kcli inspect-message [OPTIONS] &lt;ID&gt;</code></p>","tags":["message","debugging"]},{"location":"reference/kcli/inspect-message/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;ID&gt;</code></li> </ul>","tags":["message","debugging"]},{"location":"reference/kcli/inspect-message/#options","title":"Options","text":"<ul> <li><code>--want-body</code></li> </ul>","tags":["message","debugging"]},{"location":"reference/kcli/inspect-sched-q/","title":"kcli inspect-sched-q","text":"<p>Returns information about a scheduled queue.</p> <p>Part of the information is a sample of the messages contained within that queue.</p> <p>Depending on the configured queue strategy, it may not be possible to sample messages from the queue. At the time of writing, the server side can only provide message information if the strategy is set to \"SingletonTimerWheel\" (the default).</p> <p>Usage: <code>kcli inspect-sched-q [OPTIONS] &lt;QUEUE_NAME&gt;</code></p>","tags":["debugging"]},{"location":"reference/kcli/inspect-sched-q/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;QUEUE_NAME&gt;</code> \u2014 The name of the queue that you want to query</li> </ul>","tags":["debugging"]},{"location":"reference/kcli/inspect-sched-q/#options","title":"Options","text":"<ul> <li> <p><code>--want-body</code> \u2014 Whether to include the message body information in the results. This can be expensive, especially with large or no limits</p> </li> <li> <p><code>--limit &lt;LIMIT&gt;</code> \u2014 How many messages to include in the sample. The default is 5 messages. The messages are an unspecified subset of the messages in the queue and likely do NOT indicate which message(s) will be next due for delivery</p> <p>Default value: <code>5</code></p> </li> <li> <p><code>--no-limit</code> \u2014 Instead of guessing at a limit, run with no limit on the number of messages returned.  This can be expensive, especially if <code>--want-body</code> is also enabled</p> </li> </ul>","tags":["debugging"]},{"location":"reference/kcli/provider-summary/","title":"kcli provider-summary","text":"<p>Prints a summary of the aggregate state of the queues from the perspective of the provider or destination site.</p> <p>Note that this output format is subject to change and is not suitable for a machine to parse. It is expressly unstable and you must not depend upon it in automation.</p> <p>The data behind this output is pulled from the metrics endpoint, which is machine readable.</p> <p>The default output mode is to show the total volume of traffic grouped by the provider, or, if not applicable provider matching rules were defined on the server, the site name that is derived from the MX records for a domain.</p> <p>The data is shown ordered by descending volume, where volume is the sum of the delivered, failed, transiently failed and queued message counts.</p> <p>The --by-pool flag will further sub-divide the display by the egress pool.</p> <p>The column labels have the following meanings:</p> <p>PROVIDER - either the provider (if explicitly set through the config on the server), or the site name for the underlying domain.</p> <p>POOL     - (when --by-pool is used) the name of the egress pool</p> <p>D        - the total number of delivered messages</p> <p>T        - the total number of transiently failed messages</p> <p>F        - the total number of failed/bounced messages</p> <p>C        - the current number of open connections</p> <p>Q        - the total number of ready and scheduled messages in queue</p> <p>DOMAINS  - (when --show-domains is used) a list of domains that correspond to rows that do not have an explicitly configured provider.</p> <p>Usage: <code>kcli provider-summary [OPTIONS]</code></p>","tags":["ops"]},{"location":"reference/kcli/provider-summary/#options","title":"Options","text":"<ul> <li> <p><code>--by-pool</code> \u2014 Include a POOL column in the output, and break down the volume on a per-pool basis</p> </li> <li> <p><code>--show-domains</code> \u2014 For rows that were not matched on the server by provider rules we will normally show a site-name in the place of the PROVIDER column.</p> <p>When --show-domains is enabled, an additional DOMAINS column will be added to the output to hold a list of domains which correspond to that site-name.</p> <p>This option is only capable of filling in the list of domains if any of those domains have delayed messages residing in their respective scheduled queues at the time that this command was invoked.</p> </li> <li> <p><code>--limit &lt;LIMIT&gt;</code> \u2014 Limit results to LIMIT results</p> </li> </ul>","tags":["ops"]},{"location":"reference/kcli/queue-summary/","title":"kcli queue-summary","text":"<p>Prints a summary of the state of the queues, for a human to read.</p> <p>Note that this output format is subject to change and is not suitable for a machine to parse. It is expressly unstable and you must not depend upon it in automation.</p> <p>The data behind this output is pulled from the metrics endpoint, which is machine readable.</p> <p>The output is presented in two sections:</p> <ol> <li> <p>The ready queues</p> </li> <li> <p>The scheduled queues</p> </li> </ol> <p>The ready queue data is presented in columns that are mostly self explanatory, but the numeric counts are labelled with single character labels:</p> <p>D - the total number of delivered messages</p> <p>T - the total number of transiently failed messages</p> <p>C - the number of open connections</p> <p>Q - the number of ready messages in the queue</p> <p>Note that the ready queue counter values reset whenever the ready queue is reaped, which occurs within a few minutes of the ready queue being idle, so those numbers are only useful to get a sense of recent/current activity. Accurate accounting must be performed using the delivery logs and not via this utility.</p> <p>The scheduled queue data is presented in two columns; the queue name and the number of messages in that queue.</p> <p>Usage: <code>kcli queue-summary [OPTIONS]</code></p>","tags":["ops"]},{"location":"reference/kcli/queue-summary/#options","title":"Options","text":"<ul> <li> <p><code>--limit &lt;LIMIT&gt;</code> \u2014 Limit results to LIMIT results</p> </li> <li> <p><code>--by-volume</code> \u2014 Instead of ordering by name, order by volume, descending</p> </li> <li> <p><code>--domain &lt;DOMAIN&gt;</code> \u2014 Filter queues to those associated with a DNS domain</p> </li> </ul>","tags":["ops"]},{"location":"reference/kcli/rebind/","title":"kcli rebind","text":"<p>Rebind messages from matching queues into different queue(s).</p> <p>Rebinding works first by selecting the set of scheduled queues based on matching criteria that you specify via the <code>--domain</code>, <code>--routing-domain</code>, <code>--campaign</code>, <code>--tenant</code> and/or <code>--everything</code> options.</p> <p>Each matching queue has its messages removed and assessed by the rebinding logic.</p> <p>If <code>--trigger-rebind-event</code> is in use, each message will be passed to the <code>rebind_message</code> event, along with the effective data value you specify through a combination of <code>--data</code> and/or <code>--set</code> parameters.  What actually happens to the message is defined solely by the logic in your <code>rebind_message</code> event.</p> <p>Otherwise, each message will merge the key/value pairs that you specified via <code>--data</code> and/or <code>--set</code> into the metadata of the message.</p> <p>After this, the message will be re-inserted into the queue subsystem.</p> <p>If your rebind action caused any of the envelope recipient (in the case of <code>--trigger-rebind-event</code>), <code>queue</code>, <code>tenant</code>, <code>campaign</code> or <code>routing_domain</code> meta items to be changed, then the message will be placed into a different queue from its original location; in that case, it will be updated so that it is eligible for immediate delivery and an <code>AdminRebind</code> log event will be generated to the logs.</p> <p>If the queue wasn't changed, then the next-due time of the message will remain unchanged, unless you specified <code>--always-flush</code>.  In that case, the message will be placed back into its original queue but be eligible for immediate delivery.</p> <p>If you do not wish to generate <code>AdminRebind</code> log entries, then you can use <code>--suppress-logging</code>.</p> <p>Since the number of messages may be very large, and because processing messages may result in a large amount of I/O to load in every matching message's metadata, the total amount of time taken for a rebind request may be too large to feasibly wait for in the context of a simple request/response.</p> <p>With that in mind, the rebinding action runs asynchronously: aside from any immediate syntax/request formatting issues, this command will immediately return with no further status indication.</p> <p>Errors will be reported in the diagnostic log.</p>"},{"location":"reference/kcli/rebind/#examples","title":"Examples","text":"<p>Move messages from the \"example.com\" queue to the \"foo.com\" queue:</p> <p>kcli rebind --domain example.com --set queue=foo.com</p> <p>Alternatively:</p> <p>kcli rebind --domain example.com --data '{\"queue\": \"foo.com\"}'</p> <p>Usage: <code>kcli rebind [OPTIONS] --reason &lt;REASON&gt;</code></p>"},{"location":"reference/kcli/rebind/#options","title":"Options","text":"<ul> <li> <p><code>--domain &lt;DOMAIN&gt;</code> \u2014 The domain name to match. If omitted, any domains will match!</p> </li> <li> <p><code>--routing-domain &lt;ROUTING_DOMAIN&gt;</code> \u2014 The routing_domain name to match. If omitted, any routing domain will match!</p> </li> <li> <p><code>--campaign &lt;CAMPAIGN&gt;</code> \u2014 The campaign name to match. If omitted, any campaigns will match!</p> </li> <li> <p><code>--tenant &lt;TENANT&gt;</code> \u2014 The tenant name to match. If omitted, any tenant will match!</p> </li> <li> <p><code>--reason &lt;REASON&gt;</code> \u2014 The reason to log in the delivery logs (each matching message will rebind with an AdminRebind record)</p> </li> <li> <p><code>--always-flush</code> \u2014 Always flush, even if we didn't change the scheduled queue</p> </li> <li> <p><code>--everything</code> \u2014 Match all queues</p> </li> <li> <p><code>--suppress-logging</code> \u2014 Do not generate AdminRebind delivery logs</p> </li> <li> <p><code>--trigger-rebind-event</code> \u2014 Trigger a \"rebind_message\" event which receives both the message and the data, and then decides what to do to the message. Otherwise, the data will be unconditionally applied to the message metadata</p> </li> <li> <p><code>--data &lt;DATA&gt;</code> \u2014 Specify a JSON object of key/value pairs which should either be set as meta values, or passed to the rebind_message event (if <code>--trigger-rebind-event</code> is in use)</p> </li> <li> <p><code>--set &lt;KEY=VALUE&gt;</code> \u2014 Set additional key/value pairs. Can be used multiple times</p> </li> </ul>"},{"location":"reference/kcli/set-log-filter/","title":"kcli set-log-filter","text":"<p>Changes the diagnostic log filter</p> <p>See https://docs.kumomta.com/reference/kumo/set_diagnostic_log_filter/ for more information about the log filter syntax.</p> <p>Usage: <code>kcli set-log-filter &lt;FILTER&gt;</code></p>","tags":["logging","debugging"]},{"location":"reference/kcli/set-log-filter/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;FILTER&gt;</code></li> </ul>","tags":["logging","debugging"]},{"location":"reference/kcli/suspend-cancel/","title":"kcli suspend-cancel","text":"<p>Cancels an admin suspend entry.</p> <p>Cancelling the entry prevents it from matching new messages. It cannot retroactively un-suspend messages that it already matched and suspendd.</p> <p>Usage: <code>kcli suspend-cancel --id &lt;ID&gt;</code></p>","tags":["suspend"]},{"location":"reference/kcli/suspend-cancel/#options","title":"Options","text":"<ul> <li><code>--id &lt;ID&gt;</code> \u2014 The id field of the suspend entry that you wish to cancel</li> </ul>","tags":["suspend"]},{"location":"reference/kcli/suspend-list/","title":"kcli suspend-list","text":"<p>Returns list of current administrative suspend rules.</p> <p>Returns the list of un-expired admin suspends that are currently in effect on the target instance.</p> <p>Usage: <code>kcli suspend-list</code></p>","tags":["suspend"]},{"location":"reference/kcli/suspend-ready-q-cancel/","title":"kcli suspend-ready-q-cancel","text":"<p>Cancels an admin suspend entry for a ready queue/egress path.</p> <p>Cancelling the entry re-enables delivery via the specified egress path.</p> <p>Usage: <code>kcli suspend-ready-q-cancel --id &lt;ID&gt;</code></p>","tags":["suspend"]},{"location":"reference/kcli/suspend-ready-q-cancel/#options","title":"Options","text":"<ul> <li><code>--id &lt;ID&gt;</code> \u2014 The id field of the suspend entry that you wish to cancel</li> </ul>","tags":["suspend"]},{"location":"reference/kcli/suspend-ready-q-list/","title":"kcli suspend-ready-q-list","text":"<p>Returns list of current ready queue/egress path suspend rules.</p> <p>Returns the list of un-expired admin suspends that are currently in effect on the target instance.</p> <p>Usage: <code>kcli suspend-ready-q-list</code></p>","tags":["suspend"]},{"location":"reference/kcli/suspend-ready-q/","title":"kcli suspend-ready-q","text":"<p>Administratively suspend the ready queue for an egress path</p> <p>Usage: <code>kcli suspend-ready-q [OPTIONS] --name &lt;NAME&gt; --reason &lt;REASON&gt;</code></p>","tags":["suspend"]},{"location":"reference/kcli/suspend-ready-q/#options","title":"Options","text":"<ul> <li> <p><code>--name &lt;NAME&gt;</code> \u2014 The name of the ready queue that you wish to suspend</p> </li> <li> <p><code>--reason &lt;REASON&gt;</code> \u2014 The reason to log in the delivery logs</p> </li> <li> <p><code>--duration &lt;DURATION&gt;</code> \u2014 The duration to suspend. The default is '5m'</p> </li> </ul>","tags":["suspend"]},{"location":"reference/kcli/suspend/","title":"kcli suspend","text":"<p>Administratively suspend messages in matching queues</p> <p>Usage: <code>kcli suspend [OPTIONS] --reason &lt;REASON&gt; &lt;--domain &lt;DOMAIN&gt;|--campaign &lt;CAMPAIGN&gt;|--tenant &lt;TENANT&gt;|--everything|--queue &lt;QUEUE&gt;&gt;</code></p>","tags":["suspend"]},{"location":"reference/kcli/suspend/#options","title":"Options","text":"<ul> <li> <p><code>--domain &lt;DOMAIN&gt;</code> \u2014 The domain name to match. If omitted, any domains will match!</p> </li> <li> <p><code>--campaign &lt;CAMPAIGN&gt;</code> \u2014 The campaign name to match. If omitted, any campaigns will match!</p> </li> <li> <p><code>--tenant &lt;TENANT&gt;</code> \u2014 The tenant name to match. If omitted, any tenant will match!</p> </li> <li> <p><code>--reason &lt;REASON&gt;</code> \u2014 The reason to log in the delivery logs</p> </li> <li> <p><code>--everything</code> \u2014 Suspend all queues</p> </li> <li> <p><code>--queue &lt;QUEUE&gt;</code> \u2014 Suspend specific scheduled queue names using their exact queue name(s). Can be specified multiple times</p> </li> <li> <p><code>--duration &lt;DURATION&gt;</code> \u2014 The duration over which matching messages will continue to suspend. The default is '5m'</p> </li> </ul>","tags":["suspend"]},{"location":"reference/kcli/top/","title":"kcli top","text":"<p>Continually update and show what's happening in kumod</p> <p>Usage: <code>kcli top [OPTIONS]</code></p>","tags":["ops","debugging"]},{"location":"reference/kcli/top/#options","title":"Options","text":"<ul> <li> <p><code>--update-interval &lt;UPDATE_INTERVAL&gt;</code></p> <p>Default value: <code>1</code></p> </li> </ul>","tags":["ops","debugging"]},{"location":"reference/kcli/trace-smtp-client/","title":"kcli trace-smtp-client","text":"<p>Trace outgoing sessions made by the SMTP service.</p> <p>This is a diagnostic tool for the server operator.</p> <p>Sessions are logged in real time.</p> <p>Take care on a busy server with live traffic as this tracing mechanism will by-default match all traffic, but there is limited capacity/resources for tracing.  Outside of initial small scale testing, you will need to carefully consider filtering constraints in order to observe only the intended sessions, otherwise the tracing subsystem will be forced to drop a subset of trace events.</p> <p>Filtering works by specifying an allow-list for specific properties of a trace session. If an allow-list for a given property is set, and the session has the corresponding property set, then the session is traced only if is value is contained in your set of allowed values.</p> <p>Most session properties are filled out AFTER the session has been initiated, and a given session may attempt to establish a series of connections based on how the MX records are resolved, so you should anticipate seeing a number of session initiations that won't (yet) match your trace parameters.</p> <p>The main session property that is known at initiation is the ready queue name, so if you know precisely the ready queue of interest, using <code>--ready-queue</code> will be the most focused and efficient filter you can specify.</p> <p>Usage: <code>kcli trace-smtp-client [OPTIONS]</code></p>","tags":["ops","debugging"]},{"location":"reference/kcli/trace-smtp-client/#options","title":"Options","text":"<ul> <li> <p><code>--source &lt;SOURCE&gt;</code> \u2014 Add a source (in CIDR format) to the list of source addresses that we want to filter by. If any are specified, then only connections made from a matching address will be traced. If no sources are specified, any/all incoming SMTP connections will be traced.</p> <p>Can be used multiple times to add multiple candidate addresses.</p> <p>Eg: --source 10.0.0.1 --source 192.168.1.0/24</p> </li> <li> <p><code>--mx-addr &lt;MX_ADDR&gt;</code> \u2014 Add an address (in CIDR format) to the list of MX host addresses that we want to filter by. If any are specified, then only connections made from a matching address will be traced. If no addresses are specified, any/all incoming SMTP connections will be traced.</p> <p>A given session may communicate with multiple MX addresses over its lifetime. The full list of MX addresses is not known at session initiation, and is filled in after they have been resolved.</p> <p>Can be used multiple times to add multiple candidate addresses.</p> <p>Eg: --mx-addr 10.0.0.1 --mx-addr 192.168.1.0/24</p> </li> <li> <p><code>--mx-host &lt;MX_HOST&gt;</code> \u2014 The MX hostname to match. If omitted, any MX hostname will match!</p> <p>A given session may communicate with multiple MX addresses over its lifetime. The full list of MX addresses is not known at session initiation, and is filled in after they have been resolved.</p> </li> <li> <p><code>--domain &lt;DOMAIN&gt;</code> \u2014 The domain name to match. If omitted, any domains will match!</p> <p>This is a per-message property, and is unavailable for matching until after a session has established a successful connection to a host and is ready to deliver a message. Until a message is present, this filter is ignored.</p> <p>A given connection in a session may transit messages with a variety of different domains.</p> </li> <li> <p><code>--routing-domain &lt;ROUTING_DOMAIN&gt;</code> \u2014 The routing_domain name to match. If omitted, any routing domain will match!</p> <p>This is a per-message property, and is unavailable for matching until after a session has established a successful connection to a host and is ready to deliver a message. Until a message is present, this filter is ignored.</p> </li> <li> <p><code>--campaign &lt;CAMPAIGN&gt;</code> \u2014 The campaign name to match. If omitted, any campaigns will match!</p> <p>This is a per-message property, and is unavailable for matching until after a session has established a successful connection to a host and is ready to deliver a message. Until a message is present, this filter is ignored.</p> <p>A given connection in a session may transit messages with a variety of different campaigns.</p> </li> <li> <p><code>--tenant &lt;TENANT&gt;</code> \u2014 The tenant name to match. If omitted, any tenant will match!</p> <p>This is a per-message property, and is unavailable for matching until after a session has established a successful connection to a host and is ready to deliver a message. Until a message is present, this filter is ignored.</p> <p>A given connection in a session may transit messages with a variety of different tenants.</p> </li> <li> <p><code>--egress-pool &lt;EGRESS_POOL&gt;</code> \u2014 The egress pool name to match. If omitted, any pool will match!</p> <p>This property is known at session initiation.</p> </li> <li> <p><code>--egress-source &lt;EGRESS_SOURCE&gt;</code> \u2014 The egress source name to match. If omitted, any source will match!</p> <p>This property is known at session initiation.</p> </li> <li> <p><code>--mail-from &lt;MAIL_FROM&gt;</code> \u2014 The envelope sender to match. If omitted, any will match.</p> <p>This is a per-message property, and is unavailable for matching until after a session has established a successful connection to a host and is ready to deliver a message. Until a message is present, this filter is ignored.</p> <p>A given connection in a session may transit messages with a variety of different envelopes.</p> </li> <li> <p><code>--rcpt-to &lt;RCPT_TO&gt;</code> \u2014 The envelope recipient to match. If omitted, any will match.</p> <p>This is a per-message property, and is unavailable for matching until after a session has established a successful connection to a host and is ready to deliver a message. Until a message is present, this filter is ignored.</p> <p>A given connection in a session may transit messages with a variety of different envelopes.</p> </li> <li> <p><code>--ready-queue &lt;READY_QUEUE&gt;</code> \u2014 The ready queue name to match. If omitted, any ready queue will match!</p> <p>This property is known at session initiation.</p> </li> <li> <p><code>--color &lt;COLOR&gt;</code> \u2014 Whether to colorize the output</p> <p>Default value: <code>tty</code></p> <p>Possible values: <code>tty</code>, <code>yes</code>, <code>no</code></p> </li> <li> <p><code>--only-new</code> \u2014 Trace only newly opened sessions; ignore data from previously opened sessions</p> </li> <li> <p><code>--only-one</code> \u2014 Trace the first session that we observe, ignoring all others</p> </li> <li> <p><code>--terse</code> \u2014 Abbreviate especially the write side of the transaction trace, which is useful when examining high traffic and/or large message transmission</p> </li> </ul>","tags":["ops","debugging"]},{"location":"reference/kcli/trace-smtp-server/","title":"kcli trace-smtp-server","text":"<p>Trace incoming connections made to the SMTP service.</p> <p>This is a diagnostic tool for the server operator.</p> <p>Connections are logged in real time.</p> <p>Take care to use an appropriate <code>--source</code> when using this with a live busy server, as you will be overwhelmed by the traffic.</p> <p>Usage: <code>kcli trace-smtp-server [OPTIONS]</code></p>","tags":["ops","debugging"]},{"location":"reference/kcli/trace-smtp-server/#options","title":"Options","text":"<ul> <li> <p><code>--source &lt;SOURCE&gt;</code> \u2014 Add a source (in CIDR format) to the list of source addresses that we want to filter by. If any are specified, then only connections made from a matching address will be traced. If no sources are specified, any/all incoming SMTP connections will be traced.</p> <p>Can be used multiple times to add multiple candidate addresses.</p> <p>Eg: --source 10.0.0.1 --source 192.168.1.0/24</p> </li> <li> <p><code>--color &lt;COLOR&gt;</code> \u2014 Whether to colorize the output</p> <p>Default value: <code>tty</code></p> <p>Possible values: <code>tty</code>, <code>yes</code>, <code>no</code></p> </li> <li> <p><code>--only-new</code> \u2014 Trace only newly opened sessions; ignore data from previously opened sessions</p> </li> <li> <p><code>--only-one</code> \u2014 Trace the first session that we observe, ignoring all others</p> </li> <li> <p><code>--terse</code> \u2014 Abbreviate especially the read side of the transaction trace, which is useful when examining high traffic and/or large message transmission</p> </li> </ul>","tags":["ops","debugging"]},{"location":"reference/kcli/xfer-cancel/","title":"kcli xfer-cancel","text":"<p>Cancels a message transfer that was initiated via the xfer subcommand.  You specify the name of the xfer queue associated with the transfer and matching messages will be taken out of that queue and returned to their originating queue</p> <p>Usage: <code>kcli xfer-cancel --reason &lt;REASON&gt; &lt;QUEUE_NAME&gt;</code></p>","tags":["ops","xfer"]},{"location":"reference/kcli/xfer-cancel/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;QUEUE_NAME&gt;</code> \u2014 The name of the xfer queue that you wish to cancel</li> </ul>","tags":["ops","xfer"]},{"location":"reference/kcli/xfer-cancel/#options","title":"Options","text":"<ul> <li><code>--reason &lt;REASON&gt;</code> \u2014 Each matching message will be rebound into its originating queue, and an AdminRebind log will be generated to trace that the rebind happened.  The reason you specify here will be included in that log record</li> </ul>","tags":["ops","xfer"]},{"location":"reference/kcli/xfer/","title":"kcli xfer","text":"<p>Transfer messages from matching queues to an alternative kumomta node.</p> <p>The intended purpose of this command is to facilitate manual migration of queues to alternative nodes as part of planned maintenance or part of an orchestrated down-scaling operation.</p> <p>Xfering works first by selecting the set of scheduled queues based on matching criteria that you specify via the <code>--domain</code>, <code>--routing-domain</code>, <code>--campaign</code>, <code>--tenant</code>, <code>--queue</code>, and/or <code>--everything</code> options.</p> <p>Each matching queue has its messages drained and the xfer logic will amend the message metadata to capture scheduling and due time information and then place the message into a special <code>.xfer.kumomta.internal</code> message transfer queue where it will be immediately eligible to be moved to the destination node.</p> <p>Upon successful reception on the destination node, the saved scheduling information will be restored to the message and it will be inserted into an appropriate queue on that destination node for delivery at the appropriate time.</p> <p>Since the number of messages may be very large, and because processing messages may result in a large amount of I/O to load in every matching message's metadata, the total amount of time taken for an xfer request may be too large to feasibly wait for in the context of a simple request/response.</p> <p>With that in mind, the xfer action runs asynchronously: aside from any immediate syntax/request formatting issues, this command will immediately return with no further status indication.</p> <p>Errors will be reported in the diagnostic log.</p>","tags":["ops","xfer"]},{"location":"reference/kcli/xfer/#examples","title":"Examples","text":"<p>Move messages from the \"example.com\" queue to the kumomta node running an http listener on <code>http://10.0.0.1:8000</code>:</p> <p><code>kcli xfer --domain example.com --target http://10.0.0.1:8000</code></p> <p>Usage: <code>kcli xfer --reason &lt;REASON&gt; --target &lt;TARGET&gt; &lt;--domain &lt;DOMAIN&gt;|--routing-domain &lt;ROUTING_DOMAIN&gt;|--campaign &lt;CAMPAIGN&gt;|--tenant &lt;TENANT&gt;|--everything|--queue &lt;QUEUE&gt;&gt;</code></p>","tags":["ops","xfer"]},{"location":"reference/kcli/xfer/#options","title":"Options","text":"<ul> <li> <p><code>--domain &lt;DOMAIN&gt;</code> \u2014 The domain name to match. If omitted, any domains will match!</p> </li> <li> <p><code>--routing-domain &lt;ROUTING_DOMAIN&gt;</code> \u2014 The routing_domain name to match. If omitted, any routing domain will match!</p> </li> <li> <p><code>--campaign &lt;CAMPAIGN&gt;</code> \u2014 The campaign name to match. If omitted, any campaigns will match!</p> </li> <li> <p><code>--tenant &lt;TENANT&gt;</code> \u2014 The tenant name to match. If omitted, any tenant will match!</p> </li> <li> <p><code>--queue &lt;QUEUE&gt;</code> \u2014 The precise name of a scheduled queue which should match. Can be specified multiple times</p> </li> <li> <p><code>--reason &lt;REASON&gt;</code> \u2014 Each matching message will be rebound into an appropriate xfer queue, and an AdminRebind log will be generated to trace that the rebind happened.  The reason you specify here will be included in that log record</p> </li> <li> <p><code>--everything</code> \u2014 Match all queues</p> </li> <li> <p><code>--target &lt;TARGET&gt;</code> \u2014 Which node to transfer the messages to. This should be an HTTP URL prefix that will reach the HTTP listener on the target node, such as <code>http://hostname:8000</code></p> </li> </ul>","tags":["ops","xfer"]},{"location":"reference/kumo/","title":"<code>require 'kumo'</code>","text":"<p>The <code>kumo</code> module provides access to the core KumoMTA functions used to express your configuration and policy.</p>"},{"location":"reference/kumo/apply_supplemental_trace_header/","title":"kumo.apply_supplemental_trace_header","text":"<pre><code>kumo.apply_supplemental_trace_header(msg, opt_params)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Builds a supplemental trace header according to the optional parameters, and adds it to the message.</p> <p>If <code>opt_params</code> is omitted or is <code>nil</code>, then the default params will be used. The parameters are the same as the start_esmtp_listener.trace_headers parameter value.</p>"},{"location":"reference/kumo/apply_supplemental_trace_header/#example-add-a-default-supplemental-trace-header","title":"Example: add a default supplemental trace header","text":"<p>Both of these examples are equivalent:</p> <pre><code>kumo.apply_supplemental_trace_header(msg)\n</code></pre> <pre><code>kumo.apply_supplemental_trace_header(msg, {\n  supplemental_header = true,\n  header_name = 'X-KumoRef',\n  include_meta_names = {},\n})\n</code></pre>"},{"location":"reference/kumo/available_parallelism/","title":"kumo.available_parallelism","text":"<pre><code>kumo.available_parallelism()\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Returns an estimate of the default amount of parallelism a program should use.</p> <p>Parallelism is a resource. A given machine provides a certain capacity for parallelism, i.e., a bound on the number of computations it can perform simultaneously. This number often corresponds to the amount of CPUs a computer has, but it may diverge in various cases.</p> <p>Host environments such as VMs or container orchestrators may want to restrict the amount of parallelism made available to programs in them. This is often done to limit the potential impact of (unintentionally) resource-intensive programs on other programs running on the same machine.</p>","tags":["threadpool"]},{"location":"reference/kumo/available_parallelism/#limitations","title":"Limitations","text":"<p>The purpose of this API is to provide an easy and portable way to query the default amount of parallelism the program should use. Among other things it does not expose information on NUMA regions, does not account for differences in (co)processor capabilities or current system load, and will not modify the program\u2019s global state in order to more accurately query the amount of available parallelism.</p> <p>Where both fixed steady-state and burst limits are available the steady-state capacity will be used to ensure more predictable latencies.</p> <p>Resource limits can be changed during the runtime of a program, therefore the value is not cached and instead recomputed every time this function is called. It should not be called from hot code.</p> <p>The value returned by this function should be considered a simplified approximation of the actual amount of parallelism available at any given time. To get a more detailed or precise overview of the amount of parallelism available to the program, you may wish to use platform-specific APIs as well. The following platform limitations currently apply to <code>kumo.available_parallelism()</code>:</p> <ul> <li> <p>It may overcount the amount of parallelism available when limited by a   process-wide affinity mask or cgroup quotas and <code>sched_getaffinity()</code> or   cgroup fs can\u2019t be queried, e.g. due to sandboxing.</p> </li> <li> <p>It may undercount the amount of parallelism if the current thread\u2019s affinity   mask does not reflect the process\u2019 cpuset, e.g. due to pinned threads.</p> </li> <li> <p>If the process is in a cgroup v1 cpu controller, this may need to scan   mountpoints to find the corresponding cgroup v1 controller, which may take   time on systems with large numbers of mountpoints. (This does not apply to   cgroup v2, or to processes not in a cgroup.)</p> </li> <li> <p>It may overcount the amount of parallelism available when running in a VM   with CPU usage limits (e.g. an overcommitted host).</p> </li> </ul> <p>This documentation is excerpted from the underlying Rust function.</p> <p>Note</p> <p>If <code>kumo.available_parallelism</code> returns an incorrect estimate for your system (for the reasons mentioned above), you can force it to return a different by value by setting the <code>KUMO_AVAILABLE_PARALLELISM</code> environment variable to the desired value in the environment when you launch <code>kumod</code> or <code>tsa-daemon</code>.  (Since: Version 2025.05.06-b29689af).</p>","tags":["threadpool"]},{"location":"reference/kumo/bump_config_epoch/","title":"kumo.bump_config_epoch","text":"<pre><code>kumo.bump_config_epoch()\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Increments the current configuration epoch and notifies various internal modules and processes of the change, causing them to refresh their state.</p> <p>See Configuration Monitoring for more information on this topic.</p> <p>This particular function is intended to be used in a reactive manner. For example, the shaping helper uses kumo.spawn_task and kumo.http.connect_websocket to subscribe to the TSA daemon, and then calls <code>kumo.bump_config_epoch()</code> in response to changes in configuration provides by TSA daemon.</p>"},{"location":"reference/kumo/configure_accounting_db_path/","title":"kumo.configure_accounting_db_path","text":"<pre><code>kumo.configure_accounting_db_path 'PATH'\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Configures the path that will be used for the accounting database.</p> <p>The accounting database records the total volume of message receptions and deliveries performed by the MTA.</p> <p>This function should be called only from inside your init event handler.</p> <p>The default path is <code>\"/var/spool/kumomta/accounting.db\"</code>.</p>"},{"location":"reference/kumo/configure_bounce_classifier/","title":"kumo.configure_bounce_classifier","text":"<pre><code>kumo.configure_bounce_classifier { PARAMS }\n</code></pre> <p>Configures the bounce classifier. The purpose of the classifier is to attempt to digest complex and wide-ranging responses into a smaller set of categories to help inform the sender how best to respond and react to a delivery failure.</p> <p>This function should be called only from inside your init event handler.</p> <p>PARAMS is an object-style table that accepts the following keys:</p> <ul> <li><code>files</code> - required array-style table listing the paths to the set of   classification files that define the classification rules.</li> <li><code>back_pressure</code> - optional integer. default is <code>131072</code>. Specifies the maximum   number of in-flight classifications before submission blocks. (Since: Version 2024.09.02-c5476b89)</li> <li><code>pool_size</code> - optional integer. default is 1/4 of the available parallelism.   Specifies the number of threads to be used to process bounce classification.   Classification is CPU intensive and the cost of any given classification scales   with the size of the classification rules you have defined. You will likely need   to have more than a single thread available for the most optimal throughput.   The <code>pool_size</code> option allows you to specify that number of threads.   (Since: Version 2024.09.02-c5476b89)</li> <li><code>cache_size</code> - optional integer. default is <code>1024</code>. Specifies the size of   the bounce classification cache used to hold successful classification results.   (Since: Version 2024.09.02-c5476b89)</li> <li><code>uncategorized_cache_size</code> - optional integer. default is <code>1024</code>. Specifies the size of   the bounce classification cache used to hold unclassified results.  These are in   a separate cache from the positive classifications to prevent uncategorized results   from churning the successful classifications out of the cache.   (Since: Version 2024.09.02-c5476b89)</li> </ul> <p>The following classifications are pre-defined:</p> Label Meaning InvalidRecipient The recipient is invalid DNSFailure The message bounced due to a DNS failure. SpamBlock The message was blocked by the receiver as coming from a known spam source. SpamContent The message was blocked by the receiver as spam ProhibitedAttachment The message was blocked by the receiver because it contained an attachment RelayDenied The message was blocked by the receiver because relaying is not allowed. AutoReply The message is an auto-reply/vacation mail. TransientFailure Message transmission has been temporarily delayed. Subscribe The message is a subscribe request. Unsubscribe The message is an unsubscribe request. ChallengeResponse The message is a challenge-response probe. BadConfiguration messages rejected due to configuration issues with remote host BadConnection messages bounced due to bad connection issues with remote host BadDomain messages bounced due to invalid or non-existing domains ContentRelated messages refused or blocked due to content related reasons InactiveMailbox messages rejected due to expired InvalidSender messages bounced due to invalid DNS or MX entry for sending domain MessageExpired messages bounced due to not being delivered before the bounce-after NoAnswerFromHost messages bounces due to receiving no response from remote host after connecting PolicyRelated messages refused or blocked due to general policy reasons ProtocolErrors messages rejected due to SMTP protocol syntax or sequence errors QuotaIssues messages rejected or blocked due to mailbox quota issues RelayingIssues messages refused or blocked due to remote mail server relaying issues RoutingErrors messages bounced due to mail routing issues for recipient domain SpamRelated messages refused or blocked due to spam related reasons VirusRelated messages refused or blocked due to virus related reasons AuthenticationFailed authentication policy was not met TooManyRecipients A session or batch limit on the number of recipients was hit (Since: Version 2025.12.02-67ee9e96) Uncategorized messages rejected due to other reasons <p>Since: Version 2023.12.28-63cde9c7</p> <p>The functionality described in this outlined box requires version 2023.12.28-63cde9c7 of KumoMTA, or a more recent version.</p> <p>It is now possible to define your own classification labels. You can do so simply by using whatever label you like.  It is more efficient (uses less memory) to use one of the predefined codes.</p> <p>The classifier must be configured with a set of rules files that provide mappings from a set of regular expressions to the available classification codes.</p> <p><code>kumo.configure_bounce_classifier</code> will compile the merged set of files and rules into an efficient regex set that can quickly match the rule to the classification code.</p> <p>Once the classifier has been configured via this function, the logging functions will automatically call into it to populate the <code>bounce_classification</code> field.</p> <pre><code>kumo.on('init', function()\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumomta',\n  }\n  kumo.configure_bounce_classifier {\n    files = {\n      '/opt/kumomta/share/bounce_classifier/iana.toml',\n    },\n  }\nend)\n</code></pre> <p>The <code>iana.toml</code> file is provided with rules that map from IANA defined status codes to an appropriate bounce class.</p> <p>You may create and maintain your own classifications and add them to the list of files.</p> <p>Here's an excerpt of the <code>iana.toml</code>:</p> TOMLJSON <pre><code># This file contains rules that match SMTP ENHANCEDSTATUSCODES\n# codes as defined in the IANA registry:\n# https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xhtml\n# to bounce classifications.\n[rules]\nInvalidRecipient = [\n  \"^(451|550) [45]\\\\.1\\\\.[1234] \",\n  \"^45[02] [45]\\\\.2\\\\.4 \", # Mailing list expansion\n  \"^5\\\\d{2} [45]\\\\.7\\\\.17 \", # RRVS: Mailbox owner has changed\n]\nBadDomain = [\n  \"^(451|550) [45]\\\\.1\\\\.10 \", # NULL MX\n  \"^5\\\\d{2} [45]\\\\.7\\\\.18 \", # RRVS: domain owner has changed\n]\nInactiveMailbox = [\n  \"^(451|550) [45]\\\\.1\\\\.[6] \",\n  \"^[45]\\\\d{2} [45]\\\\.2\\\\.1 \",\n  \"^525 [45]\\\\.7\\\\.13 \", # User account disabled\n]\nInvalidSender = [\n  \"^(451|550) [45]\\\\.1\\\\.[78] \",\n  \"^\\\\d{3} [45]\\\\.7\\\\.27 \", # Send address has NULL MX\n]\nQuotaIssues = [\n  \"^552 [45]\\\\.2\\\\.2 \",\n  \"^552 [45]\\\\.2\\\\.3 \",\n  \"^452 [45]\\\\.3\\\\.1 \", # Mail System Full\n  \"^55[24] [45]\\\\.3\\\\.4 \", # Message too large for system\n]\n</code></pre> <pre><code>{\n  // This file contains rules that match SMTP ENHANCEDSTATUSCODES\n  // codes as defined in the IANA registry:\n  // https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xhtml\n  // to bounce classifications.\n  \"rules\": {\n    \"InvalidRecipient\": [\n      \"^(451|550) [45]\\\\.1\\\\.[1234] \",\n      \"^45[02] [45]\\\\.2\\\\.4 \",\n      \"^5\\\\d{2} [45]\\\\.7\\\\.17 \"\n    ],\n    \"BadDomain\": [\n      \"^(451|550) [45]\\\\.1\\\\.10 \",\n      \"^5\\\\d{2} [45]\\\\.7\\\\.18 \"\n    ],\n    \"InactiveMailbox\": [\n      \"^(451|550) [45]\\\\.1\\\\.[6] \",\n      \"^[45]\\\\d{2} [45]\\\\.2\\\\.1 \",\n      \"^525 [45]\\\\.7\\\\.13 \"\n    ],\n    \"InvalidSender\": [\n      \"^(451|550) [45]\\\\.1\\\\.[78] \",\n      \"^\\\\d{3} [45]\\\\.7\\\\.27 \"\n    ],\n    \"QuotaIssues\": [\n      \"^552 [45]\\\\.2\\\\.2 \",\n      \"^552 [45]\\\\.2\\\\.3 \",\n      \"^452 [45]\\\\.3\\\\.1 \",\n      \"^55[24] [45]\\\\.3\\\\.4 \"\n    ]\n  }\n}\n</code></pre>"},{"location":"reference/kumo/configure_log_hook/","title":"kumo.configure_log_hook","text":"<pre><code>kumo.configure_log_hook { PARAMS }\n</code></pre> <p>Configures the lua logging hook. When enabled, each matching log event will cause a new Message to be generated and have its body assigned to the log record (or to its template expansion if you have configured that), and passed to the should_enqueue_log_record event.</p> <pre><code>kumo.on('init', function()\n  kumo.configure_log_hook {\n    -- name will be passed to should_enqueue_log_record as the hook_name\n    -- parameter so that you can reason about different instances of the\n    -- log hook in the case where you are sending data to multiple\n    -- different places.\n    name = 'webhook',\n    headers = { 'Subject', 'X-Customer-ID' },\n  }\nend)\n</code></pre> <p>This allows you to utilize KumoMTA's internal queueing to dispatch log events to external systems such as webhooks or some external queuing system for processing elsewhere in your deployment architecture.</p> <p>See should_enqueue_log_record for an example.</p> <p>The following options are configurable for the logging hook and work the same way as their counterparts in local log file logging. Rather than duplicate the information here, this section links to those options:</p> <ul> <li>back_pressure</li> <li>meta</li> <li>headers</li> <li>per_record</li> </ul> <p>In addition, the following options are supported:</p>","tags":["logging"]},{"location":"reference/kumo/configure_log_hook/#name","title":"name","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Required string naming the hook.</p> <p>The name will be passed as the hook_name parameter to the should_enqueue_log_record event.</p>","tags":["logging"]},{"location":"reference/kumo/configure_log_hook/#deferred_spool","title":"deferred_spool","text":"<p>If set to <code>true</code>, the generated message will not be immediately saved to the spool in the case that your should_enqueue_log_record indicates that the message should be queued.</p>","tags":["logging"]},{"location":"reference/kumo/configure_redis_throttles/","title":"kumo.configure_redis_throttles","text":"<pre><code>kumo.configure_redis_throttles { PARAMS }\n</code></pre> <p>Configure the throttle layer to use a Redis data store to manage throttling across multiple MTA nodes.</p> <p>When running version 2024.09.02-c5476b89 or earlier, the redis server must have redis-cell installed for throttles to be shared. Later versions will automatically detect whether <code>redis-cell</code> is available and fall back to an alternative throttling implementation that doesn't have any other additional dependency requirements for the redis server.</p> <p>PARAMS behaves exactly as described in redis.open.</p> <p>This function should be called only from inside your init event handler.</p> <pre><code>kumo.on('init', function()\n  -- Use shared throttles and connection limits rather than in-process throttles\n  kumo.configure_redis_throttles { node = 'redis://my-redis-host/' }\nend)\n</code></pre> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Enabling redis throttles now also enables redis-based shared connection limits.</p>"},{"location":"reference/kumo/disconnect/","title":"kumo.disconnect","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <pre><code>kumo.disconnect(CODE, MESSAGE, REJECT_OR_DISCONNECT)\n</code></pre> <p>Calling <code>kumo.disconnect</code> will raise a lua error that will cause the current ESMTP event to respond with the SMTP error code and message that you specify, preferentially disconnecting the incoming SMTP session.</p> <p>The parameters are:</p> <ul> <li><code>CODE</code> - Required integer. The SMTP code to use alongside your <code>MESSAGE</code>.  Note that the SMTP   protocol specification requires that a unilateral disconnection be sent with a   <code>421</code> code.  You can adjust/account for your conformance via the optional   <code>REJECT_OR_DISCONNECT</code> parameter detailed below.</li> <li><code>MESSAGE</code> - Required string. The reason for the disconnection.  If you intend to use   ENHANCED STATUS CODES, you should prefix the message with your enhanced   status code.</li> <li><code>REJECT_OR_DISCONNECT</code> - Optional string. Controls whether the connection will be disconnected   or more simply rejected.  It accepts the following possible values:</li> <li><code>\"ForceDisconnect\"</code> - disconnect the session immediately after sending your      <code>CODE</code> and <code>MESSAGE</code>, even if <code>CODE</code> is not <code>421</code>.  Using this value with      a non-<code>421</code> code is technically non-conforming to the SMTP protocol      specification.</li> <li><code>\"FollowWith421\"</code> - if the <code>CODE</code> is not <code>421</code>, emit the <code>CODE</code> and <code>MESSAGE</code>,      then synthesize a <code>421 HOSTNAME disconnecting due to previous error</code> disconnection      response to immediately follow it, and then disconnect.</li> <li><code>\"If421\"</code> - if the <code>CODE</code> is <code>421</code> disconnect the session. Otherwise, behave like      kumo.reject and leave the connection established.</li> </ul>"},{"location":"reference/kumo/disconnect/#disconnect-with-a-421","title":"Disconnect with a 421","text":"<pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  kumo.disconnect(421, 'mta.example.com go away!')\n  -- this line is not reached\n  -- The service responds to the peer with '421 mta.example.com go away!'\n  -- and then drops the connection\nend)\n</code></pre>"},{"location":"reference/kumo/disconnect/#disconnect-with-a-non-standard-exit-code-non-smtp-conformant","title":"Disconnect with a non-standard exit code, non-SMTP-conformant","text":"<p>This example is not strictly conforming to SMTP, which requires that a 421 be used to indicate a disconnection. This may not matter in practice, but if it does matter for your use case, look at the example below this one.</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  kumo.disconnect(451, 'no thank you')\n  -- this line is not reached\n  -- The service responds to the peer with '451 no thank you'\n  -- and then drops the connection\nend)\n</code></pre>"},{"location":"reference/kumo/disconnect/#disconnect-with-a-non-standard-exit-code-while-remaining-smtp-conformant","title":"Disconnect with a non-standard exit code, while remaining SMTP conformant","text":"<pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  kumo.disconnect(451, 'no thank you', 'FollowWith421')\n  -- this line is not reached\n  -- The service responds to the peer with '451 no thank you\\r\\n421 HOSTNAME disconnecting due to previous error'\n  -- and then drops the connection\nend)\n</code></pre>"},{"location":"reference/kumo/eval_config_monitor_globs/","title":"kumo.eval_config_monitor_globs","text":"<pre><code>kumo.eval_config_monitor_globs()\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Evalutes the glob expressions that have been configured by kumo.set_config_monitor_globs and returns the deduplicated set of matching filenames as an array style table.</p> <p>This function is provided primarily as a debugging/introspection aide.</p>"},{"location":"reference/kumo/generate_rfc3464_message/","title":"kumo.generate_rfc3464_message","text":"<pre><code>local bounce_msg =\n  kumo.generate_rfc3464_message(PARAMS, OPT_ORIG_MSG, LOG_RECORD)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Generates an RFC 3464 delivery status Message from a log record.  This function is intended to be used from inside a <code>log_disposition</code> event handler to facilitate the generation of bounce messages.</p> <p>For sender-oriented use cases we generally recommend against generating bounce messages as they place additional load on the system and introduce some degree of Backscatter risk.</p> <p>When KumoMTA is deployed as a more general purpose relay it becomes more desirable to generate delivery status reports to the originating user, which is where this function comes in.</p> <p><code>PARAMS</code> is an object style table with the following fields:</p> <ul> <li><code>include_original_message</code> is a string that can be one of <code>FullContent</code>,     <code>HeadersOnly</code> or <code>No</code>.  This controls whether the entire message, just its     headers, or none of the message that triggered the report should be     included within the report.  When set to anything other than <code>No</code>, the     <code>OPT_ORIG_MSG</code> parameter must also be passed to <code>kumo.generate_rfc3464_message</code>.</li> <li><code>enable_expiration</code> is an optional boolean value that defaults to <code>false</code>     if not specified. When <code>true</code>, a report message will be generated for     messages that have exceeded their configured time in the queue without     delivery.</li> <li><code>enable_bounce</code> is an optional boolean value that defaults to <code>false</code>     if not specified. When <code>true</code>, a report message will be generated for     messages that experience a permanent failure response when talking     to the next hop MTA.</li> <li><code>reporting_mta</code> is a required lua table with the fields <code>mta_type</code> and     <code>name</code> that will be included in the <code>Reporting-MTA</code> header of the generated     report.  <code>mta_type</code> will typically be <code>dns</code> and <code>name</code> will typically be     the corresponding DNS name that identifies the current host generating the     report.  The domain name will appear in the <code>From</code> header of the generated     report as well.</li> <li><code>stable_content</code> is an optional boolean value that defaults to <code>false</code>     if not specified. When <code>true</code>, various header fields will be set to constant     values that will make the generated message easier to reason about in a     test harness. You will not typically need to use this parameter.</li> </ul> <p>The <code>OPT_ORIG_MSG</code> parameter is an optional Message that will used to provide the original message content in the report.</p> <p><code>LOG_RECORD</code> is a JsonLogRecord describing the event that occurred to the message.</p> <p><code>kumo.generate_rfc3464_message</code> takes those three parameters and produces an optional Message from them.</p> <p>The return value may be <code>nil</code>, for example, if the <code>LOG_RECORD</code> doesn't match any of the types that are enabled in the <code>PARAMS</code>, or if there is some information missing or otherwise inapplicable; for example, if <code>LOG_RECORD</code> is a <code>Bounce</code> but for a protocol other than <code>ESMTP</code> then no report will be generated.</p>"},{"location":"reference/kumo/generate_rfc3464_message/#example-of-generating-non-delivery-reports","title":"Example of generating non-delivery reports","text":"<pre><code>local log_hooks = require 'policy-extras.log_hooks'\n\nlocal function ndr_generator(msg, log_record)\n  local params = {\n    include_original_message = 'FullContent',\n    enable_expiration = true,\n    enable_bounce = true,\n    reporting_mta = {\n      mta_type = 'dns',\n      name = 'mta1.example.com',\n    },\n  }\n  local bounce_msg = kumo.generate_rfc3464_message(params, msg, log_record)\n  if bounce_msg then\n    local ok, err = pcall(kumo.inject_message, bounce_msg)\n    if not ok then\n      kumo.log_error('failed to inject NDR: ', err)\n    end\n  end\nend\n\nlog_hooks:new_disposition_hook {\n  name = 'ndr_generator',\n  hook = ndr_generator,\n}\n</code></pre> <p>If you wish to customize the human readable portion of the message, you might consider using the mime parsing functions:</p> <pre><code>local mime = bounce_msg:parse_mime()\nlocal structure = mime:get_simple_structure()\nstructure.text_part.body = 'MODIFIED!\\r\\n' .. structure.text_part.body\nbounce_msg:set_data(tostring(mime))\n</code></pre>"},{"location":"reference/kumo/generate_rfc3464_message/#sample-of-a-generated-bounce-report","title":"Sample of a generated bounce report","text":"<pre><code>Content-Type: multipart/report;\n  boundary=\"report-boundary\";\n  report-type=\"delivery-status\"\nSubject: Returned mail\nMime-Version: 1.0\nMessage-ID: &lt;UUID@mta1.example.com&gt;\nTo: sender@sender.example.com\nFrom: Mail Delivery Subsystem &lt;mailer-daemon@mta1.example.com&gt;\n\n--report-boundary\nContent-Type: text/plain;\n  charset=\"us-ascii\"\n\nThe message was received at Tue, 1 Jul 2003 08:52:37 +0000\nfrom sender@sender.example.com and addressed to recip@target.example.com.\nWhile communicating with target.example.com (42.42.42.42):\nResponse: 550 5.7.1 no thanks\n\nThe message will be deleted from the queue.\nNo further attempts will be made to deliver it.\n--report-boundary\nContent-Type: message/delivery-status;\n  charset=\"us-ascii\"\n\nReporting-MTA: dns; mta1.example.com\nArrival-Date: Tue, 1 Jul 2003 08:52:37 +0000\n\nFinal-Recipient: rfc822;recip@target.example.com\nAction: failed\nStatus: 5.7.1 no thanks\nRemote-MTA: dns; target.example.com\nDiagnostic-Code: smtp; 550 5.7.1 no thanks\nLast-Attempt-Date: Tue, 1 Jul 2003 10:52:37 +0000\n\n--report-boundary\nContent-Type: message/rfc822\n\nContent-Type: text/plain;\n  charset=\"us-ascii\"\nSubject: Hello!\n\nhello there\n--report-boundary--\n</code></pre>"},{"location":"reference/kumo/generate_rfc3464_message/#sample-of-a-generated-expiration-report","title":"Sample of a generated expiration report","text":"<pre><code>Content-Type: multipart/report;\n  boundary=\"report-boundary\";\n  report-type=\"delivery-status\"\nSubject: Returned mail\nMime-Version: 1.0\nMessage-ID: &lt;UUID@mta1.example.com&gt;\nTo: sender@sender.example.com\nFrom: Mail Delivery Subsystem &lt;mailer-daemon@mta1.example.com&gt;\n\n--report-boundary\nContent-Type: text/plain;\n  charset=\"us-ascii\"\nContent-Transfer-Encoding: quoted-printable\n\nThe message was received at Tue, 1 Jul 2003 08:52:37 +0000\nfrom sender@sender.example.com and addressed to recip@target.example.com.\nStatus: 551 5.4.7 Next delivery time would be at SOME TIME which exceeds th=\ne expiry time EXPIRES configured via set_scheduling\nThe message will be deleted from the queue.\nNo further attempts will be made to deliver it.\n--report-boundary\nContent-Type: message/delivery-status;\n  charset=\"us-ascii\"\nContent-Transfer-Encoding: quoted-printable\n\nReporting-MTA: dns; mta1.example.com\nArrival-Date: Tue, 1 Jul 2003 08:52:37 +0000\n\nFinal-Recipient: rfc822;recip@target.example.com\nAction: failed\nStatus: 5.4.7 Next delivery time would be at SOME TIME which exceeds the ex=\npiry time EXPIRES configured via set_scheduling\nDiagnostic-Code: smtp; 551 5.4.7 Next delivery time would be at SOME TIME w=\nhich exceeds the expiry time EXPIRES configured via set_scheduling\nLast-Attempt-Date: Tue, 1 Jul 2003 10:52:37 +0000\n\n--report-boundary\nContent-Type: text/rfc822-headers\n\nContent-Type: text/plain;\n  charset=\"us-ascii\"\nSubject: Hello!\n--report-boundary--\n</code></pre>"},{"location":"reference/kumo/get_memory_hard_limit/","title":"kumo.get_memory_hard_limit","text":"<pre><code>local limit = kumo.get_memory_hard_limit()\n</code></pre> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Returns the hard memory limit, or <code>nil</code> if none has been configured.</p> <p>If your policy doesn't explicitly configure a limit via kumo.set_memory_hard_limit, whether there is a hard limit depends on the environment into which the process was spawned.</p> <p>See Memory Management for a discussion on how kumomta manages memory usage.</p>","tags":["memory"]},{"location":"reference/kumo/get_memory_low_thresh/","title":"kumo.get_memory_low_thresh","text":"<pre><code>local thresh = kumo.get_memory_low_thresh()\n</code></pre> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Returns the low memory threshold, or <code>nil</code> if none has been configured.</p> <p>If your policy doesn't explicitly configure hard/soft limits, the default value depends on the environment into which the process was spawned.</p> <p>See kumo.set_memory_low_thresh for more details on this specific setting.</p> <p>See Memory Management for a discussion on how kumomta manages memory usage.</p>","tags":["memory"]},{"location":"reference/kumo/get_memory_soft_limit/","title":"kumo.get_memory_soft_limit","text":"<pre><code>local limit = kumo.get_memory_soft_limit()\n</code></pre> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Returns the soft memory limit, or <code>nil</code> if none has been configured.</p> <p>If your policy doesn't explicitly configure hard/soft limits, whether there is a default soft limit depends on the environment into which the process was spawned.</p> <p>See Memory Management for a discussion on how kumomta manages memory usage.</p>","tags":["memory"]},{"location":"reference/kumo/glob/","title":"kumo.glob","text":"<pre><code>kumo.glob(pattern [, relative_to, [, ttl_seconds]])\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>This function is deprecated in favor of kumo.fs.glob.</p> <p>This function evalutes the glob <code>pattern</code> and returns an array containing the absolute file names of the matching results.  Due to limitations in the lua bindings, all of the paths must be able to be represented as UTF-8 or this function will generate an error.</p> <p>The optional <code>relative_to</code> parameter can be used to make the results relative to a path.  If the results have the same prefix as <code>relative_to</code> then it will be removed from the returned path. The default for this parameter is <code>.</code>.</p> <p>The optional <code>ttl_seconds</code> parameter specifies how long the results of the glob operation will be cached.  Subsequent calls to <code>glob</code> with the same <code>pattern</code> and <code>relative_to</code> will return those previously cached results until the TTL expires.  The default TTL is <code>60</code> seconds.</p> <p>Warning</p> <p>This function can cause an expensive filesystem walk to occur, especially if used on a storage volume that is experiencing IO pressure (such as from spooling or logging). Take care to scope the pattern to minimize the impact of the walk, and the <code>ttl_seconds</code> parameter to something that is appropriate to your use case.</p> <p>Note</p> <p>If the specified pattern or path references a directory that doesn't exist, or a directory that is inaccessible to the kumo user, no error will be generated; those paths are silently omitted from the results.</p> <pre><code>local kumo = require 'kumo'\n\n-- logs the names of all of the '*.conf' files under `/etc`\nprint(kumo.json_encode_pretty(kumo.glob '/etc/*.conf'))\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo/inject_message/","title":"kumo.inject_message","text":"<pre><code>kumo.inject_message(MSG)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Injects the <code>MSG</code> into the queue subsystem and begins delivering the message.</p> <p>When this function returns successfully, you should consider the message that you provided as an argument to now be owned by the core of kumomta and assume that it may have already been delivered and removed from the spool.</p> <p>This function can fail due to issues resolving queue configuration or spooling. In error situations, an error will be raised that you can trap using the lua <code>pcall</code> function if appropriate.</p> <p>Danger</p> <p>Unless it is explicitly indicated in the documentation to be safe, you MUST NOT call this function on any message other than one that you have created via kumo.make_message, otherwise you risk both duplicate delivery and loss of accountability for the message.</p>","tags":["message"]},{"location":"reference/kumo/invoke_get_egress_path_config/","title":"kumo.invoke_get_egress_path_config","text":"<pre><code>local config =\n  kumo.invoke_get_egress_path_config(routing_domain, egress_source, site_name)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>This function triggers a call through to the get_egress_path_config event callback(s) that have been defined in the policy to obtain the effective configuration for the specified combination of <code>routing_domain</code>, <code>egress_source</code> and <code>site_name</code>.</p> <p>The result of that is then serialized and returned as a lua value that has the same shape as the <code>PARAMS</code> defined for kumo.make_egress_path.</p> <p>Note</p> <p>The following fields do not presently round-trip back into lua and will be unavailable in the returned value:</p> <ul> <li><code>openssl_options</code></li> <li><code>rustls_cipher_suites</code></li> </ul> <p>Danger</p> <p>Take care when using this function and its related <code>invoke_xxx</code> functions, as you can potentially create cross-dependent, mututally recursive, event callbacks that call into each other.</p>"},{"location":"reference/kumo/invoke_get_egress_pool/","title":"kumo.invoke_get_egress_pool","text":"<pre><code>local config = kumo.invoke_get_egress_pool(pool_name)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This function triggers a call through to the get_egress_pool event callback(s) that have been defined in the policy to obtain the effective configuration for the specified <code>pool_name</code>.</p> <p>The result of that is then serialized and returned as a lua value that has the same shape as the <code>PARAMS</code> defined for kumo.make_egress_pool.</p> <p>This function may be satisfied by the internal cache of resolved (and validated!) pool configuration information, so it may not directly trigger the <code>get_egress_pool</code> callback every time that it is called.</p> <p>Danger</p> <p>Take care when using this function and its related <code>invoke_xxx</code> functions, as you can potentially create cross-dependent, mututally recursive, event callbacks that call into each other.</p>"},{"location":"reference/kumo/invoke_get_egress_source/","title":"kumo.invoke_get_egress_source","text":"<pre><code>local config = kumo.invoke_get_egress_source(source_name)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This function triggers a call through to the get_egress_source event callback(s) that have been defined in the policy to obtain the effective configuration for the specified <code>source_name</code>.</p> <p>The result of that is then serialized and returned as a lua value that has the same shape as the <code>PARAMS</code> defined for kumo.make_egress_source.</p> <p>This function may be satisfied by the internal cache of resolved source configuration information, so it may not directly trigger the <code>get_egress_source</code> callback every time that it is called.</p> <p>Danger</p> <p>Take care when using this function and its related <code>invoke_xxx</code> functions, as you can potentially create cross-dependent, mututally recursive, event callbacks that call into each other.</p>"},{"location":"reference/kumo/invoke_get_queue_config/","title":"kumo.invoke_get_queue_config","text":"<pre><code>local config = kumo.invoke_get_queue_config(queue_name)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>This function triggers a call through to the get_queue_config event callback(s) that have been defined in the policy to obtain the effective configuration for the specified <code>queue_name</code>.</p> <p>The result of that is then serialized and returned as a lua value that has the same shape as the <code>PARAMS</code> defined for kumo.make_queue_config.</p> <p>Danger</p> <p>Take care when using this function and its related <code>invoke_xxx</code> functions, as you can potentially create cross-dependent, mututally recursive, event callbacks that call into each other.</p>"},{"location":"reference/kumo/json_encode/","title":"kumo.json_encode","text":"<pre><code>kumo.json_encode(VALUE)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Attempts to encode VALUE as its JSON equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.json_parse.</p> <p>See also kumo.json_load, kumo.json_parse and kumo.json_encode_pretty</p>"},{"location":"reference/kumo/json_encode_pretty/","title":"kumo.json_encode_pretty","text":"<pre><code>kumo.json_encode_pretty(VALUE)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Attempts to encode VALUE as its JSON equivalent, and returns that value serialized as a string, using pretty, more human readable representation.</p> <p>This is logically the opposite of kumo.json_parse.</p> <p>See also kumo.json_load, kumo.json_parse and kumo.json_encode</p>"},{"location":"reference/kumo/json_load/","title":"kumo.json_load","text":"<pre><code>kumo.json_load(FILENAME)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Reads the content of the file name <code>FILENAME</code> and parses it as JSON, returning a lua representation of the parsed JSON.</p> <p>This json loading implementation will accept C style block comments, C++ style single line comments and shell style single line comments.  Comments will be treated as though they were spaces prior to being parsed by the underlying json parser.</p> <p>See also kumo.json_parse, kumo.json_encode and kumo.json_encode_pretty</p>"},{"location":"reference/kumo/json_parse/","title":"kumo.json_parse","text":"<pre><code>kumo.json_parse(STRING)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Parses STRING as JSON, returning a lua representation of the parsed JSON.</p> <p>This json parsing implementation will accept C style block comments, C++ style single line comments and shell style single line comments.  Comments will be treated as though they were spaces prior to being parsed by the underlying json parser.</p> <p>This is logically the opposite of kumo.json_encode.</p> <p>See also kumo.json_load, kumo.json_encode and kumo.json_encode_pretty</p>"},{"location":"reference/kumo/log_debug/","title":"kumo.log_debug","text":"<pre><code>kumo.log_debug(ARGS)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Logs the series of <code>ARGS</code> to the diagnostic log at <code>DEBUG</code> level. This works similarly to the <code>print</code> function except that it is routed via the diagnostic logging system, which might be set to filter out the event via the set_diagnostic_log_filter.</p> <p>Note</p> <p>DEBUG is not included in the default diagnostic filter. You will need to explicitly add <code>lua=DEBUG</code> to your diagnostic filter in order to see <code>kumo.log_debug</code> diagnostics.</p> <p>The purpose of this function is to log meaningful information from your policy scripts for diagnostic purposes.</p> <pre><code>-- I am a file named unix.lua\n-- The next line is line number 3\nkumo.log_debug('Logging something', true, false, 42, { 1, 2, 3 })\n</code></pre> <p>Will produce something like this in your diagnostic log, but only if you have enabled <code>lua=DEBUG</code> in your diagnostic filter:</p> <pre><code>2025-03-07T00:08:20.071516Z DEBUG  main lua: ./unix.lua:3: Logging something true false 42 table: 0x7199e11bda40\n</code></pre> <p>The <code>main</code> string there is the thread name. You can see that the calling source file and line number are automatically included in the diagnostic record.  The arguments are converted to strings via the equivalent of the lua <code>tostring()</code> function and output as part of the diagnostic.</p>","tags":["logging","debugging"]},{"location":"reference/kumo/log_error/","title":"kumo.log_error","text":"<pre><code>kumo.log_error(ARGS)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Logs the series of <code>ARGS</code> to the diagnostic log at <code>ERROR</code> level. This works similarly to the <code>print</code> function except that it is routed via the diagnostic logging system, which might be set to filter out the event via the set_diagnostic_log_filter.</p> <p>The purpose of this function is to log meaningful information from your policy scripts for diagnostic purposes.</p> <pre><code>-- I am a file named unix.lua\n-- The next line is line number 3\nkumo.log_error('Logging something', true, false, 42, { 1, 2, 3 })\n</code></pre> <p>Will produce something like this in your diagnostic log:</p> <pre><code>2025-03-07T00:08:20.071516Z ERROR main lua: ./unix.lua:3: Logging something true false 42 table: 0x7199e11bda40\n</code></pre> <p>The <code>main</code> string there is the thread name. You can see that the calling source file and line number are automatically included in the diagnostic record.  The arguments are converted to strings via the equivalent of the lua <code>tostring()</code> function and output as part of the diagnostic.</p>","tags":["logging","debugging"]},{"location":"reference/kumo/log_info/","title":"kumo.log_info","text":"<pre><code>kumo.log_info(ARGS)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Logs the series of <code>ARGS</code> to the diagnostic log at <code>INFO</code> level. This works similarly to the <code>print</code> function except that it is routed via the diagnostic logging system, which might be set to filter out the event via the set_diagnostic_log_filter.</p> <p>The purpose of this function is to log meaningful information from your policy scripts for diagnostic purposes.</p> <pre><code>-- I am a file named unix.lua\n-- The next line is line number 3\nkumo.log_info('Logging something', true, false, 42, { 1, 2, 3 })\n</code></pre> <p>Will produce something like this in your diagnostic log:</p> <pre><code>2025-03-07T00:08:20.071516Z INFO  main lua: ./unix.lua:3: Logging something true false 42 table: 0x7199e11bda40\n</code></pre> <p>The <code>main</code> string there is the thread name. You can see that the calling source file and line number are automatically included in the diagnostic record.  The arguments are converted to strings via the equivalent of the lua <code>tostring()</code> function and output as part of the diagnostic.</p>","tags":["logging","debugging"]},{"location":"reference/kumo/log_warn/","title":"kumo.log_warn","text":"<pre><code>kumo.log_warn(ARGS)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Logs the series of <code>ARGS</code> to the diagnostic log at <code>WARN</code> level. This works similarly to the <code>print</code> function except that it is routed via the diagnostic logging system, which might be set to filter out the event via the set_diagnostic_log_filter.</p> <p>The purpose of this function is to log meaningful information from your policy scripts for diagnostic purposes.</p> <pre><code>-- I am a file named unix.lua\n-- The next line is line number 3\nkumo.log_warn('Logging something', true, false, 42, { 1, 2, 3 })\n</code></pre> <p>Will produce something like this in your diagnostic log:</p> <pre><code>2025-03-07T00:08:20.071516Z WARN  main lua: ./unix.lua:3: Logging something true false 42 table: 0x7199e11bda40\n</code></pre> <p>The <code>main</code> string there is the thread name. You can see that the calling source file and line number are automatically included in the diagnostic record.  The arguments are converted to strings via the equivalent of the lua <code>tostring()</code> function and output as part of the diagnostic.</p>","tags":["logging","debugging"]},{"location":"reference/kumo/make_message/","title":"kumo.make_message","text":"<pre><code>MSG = kumo.make_message(SENDER, RECIPIENT, BODY)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new Message object with the specified <code>SENDER</code>, <code>RECIPIENT</code> and <code>BODY</code>.</p> <p><code>make_message</code> was created (in earlier versions of kumomta) primarily for testing purposes, but is now provided for use together with kumo.inject_message to facilitate more advanced workflows.</p> <p><code>SENDER</code> is expected to be the envelope-from address.</p> <p><code>RECIPIENT</code> is expected to be the envelope-to address.</p> <p><code>BODY</code> is expected to be the appropriately formatted body payload; this is usually a MIME message.  The body should be formatted using canonical CRLF line endings.</p> <p>The message created by <code>make_message</code> exists solely in memory until you explicitly indicate that you want something to happen to it.  If you intend for kumomta to deliver the message, you should call kumo.inject_message to enqueue the message for delivery.</p>","tags":["message"]},{"location":"reference/kumo/make_throttle/","title":"kumo.make_throttle","text":"<pre><code>kumo.make_throttle(NAME, SPEC)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Constructs and returns a named throttle object.  A throttle allows constraining the rate at which an operation can occur, according to a Generic Cell Rate Algorithm.</p> <p>When used together with kumo.configure.redis_throttles(), multiple nodes can contribute to and respect a limit configured across a cluster.</p> <p>The name parameter is an arbitrary name that can be used to define the purpose and scope of a throttle.  For example, you might define the purpose as <code>throttle-ready-queue</code> and the scope to be a particular tenant.  In that case you might generate a name like <code>throttle-ready-queue-TENANT_NAME</code>.  Multiple throttle objects with the same name will increment and check the same underlying throttle; the name parameter defines the throttle.</p> <p>The spec parameter defines the permitted rate of the throttle, and has the form:</p> <pre><code>[local:]quantity/period[,max_burst=burst]\n</code></pre> <p>where quantity is a number and period can be a measure of time.</p> <ul> <li> <p>The optional <code>local:</code> prefix will cause this throttle to always   use a node-local throttle, regardless of whether redis throttles   have been enabled.  (Since: Version 2024.11.08-d383b033)</p> </li> <li> <p>The quantity must be an integer value that defines the limit   of operations that can be performed in the specified period.   Quantity can optionally use <code>,</code> or <code>_</code> as a digit separator   to help clarify large numbers.</p> </li> <li> <p>The period may be one of:</p> <ul> <li><code>day</code> or <code>d</code> to represent 1 day (<code>86400</code> seconds)</li> <li><code>hour</code>, <code>hr</code> or <code>h</code> to represent 1 hour (<code>3600</code> seconds)</li> <li><code>minute</code>, <code>min</code>, or <code>m</code> to represent 1 minute (<code>60</code> seconds)</li> <li><code>seconds</code>, <code>sec</code>, or <code>s</code> to represent 1 second</li> </ul> </li> <li> <p>The period may have an integer prefix to specify unusual   time periods, such as <code>30min</code> to represent a 30 minute period.   (Since: Version 2025.01.23-7273d2bc)</p> </li> <li> <p>The optional max_burst term allows control over how quickly the throttle   can be consumed. If you don't specify max_burst, it is effectively equal to   the quantity.  If you have configured <code>6/m</code> as your throttle, and 6   requests are immediately ready, then all 6 of them can proceed at the start   of that one minute interval.  If you set <code>6/m,max_burst=1</code> then the rate at   which they can proceed will be 1 every 10 seconds (interval = period /   quantity, so: <code>60/6 == 10</code>) across that minute.  Larger burst values will   allow larger bursts across that time period. (Since: Version 2025.01.29-833f82a8)</p> </li> </ul> <p>Examples of throttles:</p> <pre><code>\"10/s\" -- 10 per second\n\"10/sec\" -- 10 per second\n\"10/second\" -- 10 per second\n\"local:10/second\" -- 10 per second, always local regardless of redis config\n\n\"50/m\" -- 50 per minute\n\"50/min\" -- 50 per minute\n\"50/minute\" -- 50 per minute\n\"50/minute\" -- 50 per minute\n\"60/minute,max_burst=1\" -- 60 per minute, constrained to 1 per second\n\"20/30minute\" -- 20 per 30 minute period\n\n\"1,000/hr\" -- 1000 per hour\n\"1_000/h\" -- 1000 per hour\n\"1000/hour\" -- 1000 per hour\n\n\"10_000/d\" -- 10,000 per day\n\"10,000/day\" -- 10,000 per day\n</code></pre> <p>The returned throttle object has the following methods:</p>"},{"location":"reference/kumo/make_throttle/#throttlesleep_if_throttled","title":"throttle:sleep_if_throttled()","text":"<p>Checks to see if an operation can proceed, incrementing and sleeping the current action until the operation can proceed.</p> <p>Returns a boolean value to indicate whether the action was throttled; if it returns <code>true</code> then it was throttled and a delay was applied.</p> <p>This is useful for example when throttling the reception rate. In the example below, the incoming SMTP session is paused during <code>MAIL FROM</code> until the message is permitted by two sets of throttles, and then allowed to continue:</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  -- Limit reception rate to 50/minute per unique sender\n  local throttle = kumo.make_throttle(\n    string.format('reception-rate-for-%s', sender),\n    '50/minute'\n  )\n  throttle:sleep_if_throttled()\n\n  -- Additionally, limit reception rate to 100/minute, regardless of the sender\n  local throttle = kumo.make_throttle('reception-rate', '100/minute')\n  throttle:sleep_if_throttled()\nend)\n</code></pre>"},{"location":"reference/kumo/make_throttle/#throttledelay_message_if_throttledmsg","title":"throttle:delay_message_if_throttled(msg)","text":"<p>This method is intended to be used in the throttle_insert_ready_queue event.</p> <p>It will evaluate the throttle, and if a delay is required, update the due time on the message to reflect that.</p> <pre><code>kumo.on('throttle_insert_ready_queue', function(msg)\n  -- limit each tenant to 1000/hr\n  local tenant = msg:get_meta 'tenant'\n  local throttle = kumo.make_throttle(\n    string.format('tenant-send-limit-%s', tenant),\n    '1000/hr'\n  )\n  throttle:delay_message_if_throttled(msg)\nend)\n</code></pre>"},{"location":"reference/kumo/make_throttle/#throttlethrottle","title":"throttle:throttle()","text":"<p>Checks to see if an operation can proceed, and increments the count if it is permitted. The returned value indicates the outcome and returns a table with the following fields:</p> <ul> <li><code>throttled</code> - a boolean that indicates whether the operation was throttled or   allowed. If <code>true</code>, the operation was throttled and should not be permitted   to proceed.</li> <li><code>limit</code> - The total limit of this particular named throttle. Equivalent to the   <code>X-RateLimit-Limit</code> HTTP header that might be returned in various web services   that implement throttling.</li> <li><code>remaining</code> - the remaining limit of this particular named throttle. Equivalent to the   <code>X-RateLimit-Remaining</code> HTTP header that might be returned in various web services   that implement throttling.</li> <li><code>reset_after</code> - the remaining duration until the limit will reset to its maximum capacity.   Equivalent to the <code>X-RateLimit-Reset</code> HTTP that might be returned in various web   services that implement throttling.</li> <li><code>retry_after</code> - the time until the operation should be retried, or <code>nil</code> if   the action was allowed.</li> </ul> <p>This can be used to implement alternative strategies for the throttle delay. For example, if you want to issue a generic transient failure when the limit is exceeded you might do something like the following:</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  -- Limit reception rate to 50/minute per unique sender\n  local throttle = kumo.make_throttle(\n    string.format('reception-rate-for-%s', sender),\n    '50/minute'\n  )\n  local result = throttle:throttle()\n  if result.throttled then\n    kumo.reject(451, '4.4.5 try again later')\n  end\nend)\n</code></pre>"},{"location":"reference/kumo/memoize/","title":"kumo.memoize","text":"<pre><code>kumo.memoize(FUNCTION, { PARAMS })\n</code></pre> <p>This function allows you to create functions that cache the result of a computation.  This technique is known as Memoization.</p> <p>Here's a simple example; we have a sqlite lookup database that we intend to use for authentication, and we have already defined a helper function for that:</p> <pre><code>local sqlite = require 'sqlite'\n\n-- Consult a hypothetical sqlite database that has an auth table\n-- with user and pass fields\nfunction sqlite_auth_check(user, password)\n  local db = sqlite.open '/path/to/auth.db'\n  local result = db:execute(\n    'select user from auth where user=? and pass=?',\n    user,\n    password\n  )\n  -- if we return the username, it is because the password matched\n  return result[1] == user\nend\n\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\n  return sqlite_auth_check(authc, password)\nend)\n</code></pre> <p>Let's say, for the sake of example, that the query is very expensive: perhaps the IO cost is high and the query rate is also high and we want to save the iops for other work in the system.</p> <p>It would be nice if we could cache the lookup for some period of time. We can use <code>kumo.memoize</code> for this:</p> <pre><code>local sqlite = require 'sqlite'\n\nfunction sqlite_auth_check(user, password)\n  local db = sqlite.open '/tmp/auth.db'\n  local result = db:execute(\n    'select user from auth where user=? and pass=?',\n    user,\n    password\n  )\n  -- if we return the username, it is because the password matched\n  return result[1] == user\nend\n\n-- This creates a new function called `cached_sqlite_auth_check`\n-- that remembers the results for a given set of parameters for up\n-- to 5 minutes or up to 100 different sets of parameters\ncached_sqlite_auth_check = kumo.memoize(sqlite_auth_check, {\n  name = 'sqlite_auth',\n  ttl = '5 minutes',\n  capacity = 100,\n})\n\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\n  return cached_sqlite_auth_check(authc, password)\nend)\n</code></pre> <p><code>kumo.memoize</code> takes a function or a lambda and wraps it up with some logic that will internally cache the result for the same set of parameters, and returns a new function that encodes that caching logic.  The return value is the memoized function.</p> <p>The parameters it accepts are:</p> <ul> <li>FUNCTION - the function or lambda which will be called when there is a cache miss.   When it is called, it will be passed the parameters that were passed to the memoized function in order to populate the cache.</li> <li>PARAMS is a required lua table with the following fields, all of which are required:<ul> <li><code>name</code> - the name for the cache. You should create one name per function/purpose.</li> <li><code>ttl</code> - the Time To Live for cache entries; how long a previously computed    value should remain valid.  The duration is expressed as a string like <code>5    minutes</code> or <code>10 seconds</code>.</li> <li><code>capacity</code> - the total number of results to retain in the cache. When a new    entry needs to be inserted, if the cache is at capacity, the eldest entry    will be evicted to make space.</li> <li><code>invalidate_with_epoch</code> - optional boolean that defaults to <code>false</code>.    If true, anything that bumps the config epoch (eg: config file changes,    TSA config overrides and so on) will invalidate the cache. (Since: Version 2025.03.19-1d3f1f67)</li> <li><code>populate_timeout</code> - optional duration string. The effective default    value is <code>120 seconds</code>.  Specifies how long to allow the cache population    function to run before generating a timeout error. (Since: Version 2025.05.06-b29689af)</li> <li><code>retry_on_populate_timeout</code> - optional boolean that defaults to <code>false</code>.    If <code>true</code>, if the <code>populate_timeout</code> is reached, then instead of generating    an error, memoize will retry the population attempt.    (Since: Version 2025.05.06-b29689af)</li> <li><code>allow_stale_reads</code> - optional boolean that defaults to <code>false</code>.  If    <code>true</code> then <code>invalidate_with_epoch</code> will be assumed to <code>false</code> and a    cache lookup will be allowed to return with the last populated value in    the case that the item has expired and the cache population takes longer    than the <code>populate_timeout</code>. (Since: Version 2025.05.06-b29689af)</li> </ul> </li> </ul> <p>In the example above calling:</p> <pre><code>cached_sqlite_auth_check('daniel', 'tiger')\n</code></pre> <p>the first time would be a cache miss, because no calls have yet been made with <code>{'daniel', 'tiger'}</code> as parameters, so the memoized function would internally call:</p> <pre><code>sqlite_auth_check('daniel', 'tiger')\n</code></pre> <p>The next time that <code>cached_sqlite_auth_check('daniel', 'tiger')</code> is called there is a cache hit and the previously computed result would be returned, provided that 5 minutes have not expired since the first call.</p> <p>When the value expires, another call to <code>sqlite_auth_check('daniel', 'tiger')</code> will be made to determine the value.</p>"},{"location":"reference/kumo/on/","title":"kumo.on","text":"<pre><code>kumo.on(EVENT, FUNCTION)\n</code></pre> <p>Register a handler for a named event.</p> <p><code>EVENT</code> can be any string, and <code>FUNCTION</code> can be any lua function or closure.</p> <p>Only the most recently registered function for a given event will be used.</p> <p>The possible events are listed in the events reference.</p>"},{"location":"reference/kumo/read_dir/","title":"kumo.read_dir","text":"<pre><code>kumo.read_dir(path)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>This function is deprecated in favor of kumo.fs.read_dir.</p> <p>This function returns an array containing the absolute file names of the directory specified.  Due to limitations in the lua bindings, all of the paths must be able to be represented as UTF-8 or this function will generate an error.</p> <pre><code>local kumo = require 'kumo'\n\n-- logs the names of all of the entries under `/etc`\nprint(kumo.json_encode_pretty(kumo.read_dir '/etc'))\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo/reject/","title":"kumo.reject","text":"<pre><code>kumo.reject(CODE, MESSAGE)\n</code></pre> <p>Calling <code>kumo.reject</code> will raise a lua error that will cause the current ESMTP event to respond with the SMTP error code and message that you specify.</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\n  kumo.reject(420, 'rejecting all mail, just because')\n  -- this line is not reached\nend)\n</code></pre>"},{"location":"reference/kumo/set_config_monitor_globs/","title":"kumo.set_config_monitor_globs","text":"<pre><code>kumo.set_config_monitor_globs(GLOBS)\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>GLOBS is an array-style table listing out the set of glob expressions which should be monitored as part of the Configuration Monitoring system.</p> <p>The effective default is as though you had this code in your policy file:</p> <pre><code>kumo.on('init', function()\n  kumo.set_config_monitor_globs {\n    '/opt/kumomta/etc/**/*.{lua,json,toml,yaml}',\n  }\nend)\n</code></pre> <p>You can specify multiple globs as makes sense for your deployment.</p>"},{"location":"reference/kumo/set_diagnostic_log_filter/","title":"kumo.set_diagnostic_log_filter","text":"<pre><code>kumo.set_diagnostic_log_filter(FILTER)\n</code></pre> <p>Changes the filtering configuration for the diagnostic log.</p> <p>KumoMTA uses the tracing-subscriber Rust crate to provide diagnostic logging.  This can be configured via the <code>KUMOD_LOG</code> environment to set the logging for the process when it first starts up, but can also be adjusted via your policy file by calling <code>kumo.set_diagnostic_log_filter</code> if you wish.</p> <p>The default log filter that is set at startup is <code>kumod=info</code> which causes all informational logging from the <code>kumod</code> crate (the main KumoMTA server process) to be logged.</p> <p>If you want more verbose diagnostics, you might consider changing it from inside your <code>init</code> event handler:</p> <pre><code>kumo.on('init', function()\n  kumo.set_diagnostic_log_filter 'kumod=debug'\nend)\n</code></pre> <p>The filter syntax is quite powerful, allowing you set different levels for different crates.  The full set of filter directives are explained here.</p>","tags":["logging","debugging"]},{"location":"reference/kumo/set_httpinject_recipient_rate_limit/","title":"kumo.set_httpinject_recipient_rate_limit","text":"<pre><code>kumo.set_httpinject_recipient_rate_limit(SPEC)\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Configures an optional throttle for the HTTP injection API. The SPEC parameter may be <code>nil</code> to clear the rate limit, or be a throttle specification as described in kumo.make_throttle.</p> <p>It is recommended that you configure this in the <code>pre_init</code> event, which triggers prior to the <code>init</code> event where you start up your http listeners:</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_httpinject_recipient_rate_limit 'local:10,000/s'\nend)\n</code></pre> <p>The effect of setting the rate limit is that, for an incoming HTTP injection request, the number of recipients in the request is assessed against the throttle, and the request is put to sleep until the throttle will admit that number of recipients.</p> <p>It applies across any and all HTTP listeners that have been defined.</p> <p>This can therefore be used to set the upper bound on the HTTP injection rate.</p> <p>This limit does not apply to kumo.api.inject.inject_v1.</p>"},{"location":"reference/kumo/set_httpinject_threads/","title":"kumo.set_httpinject_threads","text":"<pre><code>kumo.set_httpinject_threads(N)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the httpinject thread pool. This thread pool is used to process http injection requests.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_httpinject_threads(12)\nend)\n</code></pre>","tags":["threadpool"]},{"location":"reference/kumo/set_logging_threads/","title":"kumo.set_logging_threads","text":"<pre><code>kumo.set_logging_threads(N)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the logging thread pool. This thread pool is used to process logging.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_logging_threads(12)\nend)\n</code></pre>","tags":["threadpool"]},{"location":"reference/kumo/set_lruttl_cache_capacity/","title":"kumo.set_lruttl_cache_capacity","text":"<pre><code>kumo.set_lruttl_cache_capacity(NAME, CAPACITY)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Allows you to configure the maximum capacity for a specific named pre-defined cache.</p> <p>You may only update the capacity for caches defined inside kumomta's Rust code via <code>declare_cache!</code>.  Other caches are assumed to be dynamically created and expose their capacity as part of their own individual configuration.</p> <pre><code>kumo.on('pre_init', function()\n  -- Increase the mx cache size from its default of 64*1024 to 128,000\n  kumo.set_lruttl_cache_capacity('dns_resolver_mx', 128000)\nend)\n</code></pre> <p>Note</p> <p>This function is intended to be used in <code>pre_init</code>, but it can be called at any time.  Reducing the capacity while the cache holds data will trigger a partial eviction.  The cache will eventually shrink to conform to the new size as the cache is operated upon and background processing trims the cache.</p>"},{"location":"reference/kumo/set_lruttl_cache_capacity/#tuning","title":"Tuning","text":"<p>The current cache utilization is reported via the lruttl_cache_size metric.</p> <p>If your charts show that this value is flat and matches the cache capacity, and the rate of eviction indicated by the rate of change of lruttl_evict_count is high, it may indicate that the cache is being thrashed and that increasing the cache capacity could have a beneficial effect.</p> <p>Whether it will depends on the cache and the nature of the traffic; certain caches may be expected to have a low hit rate on high cardinality and highly variant data.  Increasing the cache size for those wouldn't have much benefit and may just be a waste of RAM.</p>"},{"location":"reference/kumo/set_lruttl_cache_capacity/#pre-defined-caches","title":"Pre-defined Caches","text":"<p>Below is a list of pre-defined caches and their default capacities in the <code>main</code> branch.  The list is automatically extracted from the code during the documentation build, unversioned and may not reflect the version of KumoMTA that you are running.</p> Name Capacity Comment acl_check 128 acl_definition 128 dkim_key_cache 1024 Caches dkim loaded signing keys based on their KeySource spec dkim_signer_cache 1024 Caches dkim signer specs to signer objects dns_resolver_ip 1024 Caches domain name to the combined set of ipv4 and ipv6 records dns_resolver_ipv4 1024 Caches domain name to ipv4 records dns_resolver_ipv6 1024 Caches domain name to ipv6 records dns_resolver_mx 65536 Caches domain name to computed set of MailExchanger records egress_source_pools 128 Caches EgressPool information by pool name egress_source_sources 128 Caches EgressSource information by source name http_server_auth 128 Caches the results of the http server auth validation by auth credential mod_filesystem_glob_cache 32 Caches glob results by glob pattern mta_sts_policy 65536 Caches MTA-STS policy information by domain rustls_client_config 32 Caches TLS connector information for the RFC5321 SMTP client smtp_dispatcher_broken_tls 65536 Remembers which site names have broken TLS smtp_dispatcher_client_certificate 1024 Caches smtp client certificates by KeySource spec smtp_server_tls_config 128 Caches TLS acceptor information for the esmtp listener"},{"location":"reference/kumo/set_max_lua_context_age/","title":"kumo.set_max_lua_context_age","text":"<pre><code>kumo.set_max_lua_context_age(seconds)\n</code></pre> <p>KumoMTA maintains a pool of lua contexts so that the overhead of evaluating lua for any given event handler is reduced.</p> <p>This function allows you to change the maximum age of any given context, measured in seconds, before discarding it.</p> <p>The default value is <code>300</code> (5 minutes).</p> <p>Making it larger increases the potential for cache hits (and thus lower latency), but increases the potential for increased memory usage.</p> <p>See also set_max_lua_context_use_count, set_max_spare_lua_contexts</p>"},{"location":"reference/kumo/set_max_lua_context_use_count/","title":"kumo.set_max_lua_context_use_count","text":"<pre><code>kumo.set_max_lua_context_use_count(limit)\n</code></pre> <p>KumoMTA maintains a pool of lua contexts so that the overhead of evaluating lua for any given event handler is reduced.</p> <p>This function allows you to change the maximum number of times that any given context will be used before discarding it.</p> <p>The default value is <code>1024</code>.</p> <p>Making it larger increases the potential for cache hits (and thus lower latency), but increases the potential for increased memory usage.</p> <p>See also set_max_lua_context_age, set_max_spare_lua_contexts</p>"},{"location":"reference/kumo/set_max_spare_lua_contexts/","title":"kumo.set_max_spare_lua_contexts","text":"<pre><code>kumo.set_max_spare_lua_contexts(limit)\n</code></pre> <p>KumoMTA maintains a pool of lua contexts so that the overhead of evaluating lua for any given event handler is reduced.</p> <p>This function allows you to change the maximum capacity of that pool.</p> <p>The default value is <code>8192</code>.</p> <p>Make it smaller reduces the amount of memory used while idle, at the cost of increased latency when the server becomes busy.</p> <p>See also set_max_lua_context_use_count, set_max_lua_context_age.</p>"},{"location":"reference/kumo/set_memory_hard_limit/","title":"kumo.set_memory_hard_limit","text":"<pre><code>kumo.set_memory_hard_limit(LIMIT)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Set the hard limit for memory utilization. This defaults to the amount of physical RAM in the system.</p> <p>You typically do not need to modify this value.</p> <p>See Memory Management for a discussion on how kumomta manages memory usage.</p> <p>It is recommend to set this during the <code>pre_init</code> event.</p> <p>The <code>LIMIT</code> is expressed as an integer number of bytes.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_memory_hard_limit(2 * 1024 * 1024 * 1024)\nend)\n</code></pre>","tags":["memory"]},{"location":"reference/kumo/set_memory_low_thresh/","title":"kumo.set_memory_low_thresh","text":"<pre><code>kumo.set_memory_low_thresh(THRESH)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Set the low memory threshold. This usually defaults to 60% of amount of physical RAM in the system (actually 80% of the soft limit which happens to be 75% of the physical RAM), but ulimit or cgroup constraints may modify the value.</p> <p>When the system is using more than the low memory threshold, passive memory reduction measures will be enabled, including releasing message data when messages move between queues.</p> <p>You might want to modify this value if you have a lot of RAM and want the passive reduction measures to kick in when more of it is in use than the defaults would otherwise allow.</p> <p>See Memory Management for a discussion on how kumomta manages memory usage.</p> <p>It is recommend to set this during the <code>pre_init</code> event.</p> <p>The <code>THRESH</code> is expressed as an integer number of bytes.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_memory_low_thresh(800 * 1024 * 1024)\nend)\n</code></pre>","tags":["memory"]},{"location":"reference/kumo/set_memory_soft_limit/","title":"kumo.set_memory_soft_limit","text":"<pre><code>kumo.set_memory_soft_limit(LIMIT)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Set the soft limit for memory utilization. This usually defaults to 75% of amount of physical RAM in the system, but ulimit or cgroup constraints may modify the value.</p> <p>When the system is using more than the soft limit, incoming traffic will be turned away and various other memory reduction measures will be enabled until the memory usage falls below the soft limit.</p> <p>You might want to modify this value if you have a lot of RAM and want to use more than 75% of it in the common case.</p> <p>See Memory Management for a discussion on how kumomta manages memory usage.</p> <p>It is recommend to set this during the <code>pre_init</code> event.</p> <p>The <code>LIMIT</code> is expressed as an integer number of bytes.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_memory_soft_limit(1024 * 1024 * 1024)\nend)\n</code></pre>","tags":["memory"]},{"location":"reference/kumo/set_qmaint_threads/","title":"kumo.set_qmaint_threads","text":"<pre><code>kumo.set_qmaint_threads(N)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the qmaint thread pool. This thread pool is used to perform queue maintenance operations.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_qmaint_threads(12)\nend)\n</code></pre> <p>Note</p> <p>The <code>qmaint</code> used to perform maintenance of a mixture of both scheduled and ready queue tasks, but now is used only for scheduled queue maintenance. The ready queue maintenance is carried out by the <code>ready_qmaint</code> thread pool. (Since: Version 2025.05.06-b29689af)</p>","tags":["threadpool"]},{"location":"reference/kumo/set_ready_qmaint_threads/","title":"kumo.set_ready_qmaint_threads","text":"<pre><code>kumo.set_ready_qmaint_threads(N)\n</code></pre> Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the <code>readyq_maint</code> thread pool. This thread pool is used to perform ready queue maintenance operations.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_ready_qmaint_threads(12)\nend)\n</code></pre>","tags":["threadpool"]},{"location":"reference/kumo/set_readyq_threads/","title":"kumo.set_readyq_threads","text":"<pre><code>kumo.set_readyq_threads(N)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the readyq thread pool. This thread pool is used to perform ready queue maintenance operations.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_readyq_threads(12)\nend)\n</code></pre>","tags":["threadpool"]},{"location":"reference/kumo/set_smtpsrv_threads/","title":"kumo.set_smtpsrv_threads","text":"<pre><code>kumo.set_smtpsrv_threads(N)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the smtpsrv thread pool. This thread pool is used to process incoming smtp sessions.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_smtpsrv_threads(12)\nend)\n</code></pre>","tags":["threadpool"]},{"location":"reference/kumo/set_spoolin_threads/","title":"kumo.set_spoolin_threads","text":"<pre><code>kumo.set_spoolin_threads(N)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the spoolin thread pool. This thread pool is used to process spool enumeration during startup.</p> <p>The default number of threads is computed using some unspecified fraction of the available parallelism on the running system, and is shown in the journal on startup.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.set_spoolin_threads(12)\nend)\n</code></pre>","tags":["threadpool"]},{"location":"reference/kumo/sleep/","title":"kumo.sleep","text":"<pre><code>kumo.sleep(SECONDS)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.time module and will be removed in a future release. (Since: Version 2025.01.23-7273d2bc)</p> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Sleeps the current task for the specified number of seconds. The value can be either an integer or a floating point value, the latter can be used to specify fractional duration values.</p>"},{"location":"reference/kumo/spawn_task/","title":"kumo.spawn_task","text":"<pre><code>kumo.spawn_task { PARAMS }\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Warning</p> <p>This function should be called only from inside your init event handler.</p> <p>This function will spawn a new thread that will trigger the specified event and run it, allowing you to set up background tasks.</p> <p><code>PARAMS</code> is a lua table style object with the following fields:</p> <ul> <li><code>event_name</code> - the name of the event which should be triggered in   the new thread. You must register an event handler for this event   using kumo.on.</li> <li><code>args</code> - an optional value that is passed to the event handler.   You can use this to pass arguments to the event handler, which is   useful in the case where you want to perform the same basic function   in a task, but with varying parameters.</li> </ul> <pre><code>kumo.on('init', function()\n  kumo.spawn_task {\n    event_name = 'my.task',\n    args = { 'hello', 'there' },\n  }\nend)\n\nkumo.on('my.task', function(args)\n  -- Prints: `I am the task.  [\"hello\",\"there\"]`\n  print('I am the task.', kumo.json_encode(args))\nend)\n</code></pre> <p>Note</p> <p>If your task event handler raises an error, it will be logged and the task will stop. It is your responsibility to handle errors to ensure that your task remains running.  You can use the lua <code>pcall</code> function to trap errors and react accordingly.</p>"},{"location":"reference/kumo/toml_encode/","title":"kumo.toml_encode","text":"<pre><code>kumo.toml_encode(VALUE)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Attempts to encode VALUE as its TOML equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.toml_parse.</p> <p>See also kumo.toml_load, kumo.toml_parse and kumo.toml_encode_pretty</p>"},{"location":"reference/kumo/toml_encode_pretty/","title":"kumo.toml_encode_pretty","text":"<pre><code>kumo.toml_encode_pretty(VALUE)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Attempts to encode VALUE as its TOML equivalent, and returns that value serialized as a string, using pretty, more human readable representation.</p> <p>This is logically the opposite of kumo.toml_parse.</p> <p>See also kumo.toml_load, kumo.toml_parse and kumo.toml_encode</p>"},{"location":"reference/kumo/toml_load/","title":"kumo.toml_load","text":"<pre><code>kumo.toml_load(FILENAME)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Reads the content of the file name <code>FILENAME</code> and parses it as TOML, returning a lua representation of the parsed TOML.</p> <p>See also kumo.toml_parse, kumo.toml_encode and kumo.toml_encode_pretty</p>"},{"location":"reference/kumo/toml_parse/","title":"kumo.toml_parse","text":"<pre><code>kumo.toml_parse(STRING)\n</code></pre> <p>Warning</p> <p>This function has moved to the kumo.serde module and will be removed in a future release. (Since: Version 2024.09.02-c5476b89)</p> <p>Parses STRING as TOML, returning a lua representation of the parsed TOML.</p> <p>This is logically the opposite of kumo.toml_encode.</p> <p>See also kumo.toml_load, kumo.toml_encode and kumo.toml_encode_pretty</p>"},{"location":"reference/kumo/uncached_glob/","title":"kumo.uncached_glob","text":"<pre><code>kumo.uncached_glob(pattern [, relative_to])\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Warning</p> <p>This function can cause an expensive filesystem walk to occur, especially if used on a storage volume that is experiencing IO pressure (such as from spooling or logging). You probably should use the implicitly cached glob function instead of this one. If you must use this one, then it is strongly advised that you avoid calling it from the file-level scope of your policy scripts in order to avoid unconditionally triggering the walk on every lua context construction.</p> <p>This function evalutes the glob <code>pattern</code> and returns an array containing the absolute file names of the matching results.  Due to limitations in the lua bindings, all of the paths must be able to be represented as UTF-8 or this function will generate an error.</p> <p>The optional <code>relative_to</code> parameter can be used to make the results relative to a path.  If the results have the same prefix as <code>relative_to</code> then it will be removed from the returned path. The default for for this parameter is <code>.</code>.</p> <p>Note</p> <p>If the specified pattern or path references a directory that doesn't exist, or a directory that is inaccessible to the kumo user, no error will be generated; those paths are silently omitted from the results.</p> <pre><code>local kumo = require 'kumo'\n\n-- logs the names of all of the '*.conf' files under `/etc`\nprint(kumo.json_encode_pretty(kumo.uncached_glob '/etc/*.conf'))\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo/version/","title":"kumo.version","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This constant is set to the kumo version string that is also reported by running <code>kumod --version</code>. This can potentially be used to adjust configuration according to the installed/running version.</p> <p>The version string looks like <code>2025.11.09-d4028f99</code>. You can compare the strings lexicographically if you wish to test whether a given version is newer than another; the first component is the date on which the release was made, the second component component is a git hash.</p> <pre><code>print(kumo.version)\n-- prints something like: 2025.11.09-d4028f99\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/","title":"kumo.configure_local_logs","text":"<pre><code>kumo.configure_local_logs { PARAMS }\n</code></pre> <p>Enables local logging of reception and delivery events to the specified <code>log_dir</code> directory.</p> <p>Logs are written as zstd-compressed log file segments under the specified directory.  Each line of the file is a JSON object holding information about a reception or delivery related event.  The format of the Log Record object can be found here.</p> <p>This function should be called only from inside your init event handler.</p> <pre><code>kumo.on('init', function()\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumo-logs',\n  }\nend)\n</code></pre> <p>PARAMS is a lua table that can accept the keys listed below:</p>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/back_pressure/","title":"back_pressure","text":"<p>Maximum number of outstanding items to be logged before the submission will block; helps to avoid runaway issues spiralling out of control.</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  back_pressure = 128000,\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/compression_level/","title":"compression_level","text":"<p>Specifies the level of zstd compression that should be used.  Compression cannot be disabled.</p> <p>Specifying <code>0</code> uses the zstd default compression level, which is <code>3</code> at the time of writing.</p> <p>Possible values are <code>1</code> (cheapest, lightest) through to <code>21</code>.</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  compression_level = 3,\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/filter_event/","title":"filter_event","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Optional string. If provided, specifies the name of an event that should be triggered to decide whether logs for a given message should be included in this instance of local file logging.</p> <p>The event will be passed the message that is being considered for logging purposes.  The goal of the event is to return <code>true</code> if logging should proceed or <code>false</code> otherwise.</p> <p>You may access the message metadata to make that decision.</p> <pre><code>kumo.on('init', function()\n  -- We only want logs for messages accepted via SMTP to land here\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumo-logs-smtp',\n    filter_event = 'should_log_to_smtp_logs',\n  }\n\n  -- We want all other logs to land here\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumo-logs-other',\n    filter_event = 'should_log_to_other',\n  }\nend)\n\nkumo.on('should_log_to_smtp_logs', function(msg)\n  return msg:get_meta 'reception_protocol' == 'ESMTP'\nend)\n\nkumo.on('should_log_to_other', function(msg)\n  return msg:get_meta 'reception_protocol' ~= 'ESMTP'\nend)\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/headers/","title":"headers","text":"<p>Specify a list of message headers to include in the logs. The default is empty.</p> <p>Warning</p> <p>While logging headers directly is convenient and easy to express in the logging configuration, it comes with additional runtime CPU and IO overhead: every discrete event that is logged will result in the message contents being loaded from spool (if they are not already loaded), the message headers being parsed, and the selected headers decoded to be logged.</p> <p>If your system has CPU and IO to spare, this is a non-issue, but if you are pushing your system to its limits, and especially if you have a large scheduled queue with lots of throttled or otherwise delayed messages, these overheads can dominate the system and harm overall throughput.</p> <p>We recommend instead using msg:import_x_headers() during message reception to cache a copy of the headers that you desire to log into your message metadata, then listing those metadata fields in your logger meta list instead of using <code>headers</code>.  This will dramatically reduce the IO and CPU overheads around logging.</p> <pre><code>kumo.configure_local_logs {\n  -- You can log headers like this, but it is not recommended!\n  -- You generally should prefer to log `meta` instead.\n  headers = { 'Subject' },\n}\n</code></pre> <p>Please consider using meta rather than <code>headers</code>!</p> <p>Since: Version 2023.12.28-63cde9c7</p> <p>The functionality described in this outlined box requires version 2023.12.28-63cde9c7 of KumoMTA, or a more recent version.</p> <p>Header names can now use simple wildcard suffixes; if the last character of the header name is <code>*</code> then it will match any string with that prefix. For example <code>\"X-*\"</code> will match any header names that start with <code>\"X-\"</code>.</p>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/log_dir/","title":"log_dir","text":"<p>Specifies the directory into which log file segments will be written. This is a required key; there is no default value.</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  log_dir = '/var/log/kumo-logs',\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/max_file_size/","title":"max_file_size","text":"<p>Specify how many uncompressed bytes to allow per file segment. When this number is exceeded, the current segment is finished and a new segment is created.</p> <p>Segments are created using the current time in the form <code>YYYYMMDD-HHMMSS</code> so that it is easy to sort the segments in chronological order.</p> <p>The default value is ~1GB of uncompressed data, which compresses down to around 50MB of data per segment with the default compression settings.</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  max_file_size = 1000000000,\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/max_segment_duration/","title":"max_segment_duration","text":"<p>Specify the maximum time period for a file segment.  The default is unlimited.</p> <p>If you set this to <code>\"1min\"</code>, you indicate that any given file should cover a time period of 1 minute in duration; when that time period elapses, the current file segment, if any, will be flushed and closed and any subsequent events will cause a new file segment to be created.</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  max_segment_duration = '5 minutes',\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/meta/","title":"meta","text":"<p>Specify a list of message meta fields to include in the logs. The default is empty.</p> <pre><code>kumo.on('init', function()\n  kumo.configure_local_logs {\n    -- ..\n    meta = { 'my-meta-1', 'subject' },\n  }\nend)\n\nkumo.on('smtp_server_message_received', function(msg, conn_meta)\n  -- Arrange to log the subject header in the most\n  -- efficient way, by capturing it into the message\n  -- metadata when we receive the message.\n  -- The `msg:import_x_headers` method will capture non-x-header\n  -- names when header names are explicitly passed.\n  msg:import_x_headers { 'subject' }\n\n  -- set an arbitrary meta item; it will be logged because\n  -- `my-meta-1` is listed in the logging configuration\n  -- above.\n  msg:set_meta('my-meta-1', 'some value')\nend)\n</code></pre> <p>Since: Version 2025.10.06-5ec871ab</p> <p>The functionality described in this outlined box requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Meta names can now use simple wildcard suffixes; if the last character of the meta name is <code>*</code> then it will match any string with that prefix. For example <code>\"xfer_*\"</code> will match any meta names that start with <code>\"xfer_\"</code>.</p> <p>Note</p> <p>meta names are case sensitive, so you must specify the exact matching case, even if you are using wildcards to match names.</p> <p>See also:</p> <ul> <li>msg:import_x_headers</li> <li>msg:set_meta</li> </ul>","tags":["logging","meta"]},{"location":"reference/kumo/configure_local_logs/min_free_inodes/","title":"min_free_inodes","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Specifies the desired minimum amount of free inodes for the log storage in this location.  Can be specified using either a string like <code>\"10%\"</code> to indicate the percentage of available inodes, or a number to indicate the number of available inodes.</p> <p>If the available inodes are below the specified amount then kumomta will reject incoming SMTP and HTTP injection requests and the check-liveness endpoint will indicate that new messages cannot be received.</p> <p>The default value for this option is <code>\"10%\"</code>.</p>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/min_free_space/","title":"min_free_space","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Specifies the desired minimum amount of free disk space for the log storage in this location.  Can be specified using either a string like <code>\"10%\"</code> to indicate the percentage of available space, or a number to indicate the number of available bytes.</p> <p>If the available storage is below the specified amount then kumomta will reject incoming SMTP and HTTP injection requests and the check-liveness endpoint will indicate that new messages cannot be received.</p> <p>The default value for this option is <code>\"10%\"</code>.</p>","tags":["logging"]},{"location":"reference/kumo/configure_local_logs/per_record/","title":"per_record","text":"<p>Allows configuring per-record type logging.</p> <pre><code>kumo.configure_local_logs {\n  per_record = {\n    Reception = {\n      -- use names like \"20230306-022811_recv\" for reception logs\n      suffix = '_recv',\n    },\n\n    Delivery = {\n      -- put delivery logs in a different directory\n      log_dir = '/var/log/kumo/delivery',\n    },\n\n    TransientFailure = {\n      -- Don't log transient failures\n      enable = false,\n    },\n\n    Bounce = {\n      -- Instead of logging the json record, evaluate this\n      -- template string and log the result.\n      template = [[Bounce! id={{ id }}, from={{ sender }} code={{ response.code }} age={{ timestamp - created }}]],\n    },\n\n    -- For any record type not explicitly listed, apply these settings.\n    -- This effectively turns off all other log records\n    Any = {\n      enable = false,\n    },\n  },\n}\n</code></pre> <p>The keys of the <code>per_record</code> table must correspond to one of the record types listed below, or the special <code>Any</code> key which can be used to match any record type that was not explicitly listed.  The values of the <code>per_record</code> table are <code>LogRecordParams</code> have the following fields and values:</p> <ul> <li><code>suffix</code> - a string to append to the generated segment file name.   For example, <code>suffix = '.csv'</code> will generate names like <code>20230306-022811.csv</code>.</li> <li><code>log_dir</code> - specify an alternative log directory for this type</li> <li><code>enable</code> - defaults to <code>true</code>. If you set it to <code>false</code>, records of this   type will not be logged</li> <li><code>segment_header</code> - ((Since: Version 2023.11.28-b5252a41)) text that will be written   out to each newly opened segment file. Useful for emitting eg: a CSV header   line.</li> <li><code>template</code> - the template to use to format the log line. Continue reading   below for more information.</li> </ul> <p>The Mini Jinja templating engine, with some supplemental extensions, is used to evaluate logging templates.  The syntax and extensions are documented here.</p> <p>The JSON log record fields shown in the section below are assigned as template variables, so using <code>{{ id }}</code> in your log template will be substituted with the <code>id</code> field from the log record section below.</p> <p>To reference headers in a template, note that the header name is transformed to lowercase as part of adding it to the <code>headers</code> object, so to access a header named <code>X-FooBar</code> you would use <code>{{ headers['x-foobar'] }}</code> in your template.</p> <p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>You may now use <code>log_record</code> to reference the entire log record, which is useful if you want to replicate the default json representation of the log record for an individual record type.</p> <p>You might wish to use something like the following:</p> <pre><code>per_record = {\n    Feedback = {\n        template = [[{{ log_record | tojson }}]]\n    }\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo/define_spool/","title":"kumo.define_spool","text":"<pre><code>kumo.define_spool { PARAMS }\n</code></pre> <p>Defines a named spool storage backend.</p> <p>KumoMTA uses separate storage areas for metadata and message contents, named <code>\"meta\"</code> and <code>\"data\"</code> respectively.</p> <p>This function should be called only from inside your init event handler.</p> <pre><code>kumo.on('init', function()\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n  }\nend)\n</code></pre> <p>PARAMS is a lua table that can accept the keys listed below:</p>"},{"location":"reference/kumo/define_spool/flush/","title":"flush","text":"<p>Whether to flush data to storage after each write. The default is <code>false</code>. When set to <code>true</code>, a backend specific means of flushing OS buffers to storage will be used after each write to encourage maximum durability of writes.</p> <p>Setting <code>flush=true</code> can be incredibly harmful to throughput, and, depending on your local storage device and filesystem selection, may not meaningfully increase durability.</p> <pre><code>kumo.on('init', function()\n  kumo.define_spool {\n    -- ..\n    flush = false,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/kind/","title":"kind","text":"<p>Specifies the spool storage backend type. There are two possible options:</p> <ul> <li><code>\"LocalDisk\"</code> - the default. Stores data in individual files on the filesystem.</li> <li><code>\"RocksDB\"</code> - uses RocksDB to achieve higher throughput.</li> </ul> <p><code>\"LocalDisk\"</code>'s performance characteristics are strongly coupled with your local storage device and filesystem performance.</p> <p><code>\"RocksDB\"</code> makes heavy use of memory buffers and intelligent layout of storage to reduce the I/O cost. To a certain degree, the buffering has similar characteristics to deferred spooling, but the risk of corruption is attenuated because RocksDB uses a write-ahead-log and a background sync thread.</p>"},{"location":"reference/kumo/define_spool/min_free_inodes/","title":"min_free_inodes","text":""},{"location":"reference/kumo/define_spool/min_free_inodes/#min_free_inodes","title":"min_free_inodes","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Specifies the desired minimum amount of free inodes for the spool storage in this location.  Can be specified using either a string like <code>\"10%\"</code> to indicate the percentage of available inodes, or a number to indicate the number of available inodes.</p> <p>If the available inodes are below the specified amount then kumomta will reject incoming SMTP and HTTP injection requests and the check-liveness endpoint will indicate that new messages cannot be received.</p> <p>The default value for this option is <code>\"10%\"</code>.</p>"},{"location":"reference/kumo/define_spool/min_free_space/","title":"min_free_space","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Specifies the desired minimum amount of free disk space for the spool storage in this location.  Can be specified using either a string like <code>\"10%\"</code> to indicate the percentage of available space, or a number to indicate the number of available bytes.</p> <p>If the available storage is below the specified amount then kumomta will reject incoming SMTP and HTTP injection requests and the check-liveness endpoint will indicate that new messages cannot be received.</p> <p>The default value for this option is <code>\"10%\"</code>.</p>"},{"location":"reference/kumo/define_spool/name/","title":"name","text":"<p>Specify the name of this spool. You are free to define as many spools as you wish, but at the time of writing KumoMTA only uses spools with the following names:</p> <ul> <li><code>\"data\"</code> - holds the message bodies</li> <li><code>\"meta\"</code> - holds message metadata, such as the envelope and per message metadata</li> </ul>"},{"location":"reference/kumo/define_spool/path/","title":"path","text":"<p>Specifies the path to the directory into which the spool will be stored.</p> <pre><code>kumo.on('init', function()\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo-spool/data',\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/rocks_params/","title":"rocks_params","text":"<p>Specifies additional tuning parameters for RocksDB when <code>kind = \"RocksDB\"</code>.</p> <p>The following parameters are possible:</p>"},{"location":"reference/kumo/define_spool/rocks_params/#increase_parallelism","title":"increase_parallelism","text":"<p>By default, RocksDB uses only one background thread for flush and compaction. You can use this option to increase the number of threads available for this purpose. A good number is the number of cores available to the system:</p> <pre><code>kumo.on('init', function()\n  local params = {\n    increase_parallelism = kumo.available_parallelism(),\n  }\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/rocks_params/#optimize_level_style_compaction","title":"optimize_level_style_compaction","text":"<p>When set, its value is the number of bytes to use for the <code>memtable_memory_budget</code> and enable the use of level-style compaction.</p> <p>Level style compaction is the default.</p> <p>Larger values allocate more memory to use for write and compaction buffers and can increase throughput to RocksDB.</p> <p>This option is incompatible with <code>optimize_universal_style_compaction</code>.</p> <pre><code>kumo.on('init', function()\n  local params = {\n    -- Use 64MB as the base write_buffer size\n    optimize_level_style_compaction = 64 * 1024 * 1024,\n  }\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/rocks_params/#optimize_universal_style_compaction","title":"optimize_universal_style_compaction","text":"<p>When set, its value is the number of bytes to use for the <code>memtable_memory_budget</code> and enable the use of universal-style compaction.</p> <p>Larger values allocate more memory to use for write and compaction buffers and can increase throughput to RocksDB.</p> <p>This option is incompatible with <code>optimize_level_style_compaction</code>.</p> <pre><code>kumo.on('init', function()\n  local params = {\n    -- Use 64MB as the base write_buffer size\n    optimize_universal_style_compaction = 64 * 1024 * 1024,\n  }\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/rocks_params/#limit_concurrent_loads","title":"limit_concurrent_loads","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>When loading from RocksDB, KumoMTA will first try a non-blocking load, but if RocksDB is too busy for that, a blocking load will occur in a background thread pool.</p> <p>By default there is no spool-specific upper bound to the number of outstanding blocking submission tasks, and the thread pool in which they run can grow to up to 512 threads.</p> <p>You will generally benefit from improved latency and low CPU contention and context switches if you set an upper bound on the number of outstanding store tasks that are permitted.</p> <p>That is where this option comes in; when specified, it defines a semaphore that will limit the number of tasks that are spawned into the blocking thread pool.</p> <p>You should experiment to find which setting works best for your workload, but the recommended starting point is shown below:</p> <pre><code>kumo.on('init', function()\n  local params = {\n    -- Use double the number of cores\n    limit_concurrent_loads = kumo.available_parallelism() * 2,\n  }\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/rocks_params/#limit_concurrent_removes","title":"limit_concurrent_removes","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>When deleting from RocksDB, KumoMTA will first try a non-blocking remove, but if RocksDB is too busy for that, a blocking remove will occur in a background thread pool.</p> <p>By default there is no spool-specific upper bound to the number of outstanding blocking submission tasks, and the thread pool in which they run can grow to up to 512 threads.</p> <p>You will generally benefit from improved latency and low CPU contention and context switches if you set an upper bound on the number of outstanding store tasks that are permitted.</p> <p>That is where this option comes in; when specified, it defines a semaphore that will limit the number of tasks that are spawned into the blocking thread pool.</p> <p>You should experiment to find which setting works best for your workload, but the recommended starting point is shown below.</p> <pre><code>kumo.on('init', function()\n  local params = {\n    -- Use double the number of cores\n    limit_concurrent_removes = kumo.available_parallelism() * 2,\n  }\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/rocks_params/#limit_concurrent_stores","title":"limit_concurrent_stores","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>When saving to RocksDB, KumoMTA will first try a non-blocking submission, but if RocksDB is too busy for that, a blocking submission will occur in a background thread pool.</p> <p>By default there is no spool-specific upper bound to the number of outstanding blocking submission tasks, and the thread pool in which they run can grow to up to 512 threads.</p> <p>You will generally benefit from improved latency and low CPU contention and context switches if you set an upper bound on the number of outstanding store tasks that are permitted.</p> <p>That is where this option comes in; when specified, it defines a semaphore that will limit the number of tasks that are spawned into the blocking thread pool.</p> <p>You should experiment to find which setting works best for your workload, but the recommended starting point is shown below:</p> <pre><code>kumo.on('init', function()\n  local params = {\n    -- Use double the number of cores\n    limit_concurrent_stores = kumo.available_parallelism() * 2,\n  }\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n    kind = 'RocksDB',\n    rocks_params = params,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/","title":"kumo.make_egress_path","text":"<pre><code>kumo.make_egress_path { PARAMS }\n</code></pre> <p>Constructs a configuration object that specifies how traffic travelling the path from a source to a site will behave.</p> <p>This function should be called from the get_egress_path_config event handler to provide the configuration for the requested site.</p> <p>The following keys are possible:</p>"},{"location":"reference/kumo/make_egress_path/additional_connection_limits/","title":"additional_connection_limits","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Specifies additional connection limit constraints that cut across the per-site-per-source scoping of the connection_limit option.</p> <p>The value is a map from the limit name to the desired limit.</p> <p>For example, you could implement a global outbound connection limit of 100 connections like this:</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    additional_connection_limits = {\n      ['global-connection-limit'] = 100,\n    },\n  }\nend)\n</code></pre> <p>or you could set up a source-specific connection limit that is shared by all domains with a particular suffix match something like this, including both the source and your candidate domain name in the limit name:</p> <pre><code>local utils = require 'policy-extras.policy_utils'\n\nlocal LIMITS = {\n  ['.outlook.com'] = 100,\n  ['.example.com'] = 32,\n}\n\nkumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  local limits = {}\n  for suffix, value in pairs(LIMITS) do\n    if utils.ends_with(domain, suffix) then\n      limits[string.format('site-limit-for-%s-%s', suffix, source)] = value\n    end\n  end\n  return kumo.make_egress_path {\n    additional_connection_limits = limits,\n  }\nend)\n</code></pre> <p>You can mix all of the above with the built-in <code>connection_limit</code>:</p> <pre><code>local utils = require 'policy-extras.policy_utils'\n\nlocal LIMITS = {\n  ['.outlook.com'] = 100,\n  ['.example.com'] = 32,\n}\n\nkumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  local limits = {\n    -- No more than 100 connections globally\n    ['global-connection-limit'] = 100,\n  }\n  -- Apply domain+source specific limits\n  for suffix, value in pairs(LIMITS) do\n    if utils.ends_with(domain, suffix) then\n      limits[string.format('site-limit-for-%s-%s', suffix, source)] = value\n    end\n  end\n  return kumo.make_egress_path {\n    -- no more than 10 connections from a given source to this specific site\n    connection_limit = 10,\n    additional_connection_limits = limits,\n  }\nend)\n</code></pre> <p>When a connection is eligible to be established, the system will sort the overall set of connection limits, including the <code>connection_limit</code> limit option, from smallest to highest, then acquire a lease to connect in that order.  This minimizes the chances that we'll redundantly consume an available slot from the larger allocation only to trip over one of the smaller ones.</p> <p>Note</p> <p>When choosing a name for your limit, you can select any name you like, but you should avoid using the prefix <code>kumomta.</code> as that is used by kumomta and you do not want to collide with its own limit names.</p> <p>See also connection_limit.</p>"},{"location":"reference/kumo/make_egress_path/additional_message_rate_throttles/","title":"additional_message_rate_throttles","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Specifies additional message rate constraints that cut across the per-site-per-source scoping of the max_message_rate option.</p> <p>The value is a map from the limit name to the desired throttle spec.</p> <p>For example, you could implement a global outbound message rate of <code>4000/s</code> like this:</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    additional_message_rate_throttles = {\n      ['global-message-rate'] = '4000/s',\n    },\n  }\nend)\n</code></pre> <p>or you could set up a source-specific limit that is shared by all domains with a particular suffix match something like this, including both the source and your candidate domain name in the limit name:</p> <pre><code>local utils = require 'policy-extras.policy_utils'\n\nlocal RATES = {\n  ['.outlook.com'] = '100/s',\n  ['.example.com'] = '10/s',\n}\n\nkumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  local rates = {}\n  for suffix, value in pairs(RATES) do\n    if utils.ends_with(domain, suffix) then\n      limits[string.format('site-rate-limit-for-%s-%s', suffix, source)] =\n        value\n    end\n  end\n  return kumo.make_egress_path {\n    additional_message_rate_throttles = rates,\n  }\nend)\n</code></pre> <p>You can mix all of the above with the built-in <code>max_message_rate</code>:</p> <pre><code>local utils = require 'policy-extras.policy_utils'\n\nlocal RATES = {\n  ['.outlook.com'] = '100/s',\n  ['.example.com'] = '10/s',\n}\n\nkumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  local rates = {\n    -- No more than 4000/s connections globally\n    ['global-message-rate'] = '4000/s',\n  }\n  -- Apply domain+source specific limits\n  for suffix, value in pairs(RATES) do\n    if utils.ends_with(domain, suffix) then\n      limits[string.format('site-rate-limit-for-%s-%s', suffix, source)] =\n        value\n    end\n  end\n  return kumo.make_egress_path {\n    additional_message_rate_throttles = rates,\n    -- no more than 200/s from a given source to this specific site\n    max_message_rate = '200/s',\n  }\nend)\n</code></pre> <p>When a message is eligible to be delivered from the ready queue, the system will sort the overall set of rate limits, including the <code>max_message_rate</code> option, from smallest to highest, then check and increment each in that order. This minimizes the chances that we'll redundantly consume an available slot from the larger allocation only to trip over one of the smaller ones.</p> <p>Note</p> <p>When choosing a name for your throttle, you can select any name you like, but you should avoid using the prefix <code>kumomta.</code> as that is used by kumomta and you do not want to collide with its own limit names.</p> <p>See also max_message_rate.</p>"},{"location":"reference/kumo/make_egress_path/additional_source_selection_rates/","title":"additional_source_selection_rates","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Specifies additional source selection constraints that cut across the per-site-per-source scoping of the source_selection_rate option.</p> <p>This option can be used to help manage IP-warmup.  Please read the source_selection_rate documentation to understand how source selection rate limiting functions.</p> <p>The value of this option is a map from the rate limit name to the desired rate limit, and allows you to express multiple constraints.</p> <p>For example, you could implement a overall selection limit, independent of the destination site, for a given named source like this:</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    additional_source_selection_rates = {\n      [string.format('overall-source-limit-%s', source_name)] = '10,000/day,max_burst=1',\n    },\n  }\nend)\n</code></pre> <p>Note</p> <p>If you are using the shaping helper, it will automatically populate entries in this map when you specify <code>provider_source_selection_rate</code> in a provider block in your <code>shaping.toml</code> and will cause that limit to apply to that source across all sites that map to that provider:</p> <pre><code>[provider.\"Office 365\".sources.\"new-source\"]\nprovider_source_selection_rate = \"500/d,max_burst=1\"\n</code></pre>"},{"location":"reference/kumo/make_egress_path/allow_smtp_auth_plain_without_tls/","title":"allow_smtp_auth_plain_without_tls","text":"<p>Optional boolean. Defaults to <code>false</code>.</p> <p>When <code>false</code>, and the connection is not using TLS, SMTP AUTH PLAIN will be premptively failed in order to prevent the credential from being passed over the network in clear text.</p> <p>You can set this to <code>true</code> to allow sending the credential in clear text.</p> <p>Danger</p> <p>Do not enable this option on an untrusted network, as the credential will then be passed in clear text and visible to anyone else on the network</p>"},{"location":"reference/kumo/make_egress_path/banner_timeout/","title":"banner_timeout","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>How long to wait between a connection being established and receiving a 220 from a receiving host. The default is <code>60s</code>.</p> <p>In earlier versions of KumoMTA, this was rolled together into the <code>connect_timeout</code>.</p>"},{"location":"reference/kumo/make_egress_path/connect_timeout/","title":"connect_timeout","text":"<p>How long to wait between starting an SMTP connection and receiving a 220 from a receiving host. The default is <code>60s</code>.</p> <p>(Since: Version 2024.09.02-c5476b89)     The <code>connect_timeout</code> is now purely focused on the time it takes to     establish a working connection. The time allowed for receiving the     initial 220 banner has been separated out into <code>banner_timeout</code>.</p>"},{"location":"reference/kumo/make_egress_path/connection_limit/","title":"connection_limit","text":"<p>Specifies the maximum number of concurrent connections that will be made from the current MTA machine to the destination site.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    connection_limit = 32,\n  }\nend)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p><code>connection_limit</code> may now be specified using a string in addition to an integer; the string format allows the use of commas or underscores to separate digits if you prefer that for clarity:</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    connection_limit = '1,000',\n  }\nend)\n</code></pre> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    connection_limit = '1_000',\n  }\nend)\n</code></pre> <p>However, the primary reason for supporting the string notation is that you can indicate when you wish for the connection limit to be local to the kumod instance, rather than shared via redis.</p> <p>In the example below, we force the use of a local connection limit even if redis-shared throttle and limits are enabled:</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    connection_limit = 'local:20',\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/consecutive_connection_failures_before_delay/","title":"consecutive_connection_failures_before_delay","text":"<p>Each time KumoMTA exhausts the full list of hosts for the destination it increments a <code>consecutive_connection_failures</code> counter. When that counter exceeds the <code>consecutive_connection_failures_before_delay</code> configuration value, KumoMTA will then delay all of the messages currently in the ready queue, generating a transient failure log record with code <code>451 4.4.1 No answer from any hosts listed in MX</code>.</p> <p>The default value for this setting is 100.</p>"},{"location":"reference/kumo/make_egress_path/data_dot_timeout/","title":"data_dot_timeout","text":"<p>How long to wait for a response after issuing a closing \".\" at the end of the DATA field. The default is <code>60s</code>.</p>"},{"location":"reference/kumo/make_egress_path/data_timeout/","title":"data_timeout","text":"<p>How long to wait for a response after issuing a DATA command. The default is <code>30s</code>.</p>"},{"location":"reference/kumo/make_egress_path/dispatcher_wakeup_strategy/","title":"maintainer_wakeup_strategy","text":"Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Adjusts how aggressively the readyq Dispatch tasks will be awoken as messages are placed into the readyq.</p> <p>Can have one of two values:</p> <ul> <li> <p><code>\"Aggressive\"</code> - the default. Every attempt to place a message    into the ready queue will cause all idle outbound sessions    that are associated with the readyq to wakeup and attempt to    pull messages from it.</p> </li> <li> <p><code>\"Relaxed\"</code> - Each submission attempt will signal just a single    idle outbound session to wakeup and pull a message from the    queue.</p> </li> </ul> <p>An <code>\"Aggressive\"</code> setting will cause more spurious wakeups in the case that there are multiple sessions and just a single new message being submitted, whereas a <code>\"Relaxed\"</code> setting will be more optimal in terms of CPU usage, at the risk of potentially missing a wakeup in some edge cases with bursty or low traffic.</p> <p>In earlier versions of KumoMTA this option did not exist, but the behavior was equivalent to the <code>\"Aggressive\"</code> setting.</p>"},{"location":"reference/kumo/make_egress_path/ehlo_domain/","title":"ehlo_domain","text":"<p>Optional string. Specifies the EHLO domain when initiating a connection to the destination. The default value is the <code>ehlo_domain</code> specified by make_egress_source, if any, otherwise, the local machine hostname.</p>"},{"location":"reference/kumo/make_egress_path/ehlo_timeout/","title":"ehlo_timeout","text":"<p>How long to wait for a response after issuing an EHLO command.  The default is <code>300s</code>.</p>"},{"location":"reference/kumo/make_egress_path/enable_dane/","title":"enable_dane","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (the default is <code>false</code>), then <code>TLSA</code> records will be resolved securely to determine the destination site policy for TLS according to DANE.</p> <p>If TLSA records are available, then the effective value of <code>enable_tls</code> will be treated as though it were set to <code>\"Required\"</code> and the OpenSSL DANE implementation will be used to verify the server certificate against the TLSA records found in DNS.</p> <p>Use of DANE also requires functioning DNSSEC in your DNS resolver; you will need to configure the <code>libunbound</code> resolver to successfully use DANE:</p> <pre><code>kumo.on('init', function()\n  kumo.dns.configure_unbound_resolver {\n    options = {\n      -- Enable DNSSEC\n      validate = true,\n    },\n    -- By default, if you omit `name_servers`, unbound will\n    -- resolve via the root resolvers.\n    -- We strongly recommend deploying local caching nameservers\n    -- and referencing them here:\n    -- name_servers = { '1.1.1.1:53' },\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/enable_mta_sts/","title":"enable_mta_sts","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (which is the default), the MTA-STS policy for the destination domain will be used to adjust the effective value of <code>enable_tls</code>.</p> <p>If the policy is set to <code>\"enforce\"</code>, then, assuming that the candidate MX host name matches the policy, the connection will be made with <code>enable_tls=\"Required\"</code>.  If the host name does not match, the candidate MX host will be not be used.</p> <p>If the policy is set to <code>\"testing\"</code>, then the connection will be made with <code>enable_tls=\"OpportunisticInsecure\"</code>.</p> <p>If the policy is set to <code>\"none\"</code>, then your configured value for <code>enable_tls</code> will be used.</p> <p>If <code>enable_dane=true</code> and <code>TLSA</code> records are present, then any MTA-STS policy will be ignored.</p>"},{"location":"reference/kumo/make_egress_path/enable_pipelining/","title":"enable_pipelining","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (the default is <code>true</code>), then kumo will use the SMTP <code>PIPELINING</code> extension when it is advertised by the remote host.</p> <p>When set to <code>false</code>, then <code>PIPELINING</code> will not be used even if it is advertised.</p> <p>You typically do want to use <code>PIPELINING</code> when available, because it reduces the protocol overhead and round-trips, resulting in lower latency sends per message.</p>"},{"location":"reference/kumo/make_egress_path/enable_rset/","title":"enable_rset","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (the default is <code>true</code>), then kumo will issue an <code>RSET</code> SMTP command in between each message send on a connection.</p> <p>The purpose of the <code>RSET</code> is a defensive measure, in case something unexpected and unaccounted for has left the connection in an unknown or undesirable state; it is used as a kind of \"rollback\" operation.</p> <p>Disabling the use of <code>RSET</code> can be a micro-optimization to improve the efficiency of a connection, but when pipelining is in use, it will really be a marginal difference.</p> <p>Perhaps the biggest reason for considering disabling this option is that certain Postfix load-shedding configurations will penalize the use of RSET, because it is considered to be a \"junk\" command.  If you see a trace like this:</p> <pre><code>&gt; RSET\n&gt; MAIL FROM:&lt;sender@example.com&gt;\n&gt; RCPT TO:&lt;user@postfix.local&gt;\n&lt; 250 2.0.0 Ok\n&lt; 421 4.7.0 mail.postfix.local Error: too many errors\n&gt; QUIT\n</code></pre> <p>then postfix on the destination is configured to penalize RSET and you may wish to disable its use.</p>"},{"location":"reference/kumo/make_egress_path/enable_tls/","title":"enable_tls","text":"<p>Controls whether and how TLS will be used when connecting to the destination.</p> <p>Note</p> <p>This setting is overriden by enable_mta_sts and/or enable_dane when either of those options are enabled and an MTA-STS or DANE policy (respectively) is published by the destination site.</p> <p>Possible values are:</p> <ul> <li> <p><code>\"Opportunistic\"</code> - use TLS if advertised by the <code>EHLO</code> response. If the peer   has invalid or self-signed certificates, then the delivery will fail. KumoMTA   will NOT fallback to not using TLS on that same host.</p> </li> <li> <p><code>\"OpportunisticInsecure\"</code> - use TLS if advertised by the <code>EHLO</code> response.   Validation of the certificate will be skipped. Not recommended for sending to   the public internet; this is intended for local or lab testing scenarios.</p> </li> <li> <p><code>\"Required\"</code> - Require that TLS be advertised in the <code>EHLO</code> response. The   remote host must have valid certificates in order to deliver to the site.</p> </li> <li> <p><code>\"RequiredInsecure\"</code> - Require that TLS be advertised in the <code>EHLO</code> response.   Validation of the certificate will be skipped.  Not recommended for sending   to the public internet; this is intended for local or lab testing scenarios.</p> </li> <li> <p><code>\"Disabled\"</code> - do not try to use TLS.</p> </li> </ul> <p>The default value is <code>\"Opportunistic\"</code>.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    enable_tls = 'Opportunistic',\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/idle_timeout/","title":"idle_timeout","text":"<p>How long a connection will remain open and idle, waiting to be reused for another delivery attempt, before being closed.</p> <p>The value is specified as a integer in seconds, or as a string using syntax like <code>\"2min\"</code> for a two minute duration. The default is <code>60s</code>.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    idle_timeout = 60,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/ignore_8bit_checks/","title":"ignore_8bit_checks","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code>, the SMTP client will not pre-emptively consider a message send attempt as a permanent failure when it would require either <code>8BITMIME</code> or <code>SMTPUTF8</code> support to be advertised by the next hop and the next hop does not advertise the appropriate extension.</p> <p>The default behavior (when this is set to <code>false</code>) is to consider the message content and the message envelope.</p> <p>If the content is 8bit and <code>8BITMIME</code> is not advertised by the next hop, the message is not deliverable according to the various SMTP RFCs.  The resolution to this issue is, in order of preference:</p> <ol> <li>Ensure that the generator of the message is using appropriate transfer encoding.</li> <li>Deploy a policy that uses    msg:check_fix_conformance during    reception to rewrite the message (likely breaking any digital signatures in    the incoming message).</li> </ol> <p>If the envelope is 8bit and <code>SMTPUTF8</code> is not advertised by the next hop, then there is no way to deliver that message to that destination.  The only way to successfully deliver such a message (assuming that the recipient is actually valid) is to ensure that you have configured routing to deliver directly to the recipient providers domain (eg: don't route via a smart host that doesn't support <code>SMTPUTF8</code>).</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    ignore_8bit_checks = false,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/low_memory_reduction_policy/","title":"low_memory_reduction_policy","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Specifies what action should be taken when a message is added to the ready queue corresponding to this egress path when the memory usage is above the low memory threshold.</p> <p>Possible values for this option are:</p> <ul> <li><code>\"ShrinkDataAndMeta\"</code> - this is the default (and is the implicit action for   older versions of KumoMTA).  Both the message data and metadata will be saved   (if modified since the prior save, or if the message has not yet been saved   to spool), then both will be released, freeing up the corresponding memory.</li> <li><code>\"ShrinkData\"</code> - Both the message data and metadata will be saved   (if modified since the prior save, or if the message has not yet been saved   to spool), then just the message data will be released, freeing up that memory.   The metadata will be preserved in memory.</li> <li><code>\"NoShrink\"</code> - do not save or free up any message memory.</li> </ul> <p>This setting allows you more control in the trade-off of memory usage against spool IO pressure. The default is relatively conservative, aiming to avoid OOM killing at the cost of throughput (increased spool IO). Setting this option to <code>\"ShrinkData\"</code> or <code>\"NoShrink\"</code> will allow the system to use more memory and reduce pressure on the spool, but you increase the risk of memory usage exceeding limits and being targeted by the OOM killer if there is a burst in your workload.</p> <p>See also:  * no_memory_reduction_policy  * Memory Management</p>","tags":["memory"]},{"location":"reference/kumo/make_egress_path/mail_from_timeout/","title":"mail_from_timeout","text":"<p>How long to wait for a response after issuing a MAIL FROM command. The default is <code>300s</code>.</p>"},{"location":"reference/kumo/make_egress_path/maintainer_wakeup_strategy/","title":"maintainer_wakeup_strategy","text":"Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Adjusts how aggressively the readyq maintainer task will be awoken as messages are placed into the readyq.</p> <p>Can have one of two values:</p> <ul> <li> <p><code>\"Aggressive\"</code> - the default. Every attempt to place a message into the    ready queue will cause the associated maintainer task to wakeup to assess    whether more connections need to be established.</p> </li> <li> <p><code>\"Relaxed\"</code> - Each submission attempt will perform a quick approximation    and assessment of the current connection count to decide whether the    maintainer task needs to be signalled.  If the number of connections    matches the ideal for the current queue size, then the maintainer will    not be signalled and it will wakeup periodically to reassess the    load.</p> </li> </ul> <p>The primary purpose of the readyq maintainer is to establish new outbound connections based on the queue size.  A <code>\"Relaxed\"</code> setting will cause a precise assessment of that state to occur less frequently, reducing CPU overhead, but it may result in an increase in latency for outbound traffic when conditions are bursty.</p> <p>In earlier versions of KumoMTA this option did not exist, but the behavior was equivalent to the <code>\"Aggressive\"</code> setting.</p>"},{"location":"reference/kumo/make_egress_path/max_connection_rate/","title":"max_connection_rate","text":"<p>Optional string.</p> <p>Specifies the maximum permitted rate at which connections can be established from this source to the corresponding destination site.</p> <p>The value is of the form <code>quantity/period</code> where quantity is a number and period can be a measure of time.</p> <p>Examples of throttles:</p> <pre><code>\"10/s\" -- 10 per second\n\"10/sec\" -- 10 per second\n\"10/second\" -- 10 per second\n\n\"50/m\" -- 50 per minute\n\"50/min\" -- 50 per minute\n\"50/minute\" -- 50 per minute\n\n\"1,000/hr\" -- 1000 per hour\n\"1_000/h\" -- 1000 per hour\n\"1000/hour\" -- 1000 per hour\n\n\"10_000/d\" -- 10,000 per day\n\"10,000/day\" -- 10,000 per day\n</code></pre> <p>Throttles are implemented using a Generic Cell Rate Algorithm.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\n  return kumo.make_egress_path {\n    max_connection_rate = '100/min',\n  }\nend)\n</code></pre> <p>If the throttle is exceeded and the delay before a connection be established is longer than the <code>idle_timeout</code>, then the messages in the ready queue will be delayed until the throttle would permit them to be delievered again.</p>"},{"location":"reference/kumo/make_egress_path/max_deliveries_per_connection/","title":"max_deliveries_per_connection","text":"<p>Optional number.</p> <p>If set, no more than this number of messages will be attempted on any given connection.</p> Version Default (Since: Version 2023.08.22-4d895015) The default is 1024 Prior versions The default is unlimited"},{"location":"reference/kumo/make_egress_path/max_message_rate/","title":"max_message_rate","text":"<p>Optional string.</p> <p>Specifies the maximum permitted rate at which messages can be delivered from this source to the corresponding destination site.</p> <p>The throttle is specified the same way as for <code>max_connection_rate</code> above.</p> <p>If the throttle is exceeded and the delay before the current message can be sent is longer than the <code>idle_timeout</code>, then the messages in the ready queue will be delayed until the throttle would permit them to be delievered again.</p> <p>This option is distinct from the scheduled queue max_message_rate option in that the scheduled queue option applies to a specific scheduled queue, whilst this egress path option applies to the ready queue for a specific egress path, through which multiple scheduled queues send out to the internet.</p> <p>If you have configured <code>max_message_rate</code> both here and in a scheduled queue, the effective maximum message rate will be the lesser of the two values; both constraints are applied independently from each other at different stages of processing.</p>"},{"location":"reference/kumo/make_egress_path/max_ready/","title":"max_ready","text":"<p>Specifies the maximum number of messages that can be in the ready queue. The ready queue is the set of messages that are immediately eligible for delivery.</p> <p>If a message is promoted from its delayed queue to the ready queue and it would take the size of the ready queue above max_ready, the message will be delayed by a randomized interval of up to 60 seconds and placed back into the scheduled queue before being considered again.</p> <p>Moving a message from ready to scheduled as a result of hitting this limit may trigger disk IO to save the content of the message if the message was received with deferred spooling enabled.  In addition, other in-memory state is discarded to reduce memory utilization, and it will need to be re-loaded from the spool when the message is tried again later.</p> <p>The default for <code>max_ready</code> is 1024 messages.</p> <p>Raising the limit will increase RAM utilization in exchange for decreasing the IO load to your spool storage.</p>"},{"location":"reference/kumo/make_egress_path/max_recipients_per_batch/","title":"max_recipients_per_batch","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Optional integer.  Defaults to <code>100</code>.</p> <p>Specifies the maximum number of <code>RCPT TO</code> commands when sending a message that has multiple recipients.</p> <p>If a message has more than this number of recipients then each chunk will be attempted successively in separate transactions. Those transactions will re-use the current connection, but if the connection is broken, the excess will remain eligible for immediate delivery which will typically continue on a new connection.</p>"},{"location":"reference/kumo/make_egress_path/no_memory_reduction_policy/","title":"no_memory_reduction_policy","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Specifies what action should be taken when a message is added to the ready queue corresponding to this egress path when the memory usage is above the soft memory limit.  When the system is in this state, additional active measures will also be applied to reduce overall memory consumption.</p> <p>Possible values for this option are:</p> <ul> <li><code>\"ShrinkDataAndMeta\"</code> - this is the default (and is the implicit action for   older versions of KumoMTA).  Both the message data and metadata will be saved   (if modified since the prior save, or if the message has not yet been saved   to spool), then both will be released, freeing up the corresponding memory.</li> <li><code>\"ShrinkData\"</code> - Both the message data and metadata will be saved   (if modified since the prior save, or if the message has not yet been saved   to spool), then just the message data will be released, freeing up that memory.   The metadata will be preserved in memory.</li> <li><code>\"NoShrink\"</code> - do not save or free up any message memory.</li> </ul> <p>This setting allows you more control in the trade-off of memory usage against spool IO pressure. The default is relatively conservative, aiming to avoid OOM killing at the cost of throughput (increased spool IO). Setting this option to <code>\"ShrinkData\"</code> or <code>\"NoShrink\"</code> will allow the system to use more memory and reduce pressure on the spool, but you increase the risk of memory usage exceeding limits and being targeted by the OOM killer if there is a burst in your workload.</p> <p>See also:  * low_memory_reduction_policy  * Memory Management</p>","tags":["memory"]},{"location":"reference/kumo/make_egress_path/openssl_cipher_list/","title":"openssl_cipher_list","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>If set, then the value will be used to configure the set of ciphers used by OpenSSL for TLS protocol version lower than 1.3.</p> <p>OpenSSL is used as described under the tls_prefer_openssl option.</p> <p>The format of the string is discussed in the OpenSSL ciphers documentation</p>"},{"location":"reference/kumo/make_egress_path/openssl_cipher_suites/","title":"openssl_cipher_suites","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>If set, then the value will be used to configure the set of ciphers used by OpenSSL for TLS protocol version 1.3.</p> <p>OpenSSL is used as described under the tls_prefer_openssl option.</p> <p>The format consists of TLSv1.3 cipher suite names separated by <code>:</code> characters in order of preference.</p>"},{"location":"reference/kumo/make_egress_path/openssl_options/","title":"openssl_options","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>If set, then the value will be used to configure openssl option flags.</p> <p>OpenSSL is used as described under the tls_prefer_openssl option.</p> <p>The format of the string is the set of possible option names separated by <code>|</code> characters.</p> <p>Option names are:</p> <ul> <li><code>ALL</code> - A \u201creasonable default\u201d set of options which enables compatibility flags.</li> <li><code>NO_QUERY_MTU</code> - Do not query the MTU.  Only affects DTLS connections.</li> <li><code>COOKIE_EXCHANGE</code> - Enables Cookie Exchange as described in RFC 4347 Section   4.2.1.  Only affects DTLS   connections.</li> <li><code>NO_TICKET</code> - Disables the use of session tickets for session resumption.</li> <li><code>NO_SESSION_RESUMPTION_ON_RENEGOTIATION</code> - Always start a new session when performing a renegotiation on the server side.</li> <li><code>NO_COMPRESSION</code> - Disables the use of TLS compression.</li> <li><code>ALLOW_UNSAFE_LEGACY_RENEGOTIATION</code> - Allow legacy insecure renegotiation with servers or clients that do not support secure renegotiation.</li> <li><code>SINGLE_ECDH_USE</code> - Creates a new key for each session when using ECDHE.  This is always enabled in OpenSSL 1.1.0.</li> <li><code>SINGLE_DH_USE</code> - Creates a new key for each session when using DHE.  This is always enabled in OpenSSL 1.1.0.</li> <li><code>TLS_ROLLBACK_BUG</code> - Disables version rollback attach detection.</li> <li><code>NO_SSLV2</code> - Disables the use of SSLv2.</li> <li><code>NO_SSLV3</code> - Disables the use of SSLv3.</li> <li><code>NO_TLSV1</code> - Disables the use of TLSv1.0.</li> <li><code>NO_TLSV1_1</code> - Disables the use of TLSv1.1.</li> <li><code>NO_TLSV1_2</code> - Disables the use of TLSv1.2.</li> <li><code>NO_TLSV1_3</code> - Disables the use of TLSv1.3.</li> <li><code>NO_DTLSV1</code> - Disables the use of DTLSv1.0.</li> <li><code>NO_DTLSV1_2</code> - Disables the use of DTLSv1.2.</li> <li><code>NO_RENEGOTIATION</code> - Disallow all renegotiation in TLSv1.2 and earlier.</li> <li><code>ENABLE_MIDDLEBOX_COMPAT</code> - Enable TLSv1.3 Compatibility mode.  Requires   OpenSSL 1.1.1 or newer. This is on by default in 1.1.1, but a future version   may have this disabled by default.</li> </ul>"},{"location":"reference/kumo/make_egress_path/opportunistic_tls_reconnect_on_failed_handshake/","title":"opportunistic_tls_reconnect_on_failed_handshake","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (the default is <code>false</code>), if <code>enable_tls</code> is set to <code>Opportunistic</code> or <code>OpportunisticInsecure</code>, and the TLS handshake, or the subsequent EHLO after the TLS handshake, fails, instead of moving on to the next address in the connection plan, we will establish a new connection to the same address, but with <code>enable_tls</code> set to <code>Disabled</code>.</p>"},{"location":"reference/kumo/make_egress_path/prohibited_hosts/","title":"prohibited_hosts","text":"<p>A CIDR list of hosts that should be considered \"poisonous\", for example, because they might cause a mail loop.</p> <p>When resolving the hosts for the destination MX, if any of the hosts are present in the <code>prohibited_hosts</code> list then the ready queue will be immediately failed with a <code>550 5.4.4</code> status.</p> <p>The default value for this is:</p> <ul> <li><code>127.0.0.0/8</code>, the set of IPv4 loopback addresses</li> <li><code>::1</code>, the IPv6 loopback address</li> </ul> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The default value is now:</p> <ul> <li><code>127.0.0.0/8</code>, the set of IPv4 loopback addresses</li> <li><code>0.0.0.0</code>, the IPv4 Any address</li> <li><code>::1</code>, the IPv6 loopback address</li> <li><code>::</code>, the IPv6 Any address</li> </ul>"},{"location":"reference/kumo/make_egress_path/rcpt_to_timeout/","title":"rcpt_to_timeout","text":"<p>How long to wait for a response after issuing a RCPT TO command. The default is <code>300s</code>.</p>"},{"location":"reference/kumo/make_egress_path/reconnect_strategy/","title":"reconnect_strategy","text":"Since: Version 2025.01.29-833f82a8 <p>The functionality described in this section requires version 2025.01.29-833f82a8 of KumoMTA, or a more recent version.</p> <p>Controls the behavior of the SMTP dispatcher when it encounters an error during message delivery.  It does not affect connection-time errors (such as connection failure, or protocol or transport errors around banner, EHLO, STARTTLS, AUTH), and specifically only targets errors that might arise as part of delivering a message:</p> <ul> <li>A 421 protocol response where the peer closes the connection.</li> <li>A timeout writing a request</li> <li>A timeout reading a response</li> <li>Some other IO error on the transport (eg: connection reset)</li> </ul> <p>You can set the <code>reconnect_strategy</code> to one of the following values to select the desired behavior for session re-use for subsequent messages:</p> <ul> <li><code>\"TerminateSession\"</code> - close the current session, allowing the queue   maintainer to decide about opening a new connection based on your shaping   configuration.  If a new session is established, it will start with a fresh   connection plan.</li> <li><code>\"ReconnectSameHost\"</code> - close the current connection, but adjust the session   state so that it will try connecting to the same host again for future sends.</li> <li><code>\"ConnectNextHost\"</code> - close the current connection and proceed to the next   host in the connection plan. This is the default behavior.</li> </ul> <p>The connection plan is constructed when a session is initiated; it is drawn from the preference-ordered list of MX hosts, but randomizes the set of hosts at each preference level.  This is then flattened into a list of hosts that will be attempted one after the other to establish a connection.</p> <p><code>\"ConnectNextHost\"</code> will maximize the chances of delivering mail in the face of various transient issues with the destination site.</p> <p>Some sites have very opininated anti-abuse policies and consider any attempt to connect to second tier (non-preferred) MX hosts as signs of bad behavior and this may impact your effective deliverability.  For those sites you may want to consider deploying with <code>reconnect_strategy=\"TerminateSession\"</code>.</p>"},{"location":"reference/kumo/make_egress_path/refresh_interval/","title":"refresh_interval","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Specifies how long this particular egress path object should be considered to be current when the refresh_strategy is set to <code>Ttl</code>.</p> <p>The default value for this is <code>\"60 seconds\"</code>.  This option accepts any duration string value.</p>"},{"location":"reference/kumo/make_egress_path/refresh_strategy/","title":"refresh_strategy","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Defines the refresh strategy that should be used to determine when this particular egress path object needs to be refreshed.</p> <p>Possible values are:</p> <ul> <li><code>\"Ttl\"</code> - the default value. Use the refresh_interval value.</li> <li><code>\"Epoch\"</code> - remains current until the Configuration   Monitoring system   determines that the configuration epoch has changed.</li> </ul>"},{"location":"reference/kumo/make_egress_path/remember_broken_tls/","title":"remember_broken_tls","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>While many destination sites on the internet advertise support for STARTTLS, a subset of them are problematic for reasons that can include:</p> <ul> <li>Running ancient crypto software with deprecated or otherwise incompatible    cipher suites</li> <li>Misconfigured CN</li> <li>Expired certificates</li> </ul> <p>These can cause issues when it comes to reliably enabling TLS for a given session when running in <code>Opportunistic</code> TLS mode; since the broken TLS can prevent re-using the existing session in clear text we can end up failing to connect to any of the candidate hosts for a given site.</p> <p>That is where this option comes into play: when it is set to a duration string, that will cause <code>kumod</code> to remember that a given site has broken TLS for up to that duration.</p> <p>Subsequent connection attempts will use that information to influence how it should proceed; for <code>Opportunistic</code> modes we will treat the session as if STARTTLS was not advertised.  For <code>Required</code> modes we will log an error that mentions that <code>remember_broken_tls</code> is set.</p> <pre><code>kumo.make_egress_path {\n  remember_broken_tls = '3 days',\n}\n</code></pre> <p>Note</p> <p>This information is cached locally in the memory of a given kumod process.  It is not shared with other nodes in a cluster, and it will be forgotten when the node is restarted.</p>"},{"location":"reference/kumo/make_egress_path/rset_timeout/","title":"rset_timeout","text":"<p>How long to wait for a response after issuing a RSET command. The default is <code>5s</code>.</p>"},{"location":"reference/kumo/make_egress_path/rustls_cipher_suites/","title":"rustls_cipher_suites","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional array of strings.</p> <p>If set, then the value will be used to configure rustls cipher suites.</p> <p>Rustls is used as described under the tls_prefer_openssl option above.</p> <p>The list of possible cipher suites at the time of writing is:</p> <ul> <li><code>TLS13_AES_256_GCM_SHA384</code></li> <li><code>TLS13_AES_128_GCM_SHA256</code></li> <li><code>TLS13_CHACHA20_POLY1305_SHA256</code></li> <li><code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</code></li> <li><code>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</code></li> <li><code>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</code></li> <li><code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code></li> <li><code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code></li> <li><code>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</code></li> </ul> <p>This list may evolve over time as new releases of kumomta are made.  You can review the current possible list with the <code>tls-probe</code> utility:</p> <pre><code>$ /opt/kumomta/sbin/tls-probe list-rustls-cipher-suites\nTLS13_AES_256_GCM_SHA384\nTLS13_AES_128_GCM_SHA256\nTLS13_CHACHA20_POLY1305_SHA256\nTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\nTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\nTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\nTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n</code></pre>"},{"location":"reference/kumo/make_egress_path/skip_hosts/","title":"skip_hosts","text":"<p>A CIDR list of hosts that should be removed from the list of hosts returned when resolving the MX for the destination domain.</p> <p>This can be used for example to skip a host that is experiencing issues.</p> <p>If all of the hosts returned for an MX are filtered out by <code>skip_hosts</code> then the complete contents of the ready queue will be immediately processed.  The behavior depends on the version of kumod:</p> Behavior Since Transiently Failed with a <code>451 4.4.4 KumoMTA internal: MX consisted solely of hosts on the skip_hosts list</code> status (Since: Dev Builds Only) Permanently Failed with a <code>550 5.4.4 MX consisted solely of hosts on the skip_hosts list</code> status All earlier versions"},{"location":"reference/kumo/make_egress_path/skip_hosts/#skipping-ipv6-addresses","title":"Skipping IPv6 Addresses","text":"<p>When performing MX resolution, KumoMTA will always resolve both the IPv4 and IPv6 addresses as part of its connection plan.  If your infrastructure cannot or for policy reasons, should not use IPv6 you can set:</p> <pre><code>kumo.make_egress_path {\n  -- Don't use IPv6 for deliveries\n  skip_hosts = { '::/0' },\n}\n</code></pre> <p>If you are using the shaping helper, you can express that in your <code>shaping.toml</code>:</p> <pre><code>[default]\nskip_hosts = [\"::/0\"]\n</code></pre>"},{"location":"reference/kumo/make_egress_path/smtp_auth_plain_password/","title":"smtp_auth_plain_password","text":"<p>Specifies the password that should be used together with <code>smtp_auth_plain_username</code> when an authenticated SMTP connection is desired.</p> <p>The value is any keysource, which allows for specifying the password inline in the configuration file, or managing it via a credential manager such as HashiCorp Vault.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, site_name)\n  return kumo.make_egress_path {\n    enable_tls = 'Required',\n    smtp_auth_plain_username = 'daniel',\n    -- The password can be any keysource value.\n    -- Here we are loading the credential for the domain\n    -- from HashiCorp vault\n    smtp_auth_plain_password = {\n      vault_mount = 'secret',\n      vault_path = 'smtp-auth/' .. domain,\n      -- Optional: specify a custom key name (defaults to \"key\")\n      -- vault_key = \"password\"\n    },\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/smtp_auth_plain_username/","title":"smtp_auth_plain_username","text":"<p>When set, connecting to the destination requires a successful AUTH PLAIN using the specified username.</p> <p>AUTH PLAIN will only be attempted if TLS is also enabled, unless <code>allow_smtp_auth_plain_without_tls = true</code>. This is to prevent leaking of the credential over an unencrypted link.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, site_name)\n  return kumo.make_egress_path {\n    enable_tls = 'Required',\n    smtp_auth_plain_username = 'daniel',\n    -- The password can be any keysource value\n    smtp_auth_plain_password = {\n      key_data = 'tiger',\n    },\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/smtp_port/","title":"smtp_port","text":"<p>Specifies the port to connect to when making an SMTP connection to a destination MX host.</p> <p>The default is port 25.</p> <p>See also:</p> <ul> <li>kumo.make_egress_source().remote_port</li> <li>kumo.make_queue_config().protocol</li> </ul>","tags":["port"]},{"location":"reference/kumo/make_egress_path/source_selection_rate/","title":"source_selection_rate","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Optional throttle spec string.</p> <p>Specifies the maximum permitted rate at which the source that is associated with this egress path can be selected during the promotion of a message from the scheduled queue to the ready queue of this egress path.</p> <p>This option can be used to help manage IP-warmup.</p> <p>For example, if you have two sources in a pool named <code>mypool</code>:</p> <ul> <li><code>new</code> - a new source that you want to use sparingly until you have established a good reputation for it</li> <li><code>established</code> - a source that is fully established</li> </ul> <p>And you have a <code>shaping.toml</code> configuration like:</p> <pre><code>[\"example.com\".sources.\"new\"]\n# You will probably want to set max_burst for this sort of throttle,\n# to avoid clumping all the sends together at the start of the day\nsource_selection_rate = \"100/day,max_burst=1\"\n</code></pre> <p>and a <code>queue.toml</code> configuration like:</p> <pre><code>[queue.'example.com']\negress_pool = 'mypool'\n</code></pre> <p>then messages destined for <code>example.com</code> will use the regular weighted round-robin source selection from <code>mypool</code>, but it will be modified slightly:</p> <ul> <li>Whenever the <code>new</code> source is selected by the weighted round-robin    algorithm, <code>source_selection_rate</code> (and <code>additional_source_selection_rates</code>)    will be consulted to see if there are rate limits for selection.</li> <li>If any selection rate limits are present, the throttles are sorted from    smallest to largest and then checked</li> <li>If there is remaining capacity in the throttles then the source will be selected.</li> <li>The first limit that is exceeded will cause the source to be ineligible    for this particular selection, and the round-robin algorithm will proceed    to try the next potential candidate source</li> </ul> <p>See also:</p> <ul> <li>additional_source_selection_rates</li> </ul>"},{"location":"reference/kumo/make_egress_path/starttls_timeout/","title":"starttls_timeout","text":"<p>How long to wait for a response after issuing a STARTTLS comand. The default is <code>5s</code>.</p>"},{"location":"reference/kumo/make_egress_path/suspended/","title":"suspended","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Optional boolean. Defaults to <code>false</code>.</p> <p>When set to <code>true</code>, this pathway will not be used to send mail.</p> <p>This option is present primarily to facilitate traffic shaping automation.</p> <p>Warning</p> <p>This option is deprecated and will be removed in a future release. It has been subsumed by realtime TSA suspension updates. It no longer has any effect.</p>"},{"location":"reference/kumo/make_egress_path/system_shutdown_timeout/","title":"system_shutdown_timeout","text":"Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>How long to wait for an in-flight delivery attempt to gracefully complete when the system is being shutdown. Once this timeout is reached, any open sessions will be aborted.</p> <p>The default value is computed by summing up the per-message-delivery timeout values:</p> <ul> <li>mail_from_timeout +</li> <li>rcpt_to_timeout +</li> <li>data_timeout +</li> <li>data_dot_timeout</li> </ul> <p>Caution</p> <p>If you make this value too short you increase the risk duplicate delivery when the sessions are terminated.</p>"},{"location":"reference/kumo/make_egress_path/tls_certificate/","title":"tls_certificate","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Specify the path to a TLS certificate file to use for presenting the client side certificate during delivery of emails.</p> <p>If unspecified, no client side certificate would be presented.</p> <p>Preferred to use X.509 version 3 to support both openssl and rustls.</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      -- ..\n      tls_certificate = '/path/to/cert.pem',\n    }\n  end\n)\n</code></pre> <p>You may specify that the certificate be loaded from a HashiCorp Vault:</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      -- ..\n      tls_certificate = {\n        vault_mount = 'secret',\n        vault_path = 'tls/mail.example.com.cert',\n\n        -- Specify how to reach the vault; if you omit these,\n        -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n\n        -- vault_address = \"http://127.0.0.1:8200\"\n        -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n      },\n    }\n  end\n)\n</code></pre> <p>The key must be stored as <code>key</code> (even though this is a certificate!) under the <code>path</code> specified.  For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert key=@mail.example.com.cert\n</code></pre>"},{"location":"reference/kumo/make_egress_path/tls_prefer_openssl/","title":"tls_prefer_openssl","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional boolean. Defaults to <code>false</code>.</p> <p>When set to <code>true</code>, this pathway will prefer to use OpenSSL as the TLS implementation.</p> <p>When set to <code>false</code>, this pathway will prefer to use rustls as the TLS implementation, unless DANE is enabled and TLSA records are present, in which case OpenSSL will be used.</p>"},{"location":"reference/kumo/make_egress_path/tls_private_key/","title":"tls_private_key","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Specify the path to the TLS private key file that corresponds to the <code>tls_certificate</code>.</p> <p>If unspecified, no client side certificate would be presented.</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      -- ..\n      tls_private_key = '/path/to/key.pem',\n    }\n  end\n)\n</code></pre> <p>You may specify that the key be loaded from a HashiCorp Vault:</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      -- ..\n      tls_private_key = {\n        vault_mount = 'secret',\n        vault_path = 'tls/mail.example.com.key',\n\n        -- Specify how to reach the vault; if you omit these,\n        -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n\n        -- vault_address = \"http://127.0.0.1:8200\"\n        -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n      },\n    }\n  end\n)\n</code></pre> <p>The key must be stored as <code>key</code> under the <code>path</code> specified. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com key=@mail.example.com.key\n</code></pre>"},{"location":"reference/kumo/make_egress_path/try_next_host_on_transport_error/","title":"try_next_host_on_transport_error","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>An optional boolean value that defaults to <code>false</code>.</p> <p>When set to <code>true</code>, if an SMTP message delivery attempt encounters a timeout, a transport error, or a protocol error that isn't directly associated with the message (eg: rejection prior to <code>MAIL FROM</code>), then, after logging a <code>TransientFailure</code> for the failed attempt, the message will be immediately eligible for delivery on the next available connection in the current connection session.</p> <p>If there are no further available connections, or <code>try_next_host_on_transport_error</code> is set to <code>false</code>, then the message will be re-queued to the scheduld queue for later delivery.</p> <p>In earlier versions of KumoMTA this option did not exist and the system behaves as if it was set to <code>false</code>.</p>"},{"location":"reference/kumo/make_egress_path/use_lmtp/","title":"use_lmtp","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (the default is <code>false</code>), use the <code>LMTP</code> protocol as described in RFC 2033 rather than the <code>ESMTP</code> protocol.</p>"},{"location":"reference/kumo/make_egress_pool/","title":"kumo.make_egress_pool","text":"<pre><code>kumo.make_egress_pool { PARAMS }\n</code></pre> <p>Defines an egress pool, which is a collection of weighted egress sources associated with the source of outbound traffic from the MTA.</p> <p>A given scheduled queue can be associated with a pool and it will then use Weighted Round Robin (WRR) to distribute sends from that scheduled queue across the IPs contained within its associated pool.  When a scheduled queue is idle for approximately 10 minutes, it will idle out and the round robin state will be reset for the next send.</p> <p>Info</p> <p>The Weighted Round Robin implementation in kumomta is considered to be probabilistic, achieving the configured distribution only when the rate of sending is sufficiently high (at least 1 message to a given site every few minutes), and is scoped per-scheduled-queue. There is no whole-machine nor whole-cluster coordination in the round robin implementation as those techniques introduce bottlenecks that limit scalability and are unnecessary at the kinds of volumes where it is important to implement distribution across sending IPs.</p> <p>This function is intended to be used inside your get_egress_pool event handler.</p> <p><code>PARAMS</code> is a lua table which may have the following keys:</p>"},{"location":"reference/kumo/make_egress_pool/entries/","title":"entries","text":"<p>Required list of entries.</p> <p>Each entry has a name, which must refer to a source that will be resolved via your get_egress_source event, and an optional weight:</p> <pre><code>local SOURCE_TO_IP = {\n  ['ip-1'] = '10.0.0.1',\n  ['ip-2'] = '10.0.0.2',\n  ['ip-3'] = '10.0.0.3',\n}\n\nfunction setup_pools()\n  return {\n    ['BestReputation'] = kumo.make_egress_pool {\n      name = 'BestReputation',\n      entries = {\n        { name = 'ip-1' },\n      },\n    },\n\n    ['MediumReputation'] = kumo.make_egress_pool {\n      name = 'MediumReputation',\n      entries = {\n        { name = 'ip-2', weight = 2 },\n        -- we're warming up ip-3, so use it less frequently than ip-2\n        { name = 'ip-3', weight = 1 },\n      },\n    },\n  }\nend\n\nlocal POOLS = setup_pools()\n\nkumo.on('get_egress_source', function(source_name)\n  return kumo.make_egress_source {\n    name = source_name,\n    source_address = SOURCE_TO_IP[source_name],\n  }\nend)\n\nkumo.on('get_egress_pool', function(pool_name)\n  return POOLS[pool_name]\nend)\n</code></pre> <p>The weight is used as part of Weighted Round-Robin selection for the source from the pool.</p> <p>If the weights are all equal, or are all left unspecified, then simple round-robin selection of sources will occur.</p> <p>Otherwise, the weight influences how often a given source will be used for traffic originating from this pool.</p> <p>A weight of <code>0</code> is permitted: it is equivalent to not including the associated sources in the list of entries.</p> <p>If weight is left unspecified, it defaults to <code>1</code>.</p>"},{"location":"reference/kumo/make_egress_pool/name/","title":"name","text":"<p>Required string.</p> <p>The name of the pool. This name can be referenced via make_queue_config().egress_pool.</p>"},{"location":"reference/kumo/make_egress_pool/ttl/","title":"ttl","text":"<p>Optional time-to-live specifying how long the pool definition should be cached.  The cache has two purposes:</p> <ul> <li>To limit the number of configurations kept in memory at any one time</li> <li>To enable data to be refreshed from external storage, such as a json data   file, or a database</li> </ul> <p>The default TTL is 60 seconds, but you can specify any duration using a string like <code>\"5 mins\"</code> to specify 5 minutes.</p>"},{"location":"reference/kumo/make_egress_source/","title":"kumo.make_egress_source","text":"<pre><code>kumo.make_egress_source { PARAMS }\n</code></pre> <p>Defines an egress source, which is an entity associated with the source of outbound traffic from the MTA.  A source must be referenced by a pool to be useful.</p> <p>This function is intended to be used inside your get_egress_source event handler.</p> <p>A source must have at a minimum a name, which will be used in logging/reporting.</p> <p><code>PARAMS</code> is a lua table which may have the following keys:</p>"},{"location":"reference/kumo/make_egress_source/ehlo_domain/","title":"ehlo_domain","text":"<p>Optional string.</p> <p>If set, specifies the hostname to be passed with the EHLO command when the server connects to a remote host.</p> <p>If not specified, the kernel will use the server's hostname.</p> <p>Note that the <code>ehlo_domain</code> set by make_egress_path, if any, takes precedence over this value.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1\n    kumo.make_egress_source {\n      name = 'ip-1',\n      source_address = '10.0.0.1',\n      ehlo_domain = 'mta1.examplecorp.com',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/ha_proxy_server/","title":"ha_proxy_server","text":"<p>Optional string.</p> <p>If both <code>ha_proxy_server</code> and <code>ha_proxy_source_address</code> are specified, then SMTP connections will be made via an HA Proxy server.</p> <p><code>ha_proxy_server</code> specifies the address and port of the proxy server.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1, via a proxy server\n    kumo.make_egress_source {\n      name = 'ip-1',\n      ha_proxy_source_address = '10.0.0.1',\n      ha_proxy_server = '10.0.0.1:5000',\n      ehlo_domain = 'mta1.examplecorp.com',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/ha_proxy_source_address/","title":"ha_proxy_source_address","text":"<p>Optional string.</p> <p>Specifies the source address that the HA Proxy server should use when initiating a connection.</p> <p>Note</p> <p>The HA Proxy protocol doesn't provide a mechanism for reporting    whether binding to this address was successful.  From the perspective    of KumoMTA, invalid proxy configuration will appear as a timeout    with no additional context.  We recommend using SOCKS5 instead    of HA proxy, as the SOCKS5 protocol is better suited for outbound    connections.</p>"},{"location":"reference/kumo/make_egress_source/name/","title":"name","text":"<p>Required string.</p> <p>The name of the source.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  -- Make a source that just has the requested name, but otherwise doesn't\n  -- specify any particular source configuration\n  return kumo.make_egress_source {\n    name = source_name,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/remote_port/","title":"remote_port","text":"<p>Optional integer.</p> <p>If set, will override the remote SMTP port number. This is useful in scenarios where your network is set to manage the egress address based on port mapping.</p> <p>This option takes precedence over kumo.make_egress_path().smtp_port.</p> <p>See also:</p> <ul> <li>kumo.make_egress_path().smtp_port.</li> <li>kumo.make_queue_config().protocol</li> </ul>","tags":["port"]},{"location":"reference/kumo/make_egress_source/socks5_proxy_server/","title":"socks5_proxy_server","text":"Since: Version 2023.06.22-51b72a83 <p>The functionality described in this section requires version 2023.06.22-51b72a83 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>If both <code>socks5_proxy_server</code> and <code>socks5_proxy_source_address</code> are specified, then SMTP connections will be made via a SOCKS5 Proxy server.</p> <p><code>socks5_proxy_server</code> specifies the address and port of the proxy server.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1, via a proxy server\n    kumo.make_egress_source {\n      name = 'ip-1',\n      socks5_proxy_source_address = '10.0.0.1',\n      socks5_proxy_server = '10.0.0.1:5000',\n      ehlo_domain = 'mta1.examplecorp.com',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/socks5_proxy_source_address/","title":"socks5_proxy_source_address","text":"Since: Version 2023.06.22-51b72a83 <p>The functionality described in this section requires version 2023.06.22-51b72a83 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>Specifies the source address that the SOCKS5 Proxy server should use when initiating a connection.</p>"},{"location":"reference/kumo/make_egress_source/source_address/","title":"source_address","text":"<p>Optional string.</p> <p>If set, specifies the local IP address that should be used as the source of any connection that will be made from this source.</p> <p>If not specified, the kernel will select the IP address automatically.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1\n    return kumo.make_egress_source {\n      name = 'ip-1',\n      source_address = '10.0.0.1',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre> <p>Note</p> <p>When using HA Proxy, the <code>source_address</code> will be used when connecting to the proxy. You should use <code>ha_proxy_source_address</code> to specify the actual address to use from the HA Proxy instance to the destination.</p>"},{"location":"reference/kumo/make_egress_source/ttl/","title":"ttl","text":"<p>Optional time-to-live specifying how long the source definition should be cached.  The cache has two purposes:</p> <ul> <li>To limit the number of configurations kept in memory at any one time</li> <li>To enable data to be refreshed from external storage, such as a json data   file, or a database</li> </ul> <p>The default TTL is 60 seconds, but you can specify any duration using a string like <code>\"5 mins\"</code> to specify 5 minutes.</p>"},{"location":"reference/kumo/make_listener_domain/","title":"kumo.make_listener_domain","text":"<pre><code>kumo.make_listener_domain { PARAMS }\n</code></pre> <p>Make a listener-domain configuration object.</p> <p>The get_listener_domain event expects one of these to be returned to it (or a <code>nil</code> value).</p> <p>A listener-domain contains information that affects whether an incoming SMTP message will be accepted and/or relayed.</p> <p>By default, unless the client is connecting from one of the <code>relay_hosts</code>, relaying is denied.</p> <p><code>PARAMS</code> is a lua table that can accept the keys listed below.</p>"},{"location":"reference/kumo/make_listener_domain/log_arf/","title":"log_arf","text":"<p>Affects how incoming RFC 5965 formatted ARF feedback report messages are handled.</p> <p>Can be one of the following values:</p> <ul> <li><code>\"Ignore\"</code> - do not parse or care whether the incoming message might    be an ARF report. (Since: Version 2025.05.06-b29689af)</li> <li><code>\"LogThenRelay\"</code> - if the incoming message is a feedback report, then    log the <code>Feedback</code> record and continue to allow the message to be    enqueued for relay.  You will also see a <code>Reception</code> record for the relayed    message, as well as records for its attempts to relay after reception.    (Since: Version 2025.05.06-b29689af)</li> <li><code>\"LogThenDrop\"</code> - if the incoming message is a feedback report, then log    the <code>Feedback</code> record, but silently drop the message without relaying it.    There will be no additional log records for the message.    (Since: Version 2025.05.06-b29689af)</li> <li><code>false</code> - equivalent to <code>\"Ignore\"</code>.  This is for backwards compatibility    with earlier versions of KumoMTA and we recommend using <code>\"Ignore\"</code> explicitly    in your configuration moving forwards.</li> <li><code>true</code> - equivalent to <code>\"LogThenRelay\"</code>.  This is for backwards compatibility    with earlier versions of KumoMTA and we recommend using <code>\"LogThenRelay\"</code>    explicitly in your configuration moving forwards if you want that behavior,    although you will likely prefer to use <code>\"LogThenDrop\"</code> in most cases.</li> </ul> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  if domain == 'fbl.example.com' then\n    return kumo.make_listener_domain {\n      log_arf = 'LogThenDrop',\n    }\n  end\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/log_oob/","title":"log_oob","text":"<p>Affects how incoming RFC 3464 formatted out-of-band bounce report messages are handled.</p> <p>Can be one of the following values:</p> <ul> <li><code>\"Ignore\"</code> - do not parse or care whether the incoming message might    be an OOB report. (Since: Version 2025.05.06-b29689af)</li> <li><code>\"LogThenRelay\"</code> - if the incoming message is an OOB report, then    log the <code>OOB</code> record and continue to allow the message to be    enqueued for relay.  You will also see a <code>Reception</code> record for the relayed    message, as well as records for its attempts to relay after reception.    (Since: Version 2025.05.06-b29689af)</li> <li><code>\"LogThenDrop\"</code> - if the incoming message is an OOB report, then log    the <code>OOB</code> record, but silently drop the message without relaying it.    There will be no additional log records for the message.    (Since: Version 2025.05.06-b29689af)</li> <li><code>false</code> - equivalent to <code>\"Ignore\"</code>.  This is for backwards compatibility    with earlier versions of KumoMTA and we recommend using <code>\"Ignore\"</code> explicitly    in your configuration moving forwards.</li> <li><code>true</code> - equivalent to <code>\"LogThenRelay\"</code>.  This is for backwards compatibility    with earlier versions of KumoMTA and we recommend using <code>\"LogThenRelay\"</code>    explicitly in your configuration moving forwards if you want that behavior,    although you will likely prefer to use <code>\"LogThenDrop\"</code> in most cases.</li> </ul> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  if domain == 'bounce.example.com' then\n    return kumo.make_listener_domain {\n      log_oob = 'LogThenDrop',\n    }\n  end\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/relay_from/","title":"relay_from","text":"<p>Optional CIDR list. Defaults to an empty list. If the connected client is from an IP address that matches the CIDR list, and the sending domain matches the requested domain, then relaying will be allowed.</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  if domain == 'send.example.com' then\n    return kumo.make_listener_domain {\n      relay_from = { '10.0.0.0/24' },\n    }\n  end\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/relay_to/","title":"relay_to","text":"<p>Optional boolean. Defaults to <code>false</code>. When set to <code>true</code>, allows relaying mail from anyone, so long as it is addressed to the requested domain.</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  if domain == 'example.com' then\n    return kumo.make_listener_domain {\n      relay_to = true,\n    }\n  end\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/relay_to/#enable-relaying-based-on-smtp-authentication","title":"Enable relaying based on SMTP authentication","text":"<p>This example shows how to use the connection metadata information to determine if the current session is authenticated, and use that to govern whether relaying is allowed.</p> <p>In this example, any user is permitted to relay to anywhere:</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  if conn_meta:get_meta 'authz_id' then\n    -- We're authenticated as someone.\n    -- Allow relaying\n    return kumo.make_listener_domain {\n      relay_to = true,\n    }\n  end\nend)\n</code></pre> <p>A more sophisticated configuration might use a mapping to control which domains are allowed relaying based on the authorization id:</p> <pre><code>local RELAY_BY_DOMAIN = {\n  ['example.com'] = {\n    -- The user daniel is permitted to relay to example.com\n    ['daniel'] = true,\n  },\n}\n\nkumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  local dom_map = RELAY_BY_DOMAIN[domain]\n  if dom_map then\n    local authz_id = conn_meta:get_meta 'authz_id'\n    if dom_map[authz_id] then\n      return kumo.make_listener_domain {\n        relay_to = true,\n      }\n    end\n  end\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/","title":"kumo.make_queue_config","text":"<pre><code>kumo.make_queue_config { PARAMS }\n</code></pre> <p>Constructs a configuration object that specifies how a queue will behave.</p> <p>This function should be called from the get_queue_config event handler to provide the configuration for the requested queue.</p> <p>The following keys are possible:</p>"},{"location":"reference/kumo/make_queue_config/egress_pool/","title":"egress_pool","text":"<p>The name of the egress pool which should be used as the source of this traffic.</p> <p>If you do not specify an egress pool, a default pool named <code>unspecified</code> will be used. That pool contains a single source named <code>unspecified</code> that has no specific source settings: it will just make a connection using whichever IP the kernel chooses.</p> <p>See kumo.make_egress_pool().</p>"},{"location":"reference/kumo/make_queue_config/max_age/","title":"max_age","text":"<p>Limits how long a message can remain in the queue. The default value is <code>\"7 days\"</code>.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  return kumo.make_queue_config {\n    -- Age out messages after being in the queue for 20 minutes\n    max_age = '20 minutes',\n  }\nend)\n</code></pre> <p>Note</p> <p>If you are using message:set_scheduling() to configure a custom <code>expires</code> timestamp on a per-message basis, then <code>max_age</code> will be ignored for those messages and only your <code>expires</code> timestamp will be considered for expiration.</p>"},{"location":"reference/kumo/make_queue_config/max_message_rate/","title":"max_message_rate","text":"Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>Specifies the maximum permitted rate at which messages can move from this scheduled queue and into the ready queue for the appropriate egress source.</p> <p>The value is of the form <code>quantity/period</code> where quantity is a number and period can be a measure of time.</p> <p>Examples of throttles:</p> <pre><code>\"10/s\" -- 10 per second\n\"10/sec\" -- 10 per second\n\"10/second\" -- 10 per second\n\n\"50/m\" -- 50 per minute\n\"50/min\" -- 50 per minute\n\"50/minute\" -- 50 per minute\n\n\"1,000/hr\" -- 1000 per hour\n\"1_000/h\" -- 1000 per hour\n\"1000/hour\" -- 1000 per hour\n\n\"10_000/d\" -- 10,000 per day\n\"10,000/day\" -- 10,000 per day\n</code></pre> <p>Throttles are implemented using a Generic Cell Rate Algorithm.</p> <p>If the throttle is exceeded the message will be re-inserted into the scheduled queue with a delay based on the acceptance rate of the throttle.</p> <p>This option is distinct from the egress path max_message_rate option in that this one applies to a specific scheduled queue, whilst the egress path option applies to the ready queue for a specific egress path, through which multiple scheduled queues send out to the internet.</p> <p>If you have configured <code>max_message_rate</code> both here and in an egress path, the effective maximum message rate will be the lesser of the two values; both constraints are applied independently from each other at different stages of processing.</p>"},{"location":"reference/kumo/make_queue_config/max_retry_interval/","title":"max_retry_interval","text":"<p>Messages are retried using an exponential backoff as described under retry_interval below. max_retry_interval sets an upper bound on the amount of time between delivery attempts.</p> <p>The default is that there is no upper limit.</p> <p>The value is expressed in seconds.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  return kumo.make_queue_config {\n    -- Retry at most every hour\n    max_retry_interval = '1 hour',\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/protocol/","title":"protocol","text":"<p>Configure the delivery protocol. The default is to use SMTP to the domain associated with the queue, but you can also configure delivering to a local maildir, or using custom lua code to process a message</p>","tags":["port"]},{"location":"reference/kumo/make_queue_config/protocol/#example-of-smart-hosting-with-the-smtp-protocol","title":"Example of smart-hosting with the SMTP protocol","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Rather than relying on MX resolution, you can provide an explicit list of MX host names or IP addresses to which the queue should deliver. The addresses will be tried in the order specified.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'smarthost.example.com' then\n    -- Relay via some other internal infrastructure.\n    -- Enclose IP (or IPv6) addresses in `[]`.\n    -- Otherwise the name will be resolved for A and AAAA records\n    return kumo.make_queue_config {\n      protocol = {\n        smtp = {\n          mx_list = {\n            'smart.host.local',\n            { name = 'mx.example.com', addr = '10.0.0.1' },\n          },\n        },\n      },\n    }\n  end\n  -- Otherwise, just use the defaults\n  return kumo.make_queue_config {}\nend)\n</code></pre> <p>Since: Version 2025.10.06-5ec871ab</p> <p>The functionality described in this outlined box requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>You may now use port numbers to override the outbound port number.</p> <pre><code>return kumo.make_queue_config {\n  protocol = {\n    smtp = {\n      mx_list = {\n        'smart.host.local:2025',\n        { name = 'mx.example.com', addr = '10.0.0.1:2025' },\n      },\n    },\n  },\n}\n</code></pre> <p>Note that a <code>remote_port</code> defined in the egress source will override a port that you define here.  A port number defined here in <code>mx_list</code> overrides a port number defined by <code>make_egress_path</code> in your shaping configuration.</p>","tags":["port"]},{"location":"reference/kumo/make_queue_config/protocol/#example-of-using-the-maildir-protocol","title":"Example of using the Maildir protocol","text":"<pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'maildir.example.com' then\n    -- Store this domain into a maildir, rather than attempting\n    -- to deliver via SMTP\n    return kumo.make_queue_config {\n      protocol = {\n        maildir_path = '/var/tmp/kumo-maildir',\n      },\n    }\n  end\n  -- Otherwise, just use the defaults\n  return kumo.make_queue_config {}\nend)\n</code></pre> <p>Note</p> <p>Maildir support is present primarily for functional validation rather than being present as a first class delivery mechanism.</p> <p>Failures to write to the maildir will cause the message to be delayed and retried approximately 1 minute later.  The normal message retry schedule does not apply.</p>","tags":["port"]},{"location":"reference/kumo/make_queue_config/protocol/#specifying-directory-and-file-modes-for-maildir","title":"Specifying directory and file modes for maildir","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>If you are sharing the maildir with something like dovecot it can sometimes be desirable to explicitly control the file permissions of the directory structure and files that are created.  You can achieve this via the <code>dir_mode</code> and <code>file_mode</code> parameters.</p> <p>Note</p> <p>Lua doesn't support native octal literal numbers, so you must use <code>tonumber</code> as shown in the example below if you wish to specify the modes in octal</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'maildir.example.com' then\n    return kumo.make_queue_config {\n      protocol = {\n        maildir_path = '/var/tmp/kumo-maildir',\n        dir_mode = tonumber('775', 8),\n        file_mode = tonumber('664', 8),\n      },\n    }\n  end\nend)\n</code></pre>","tags":["port"]},{"location":"reference/kumo/make_queue_config/protocol/#advanced-maildir-path","title":"Advanced Maildir Path","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>If you are sharing the maildir with something like dovecot it is desirable to be able to put messages into per-user maildirs. You can achieve this through templated paths.</p> <p>The <code>maildir_path</code> field supports template expansion.</p> <p>The following values are pre-defined in the context:</p> <ul> <li><code>meta</code> - the full set of metadata from the message.</li> <li><code>queue</code> - the effective queue name of the message.</li> <li><code>campaign</code> - the campaign associated with the message (may be nil).</li> <li><code>tenant</code> - the tenant associated with the message (may be nil).</li> <li><code>domain</code> - the domain portion of the queue name (usually the same thing     as <code>domain_part</code>, but may be different if you are using advanced queue     name assignment).</li> <li><code>routing_domain</code> - the routing domain portion of the queue (may be nil).</li> <li><code>local_part</code> - the user mailbox portion of the envelope recipient email address.</li> <li><code>domain_part</code> - the domain portion of the envelope recipient email address.</li> <li><code>email</code> - the full envelope recipient email address.</li> <li><code>sender_local_part</code> the user mailbox portion of the envelope sender email address.</li> <li><code>sender_domain_part</code> the domain portion of the envelope sender email address.</li> <li><code>sender_email</code> the full envelope sender email address.</li> </ul> <p>In the example below, each recipient domain has its own directory created (although in this example, we only do this for <code>maildir.example.com</code>), and each individual user at that domain has their own maildir created.</p> <p>\"created\" here means that kumomta will create it if it doesn't already exist, and deliver to it in either case.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'maildir.example.com' then\n    return kumo.make_queue_config {\n      protocol = {\n        maildir_path = '/maildirs/{{ domain_part }}/{{ local_part }}',\n        dir_mode = tonumber('775', 8),\n        file_mode = tonumber('664', 8),\n      },\n    }\n  end\nend)\n</code></pre>","tags":["port"]},{"location":"reference/kumo/make_queue_config/protocol/#using-lua-as-a-delivery-protocol","title":"Using Lua as a delivery protocol","text":"<pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'webhook' then\n    -- Use the `make.webhook` event to handle delivery\n    -- of webhook log records\n    return kumo.make_queue_config {\n      protocol = {\n        custom_lua = {\n          -- this will cause an event called `make.webhook` to trigger.\n          -- You can pick any name for this event, so long as it doesn't\n          -- collide with a pre-defined event, and so long as you bind\n          -- to it with a kumo.on call\n          constructor = 'make.webhook',\n        },\n      },\n    }\n  end\n  return kumo.make_queue_config {}\nend)\n\n-- This event will be called each time we need to make a connection.\n-- It needs to return a lua object with a `send` method\nkumo.on('make.webhook', function(domain, tenant, campaign)\n  -- Create the connection object\n  local connection = {}\n\n  -- define a send method on the connection object.\n  -- The return value is the disposition string for a successful\n  -- delivery; that string will get logged in the resulting log record.\n  -- If the delivery failed, you can use `kumo.reject` to raise the\n  -- error with an appropriate 400 or 500 code.\n  -- 400 codes will be retried later. 500 codes will log a permanent\n  -- failure and no further delivery attempts will be made for the message.\n  function connection:send(message)\n    print(message:get_data())\n    if failed then\n      kumo.reject(400, 'failed for some reason')\n    end\n    return 'OK'\n  end\n\n  return connection\nend)\n</code></pre> <p>See should_enqueue_log_record for a more complete example.</p>","tags":["port"]},{"location":"reference/kumo/make_queue_config/reap_interval/","title":"reap_interval","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional duration string. The default is <code>\"10m\"</code>.  It controls how long the queue should remain empty and idle before we reap it from the queue management layer and free its associated resources and metrics.</p>"},{"location":"reference/kumo/make_queue_config/refresh_interval/","title":"refresh_interval","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional duration string. The default is <code>\"1m\"</code>.  It controls how long the queue should wait before refreshing the configuration for that queue by triggering the get_queue_config event when the refresh_strategy is set to <code>Ttl</code>.</p>"},{"location":"reference/kumo/make_queue_config/refresh_strategy/","title":"refresh_strategy","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Defines the refresh strategy that should be used to determine when this particular queue configuration object needs to be refreshed.</p> <p>Possible values are:</p> <ul> <li><code>\"Ttl\"</code> - the default value. Use the refresh_interval value.</li> <li><code>\"Epoch\"</code> - remains current until the Configuration   Monitoring system   determines that the configuration epoch has changed.</li> </ul>"},{"location":"reference/kumo/make_queue_config/retry_interval/","title":"retry_interval","text":"<p>Messages are retried using an exponential backoff.  retry_interval sets the base interval; if a message cannot be immediately delivered and encounters a transient failure, then a (jittered) delay of retry_interval seconds will be applied before trying again. If it transiently fails a second time, retry_interval will be doubled and so on, doubling on each attempt.</p> <p>The default is <code>\"20 minutes\"</code>.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  return kumo.make_queue_config {\n    retry_interval = '20 minutes',\n  }\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/shrink_policy/","title":"shrink_policy","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Danger</p> <p>This is an advanced option whose use is not recommended without deep knowledge of KumoMTA and the overall system constraints.</p> <p>Controls the message shrinking policy when messages are placed into the corresponding scheduled queue with a due date in the future.</p> <p>The default behavior when the policy is left unspecified, and for older versions of KumoMTA, is <code>\"ShrinkDataAndMeta\"</code>, which releases both the message data and metadata, resulting in a minimal per-message overhead while messages are scheduled for delivery in the future.</p> <p>The purpose of <code>shrink_policy</code> is to adjust how aggressively that memory is released depending on how long it will be before the message will next be retried.</p> <p>The <code>shrink_policy</code> option is an array of <code>QueueShrinkPolicy</code> values that have the following fields:</p> <ul> <li><code>interval</code> - a time interval expressed using a duration string like <code>\"60 s\"</code>    for 60 seconds.  This value will be compared against the time until the     message is next due for delivery to decide whether the entry matches.</li> <li><code>policy</code> - a <code>MemoryReductionPolicy</code> value, which can be one of:<ul> <li><code>\"ShrinkDataAndMeta\"</code> - release both the message data and metadata</li> <li><code>\"ShrinkData\"</code> - release just the message data, keeping metadata in memory</li> <li><code>\"NoShrink\"</code> - do not release either data or metadata (very dangerous!   use with caution!)</li> </ul> </li> </ul> <p>The way that <code>shrink_policy</code> is processed is that each element of the policy is compared against the remaining time until due. If the the remaining time is &gt;= the interval of the entry, then the policy value from that entry is selected. This repeats until the end of the policy list has been processed.</p> <p>As an example, if you configure the <code>shrink_policy</code> like this:</p> <pre><code>kumo.on(\n  'get_queue_config',\n  function(domain_name, tenant, campaign, routing_domain)\n    return kumo.make_queue_config {\n      max_retry_interval = '20 minutes',\n      shrink_policy = {\n        { interval = '0 s', policy = 'ShrinkData' },\n        { interval = '60 s', policy = 'ShrinkDataAndMeta' },\n      },\n    }\n  end\n)\n</code></pre> <p>then the system behavior will be:</p> <ul> <li> <p>When a message is added to the scheduled queue and it is due within the next   <code>60s</code>, then we'll release just the message data and keep the message metadata   in memory.</p> </li> <li> <p>If the message is due further into the future than <code>60s</code>, then both the data   and metadata will be freed from RAM.</p> </li> </ul> <p>It might be advantageous to configure the <code>shrink_policy</code> in this way if you have a lot of available RAM and want to avoid spool IO for messages that will be retried in the near future, especially if you think that when the message is next due it might be subject to a suspension or bounce: you can save a load operation to recall the message metadata to compare against the suspension/bounce rules in that situation.</p> <p>Caution</p> <p>When memory usage hits the soft limit, KumoMTA assumes that messages in the scheduled queue are fully \"shrunk\", having neither their data or metadata loaded.</p> <p>When you use <code>shrink_policy</code> to change that assumption, the effectiveness of its low memory recovery options is reduced because it does not sweep the scheduled queues to ensure that all the messages are fully shrunk.</p> <p>You need to satisfy yourself that you have appropriate constraints configured to avoid an OOM-related kill when you change the <code>shrink_policy</code>.</p>","tags":["memory"]},{"location":"reference/kumo/make_queue_config/strategy/","title":"strategy","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Optional string to specify the scheduled queue strategy.  There are two possible values:</p> <ul> <li><code>\"TimerWheel\"</code> - The timer wheel has <code>O(1)</code> insertion and <code>O(1)</code>   pop costs, making it good for very large scheduled queues, but that comes in   exchange for a flat periodic tick overhead.  As the number of scheduled queues   increases and/or the <code>retry_interval</code> decreases, so does the aggregate overhead   of maintaining timerwheel queues.</li> <li><code>\"SkipList\"</code> - A skiplist has <code>O(log n)</code> insertion and <code>O(1)</code> pop costs,   making it a good general purpose queue, but becomes more expensive to insert   into as the size of the queue increases.  That higher insertion cost is in   exchange for the overall maintenance being cheaper, as the queue can go to   sleep until the time of the next due item.  The ongoing and aggregate   maintenance is therefore cheaper than a <code>TimerWheel</code> but the worst-case   scenario where the destination is not accepting mail and causing the   scheduled queue to grow is logarithmically more expensive as the queue   grows.</li> <li><code>\"SingletonTimerWheel\"</code> - Like <code>\"TimerWheel\"</code> above, but there is one shared   wheel for all queues that use the <code>\"SingletonTimerWheel\"</code> strategy. This   mitigates the per-queue aggregate maintenance overhead mentioned above, and   is ideal especially for deployments with very many (more than 100,000 or so)   scheduled queues. This option is the default in <code>dev</code> builds and will be   the default in the next stable release.</li> </ul> <p>The default value depends on the version:</p> Version Default 2024.09.02-c5476b89 and earlier <code>\"TimerWheel\"</code> (Since: Version 2024.11.08-d383b033) <code>\"SingletonTimerWheel\"</code> <p>Which should you use? Whichever works best for your environment! Make sure that you test normal healthy operation with a lot of queues as well as the worst case scenario where those queues are full and egress is blocked.</p> <p>If you have very short <code>retry_interval</code> set for the majority of your queues you may wish to adopt <code>SkipList</code> for its lower idle CPU cost, or alternatively use <code>TimerWheel</code> and find a <code>timerwheel_tick_interval</code> that works for your typical number of queues.</p> <p>Note</p> <p>Changing the strategy for a given queue requires that the queue either be aged out, or for kumod to be restarted, before it will take effect.  This restriction may be removed in a future release.</p>"},{"location":"reference/kumo/make_queue_config/timerwheel_tick_interval/","title":"timerwheel_tick_interval","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>When using the default <code>strategy = \"TimerWheel\"</code>, the timer wheel needs to be ticked regularly in order to promote messages into the ready queue. The default tick interval is computed as <code>retry_interval / 20</code> and clamped to be within the range <code>&gt;= 1s &amp;&amp; &lt;= 1m</code>.</p> <p>If you have a short <code>retry_interval</code> and a lot of scheduled queues you may find that your system is spending more time ticking over than is desirable, so you can explicitly select the tick interval via this option.</p> <p>The value is an optional string duration like <code>1m</code>.</p> <p>If you have to set this, our recommendation is generally for this to be as long as possible.</p> <p>Note</p> <p>The maintainer will also tick over whenever the refresh_interval elapses, so there isn't a tangible benefit to setting <code>timerwheel_tick_interval</code> larger than <code>refresh_interval</code>.</p>"},{"location":"reference/kumo/start_esmtp_listener/","title":"kumo.start_esmtp_listener","text":"<pre><code>kumo.start_esmtp_listener { PARAMS }\n</code></pre> <p>Configure and start ESMTP service.</p> <p>This function should be called only from inside your init event handler.</p> <p>To listen on multiple IP/port combinations, simply call <code>kump.start_esmtp_listener</code> multiple times with the appropriate parameters.</p> <pre><code>kumo.on('init', function()\n  -- use the same settings for ports 25 and 2026, without repeating them all\n  for _, port in ipairs { 25, 2026 } do\n    kumo.start_esmtp_listener {\n      listen = '0:' .. tostring(port),\n      relay_hosts = { '0.0.0.0/0' },\n    }\n  end\nend)\n</code></pre> <p>Note</p> <p>You can also use the smtp_server_get_dynamic_parameters event to dynamically adjust listener parameters. You cannot bind new ports or IPs that way, but if you are using the \"any\" address such as <code>0.0.0.0</code> or <code>::</code>, you can dynamically refine the parameters for IP-based virtual service.</p> <p><code>PARAMS</code> is a lua table that can accept the keys listed below:</p>"},{"location":"reference/kumo/start_esmtp_listener/allow_xclient/","title":"allow_xclient","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Danger</p> <p>Take care to apply this ONLY in an appropriate <code>peer</code> block, otherwise you risk a variety of security/authentication related bypasses.</p> <p>When set to <code>true</code>, allows the connected session to use the XCLIENT ESMTP extension.</p> <p><code>XCLIENT</code> is used primarily in testing environments to facilitate validation of authentication checks that are based upon the IP address of the peer or the server itself.</p> <p>KumoMTA supports the following XCLIENT attributes:</p> <ul> <li><code>ADDR</code> and <code>PORT</code>: cause the <code>received_from</code> metadata to change    to reflect the specified address and/or port.</li> <li><code>DESTADDR</code> and <code>DESTPORT</code>: cause the <code>received_via</code> metadata to    change to reflect the specified address and/or port.</li> </ul> <p>None of the other XCLIENT attributes are supported at the time of writing.</p> <p>After <code>XCLIENT</code> has been successfully negotiated, the ESMTP listener re-evaluates the parameters (especially the via and peer blocks), and triggers smtp_server_get_dynamic_parameters to ensure that all the listener configuration has been updated to match the adjusted <code>via</code> and <code>from</code> addresses.</p> <pre><code>kumo.start_esmtp_listener {\n  -- Always use an appropriate `peer` block to scope XCLIENT to\n  -- networks that you trust at the highest levels\n  peer = {\n    ['127.0.0.1'] = {\n      allow_xclient = true,\n    },\n  },\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/banner/","title":"banner","text":"<p>Customize the banner that is returned to clients when they first connect. The configured hostname will be automatically prepended to this text, so you should not include a hostname.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  banner = 'Welcome to KumoMTA!',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/batch_handling/","title":"batch_handling","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>SMTP messages can have an envelope that includes multiple recipients.  Each recipient will receive a copy of the message.  If multiple recipients share the same mailbox provider then it is advantageous from a bandwidth and efficiency perspective to relay that message to that provider as a single message with a list of multiple recipients, rather than sending one distinct copy per recipient.</p> <p>The <code>batch_handling</code> option specifies how incoming multi-recipient transactions are split into outgoing batches.</p> <p>It can have one of two values:</p> <ul> <li><code>\"BifurcateAlways\"</code> - this is the default and recommended setting for     sender-focused deployments. Every incoming recipient is placed into a     separate batch and tracked separately.</li> <li><code>\"BatchByDomain\"</code> - recipients with exactly the same domain portion are     grouped together, resulting in one outgoing batch per unique domain.</li> </ul> <p>If you have more advanced requirements around managing batching/splitting, then you can implement them via the smtp_server_split_transaction event handler.</p> <pre><code>kumo.start_esmtp_listener {\n  batch_handling = 'BatchByDomain',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/client_timeout/","title":"client_timeout","text":"<p>Controls the timeout used when reading data from the client. If no data arrives within the specified timeout, the server will close the connection to the client.</p> <pre><code>kumo.start_esmtp_listener {\n  -- The default is 1 minute\n  client_timeout = '1 minute',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/data_buffer_size/","title":"data_buffer_size","text":"<p>Specified the size of the buffer used to read chunks of the message payload during the <code>DATA</code> phase of the SMTP transaction.  Making this larger will improve the throughput in terms of bytes-per-syscall at the expense of using more RAM.</p> <p>The default size is 128KB (<code>128 * 1024</code>).  If your average message size is significantly larger than the default, then you may wish to increase this value.</p>"},{"location":"reference/kumo/start_esmtp_listener/data_processing_timeout/","title":"data_processing_timeout","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Sets an upper bound on the time that the SMTP server will allow for processing the DATA portion of an SMTP transaction.  This time period covers internal processing of the DATA once it has been received.</p> <p>The default for this is <code>\"5 minutes\"</code>.</p> <p>Note</p> <p>The behavior of this option is probably not quite what you might expect, so read carefully!</p> <p>The primary purpose of this option is to prevent KumoMTA from taking final responsibility for relaying a message if it has taken longer than the defined <code>data_processing_timeout</code>.   It does not guarantee that there will be a response to DATA within the specified timeout.</p> <p>The main benefit of this is to avoid uncertainty with the injecting client: if processing DATA takes longer than the timeout configured in the client, it is likely that the client will treat the timeout as a transient failure and re-try delivery.  If the message was actually accepted by KumoMTA, but just took a little bit longer, then the overall result would be a duplicate send of the same logical message content.</p> <p>If <code>data_processing_timeout</code> is set to a duration that is just a little less than the client timeout then the duplicate delivery risk in that situation is mitigated.</p> <p>The way this works is that the majority of DATA-time processing will be run within the specified deadline, returning a <code>451 4.4.5 data_processing_timeout exceeded</code> if the time limit is exceeded.  Depending on the server configuration and workload, there may be some portions of processing that cannot be cancelled if they take too long (most spooling configurations have a code path where the IO cannot be timed out, for example).</p> <p>If, by the time KumoMTA is ready to insert the message into the outbound processing flow, the time elapsed exceeds the <code>data_processing_timeout</code> then KumoMTA will unwind the reception of the message from the spool and issue a transient failure to the client.</p> <p>In the event that a message is \"unwound\" you will observe both a <code>Reception</code> and an internal <code>Bounce</code> record for the message explaining that the insertion failed during reception.</p> <pre><code>kumo.start_esmtp_listener {\n  -- The default is 5 minutes\n  data_processing_timeout = '5 minutes',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/deferred_queue/","title":"deferred_queue","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>Warning</p> <p>Carefully read and understand this option before enabling it. It should NOT be used on the public internet, and only enabled for listeners where you implicitly trust any incoming connection.</p> <p>When this option is set to <code>true</code>, after receiving the DATA portion of an incoming message, the processing flow is altered such that the latency of normal post-DATA processing is hidden from the injecting client.</p> <p>Info</p> <p>Enabling this option will increase your average incoming SMTP transaction latency slightly, and increase IOPS pressure to your spool and logging devices, but will clamp the worst-case latency outliers for your incoming SMTP transaction latency.</p> <ul> <li>The <code>smtp_server_message_received</code> event is NOT triggered</li> <li>Trace and supplemental headers are produced and added to the message   according to that unprocessed state of the message</li> <li>The message is saved to spool (unless deferred_spool is enabled)</li> <li>The message is queued to a special queue named <code>deferred_smtp_inject.kumomta.internal</code>.</li> <li>A <code>Reception</code> record is recorded that shows that it was queued to that queue</li> <li>A <code>250 ok</code> response is returned to the injector.  It is not possible to   return anything other than a 250 response when <code>deferred_queue = true</code>.</li> </ul> <p>The <code>deferred_smtp_inject.kumomta.internal</code> queue will process messages according to these steps:</p> <ul> <li>The smtp_server_message_deferred_inject event will be triggered</li> <li>If returns without error:</li> <li>A <code>DeferredInjectionRebind</code> record is logged for the message showing that the message     was rebound into a different queue via the <code>DeferredSmtpInjection</code> protocol.</li> <li>The message will be rebound into the appropriate queue per the     normal rules based on the message metadata and envelope recipient.</li> <li>If the event triggered a <code>kumo.reject</code> with a 5xx code, a <code>Bounce</code> record   will be recorded and the message will be removed from the spool.</li> <li>In other error cases, a <code>TransientFailure</code> record will be recorded and   the message will attempt processing again later. The   <code>deferred_smtp_inject.kumomta.internal</code> scheduled queue has a hard-coded base   retry interval of one minute, and will respect the product default   exponential backoff for up to 1 week.</li> </ul> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  deferred_queue = true,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/deferred_queue/#shaping-considerations","title":"Shaping Considerations","text":"<p>If you are using the shaping helper, you should consider adding:</p> <pre><code>[\"deferred_smtp_inject.kumomta.internal\"]\n# The domain is fake and doesn't resolve, don't try to resolve it\nmx_rollup = false\n# Set connection_limit to a small multiple of the number of\n# CPUs in the system.  Experiment to find what works best in\n# your environment.  Try either 1x or 2x number of cpus to start.\nconnection_limit = 12\n# Increase max_ready to something appropriate; since this queue\n# is a fan-in, it will typically hold more messages than your\n# other queues\nmax_ready = 80000\n</code></pre> <p>If you are doing shaping via lua, then you can more directly handle the configuration:</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    if routing_domain == 'deferred_smtp_inject.kumomta.internal' then\n      return kumo.make_egress_path {\n        connection_limit = kumo.available_parallelism(),\n        refresh_strategy = 'Epoch',\n        max_ready = 80000,\n      }\n    end\n    -- do the rest of your shaping configuration here\n  end\n)\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/deferred_spool/","title":"deferred_spool","text":"<p>Danger</p> <p>Enabling this option may result in loss of accountability for messages. You should satisfy yourself that your system is able to recognize and deal with that scenario if/when it arises.</p> <p>When set to <code>true</code>, incoming messages are retained in memory until after their first transient delivery failure.</p> <p>This can have a dramatic impact on throughput by removing local storage I/O as a bottleneck, but introduces a risk of forgetting about those messages if the machine loses power or if the kumod process exits unexpectedly.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  deferred_spool = false,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/hostname/","title":"hostname","text":"<p>Specifies the hostname to report in the banner and other SMTP responses. The default, if unspecified, is to use the hostname of the local machine.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  hostname = 'mail.example.com',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/invalid_line_endings/","title":"invalid_line_endings","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Specifies the behavior when the received DATA contains invalid line endings.  The SMTP protocol requires that each line of the DATA be separated by canonical CRLF sequences. Immediately after receiving the DATA payload, but before any other policy events are triggered, if the received DATA is non-conforming the value of this parameter is checked to determine what to do. It has three possible values:</p> <ul> <li><code>\"Deny\"</code> - this is the default. The incoming message will be     rejected.</li> <li><code>\"Allow\"</code> - The incoming message will be accepted. Depending     on the configured policy, some later policy actions may fail     to parse the message, and DKIM signatures may be created that     are not possible to validate correctly.  There is no guarantee     that any resulting message will be routable to its intended     destination.</li> <li><code>\"Fix\"</code> - the line endings will be normalized to CRLF and the     message will be accepted.  It's possible for this to invalidate     any signatures that may have already been present in the message.</li> </ul>"},{"location":"reference/kumo/start_esmtp_listener/line_length_hard_limit/","title":"line_length_hard_limit","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>The SMTP protocol specification defines the maximum length of a line in the protocol.  The limit exists because there are SMTP implementations that are simply not capable of reading longer lines.</p> <p>This option sets the limit on line length that is enforced by KumoMTA. The default matches the RFC specified limit of <code>998</code> + CRLF.  When the line length limit is exceeded, KumoMTA will return a \"line too long\" error to the client.</p> <p>You can raise this limit, but doing so may allow messages to be accepted that will be unable to be relayed to other SMTP implementations.</p>"},{"location":"reference/kumo/start_esmtp_listener/listen/","title":"listen","text":"<p>Specifies the local IP and port number to which the ESMTP service should bind and listen.</p> <p>Use <code>0.0.0.0</code> to bind to all IPv4 addresses.</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n}\n</code></pre> <p>Note</p> <p>This option cannot be used in dynamic listener contexts such as within via, peer or within the parameters returned from smtp_server_get_dynamic_parameters. It can only be used directly at the top level within the <code>kumo.start_esmtp_listener</code> call.</p>"},{"location":"reference/kumo/start_esmtp_listener/max_connections/","title":"max_connections","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Specifies the maximum number of concurrent connections that are permitted to this listener. Connections above this will be accepted and then closed immediately with a <code>421 4.3.2</code> response.</p> <p>The default value for this is <code>32768</code>, which is approximately half of the possible number of ports for a given IP address, leaving the other half available for outgoing connections.</p> <p>Each time a connection is denied due to hitting this limit, the <code>total_connections_denied</code> counter is incremented for the <code>esmtp_listener</code> service.</p> <p>In earlier releases, there was no kumod-controlled upper bound on the number of connections, and as many as the kernel allowed would be permitted.</p> <p>Note</p> <p>This option cannot be used in dynamic listener contexts such as within via, peer or within the parameters returned from smtp_server_get_dynamic_parameters. It can only be used directly at the top level within the <code>kumo.start_esmtp_listener</code> call.</p>"},{"location":"reference/kumo/start_esmtp_listener/max_message_size/","title":"max_message_size","text":"<p>Specifies the maximum size of a message that can be relayed through this listener, in bytes.</p> <p>The default is <code>20 MB</code> (<code>20 * 1024 * 1024</code>).</p> <p>Messages exceeding this size will be rejected.</p>"},{"location":"reference/kumo/start_esmtp_listener/max_messages_per_connection/","title":"max_messages_per_connection","text":"<p>Specifies the maximum number of consecutive <code>MAIL FROM</code> commands that can be issued for a given SMTP connection.  When the limit is reached, transient failures will be returned to those additional <code>MAIL FROM</code> commands.</p> <pre><code>kumo.start_esmtp_listener {\n  max_messages_per_connection = 10000,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/max_recipients_per_message/","title":"max_recipients_per_message","text":"<p>Specifies the maximum number of consecutive <code>RCPT TO</code> commands that can be issued for a given SMTP transaction.  When the limit is reached, transient failures will be returned to those additional <code>RCPT TO</code> commands.</p> <pre><code>kumo.start_esmtp_listener {\n  max_recipients_per_message = 1024,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/meta/","title":"meta","text":"Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Pre-define connection metadata values.</p> <p>The value of this option is a mapping of metadata key strings to corresponding metadata values.  Each of these will be set in the connection metadata object.</p> <p>In this example, the key <code>hello</code> is assigned the value <code>there</code> when the connection is opened:</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n  meta = {\n    hello = 'there',\n  },\n}\n</code></pre> <p><code>meta</code> can be combined with via and peer to adjust the metadata based on the local or remote address associated with the session, respectively. In the following example the <code>trusted</code> metadata key is assigned to <code>true</code> for connections from loopback or a lan address, but <code>false</code> otherwise:</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n  meta = {\n    -- default is to assume untrusted\n    trusted = false,\n  },\n  peer = {\n    ['127.0.0.0/24'] = {\n      meta = {\n        trusted = true,\n      },\n    },\n    ['192.168.1.0/24'] = {\n      meta = {\n        trusted = true,\n      },\n    },\n  },\n}\n</code></pre> <p>When <code>meta</code> is processed and applied to the effective listener configuration, its values are overlaid and merged into the configuration, so in the example above, the <code>trusted</code> value is applied to the metadata first, then the matching peer block will replace the <code>trusted</code> key with the values it defines, preserving any other keys that might already be defined in the connection metadata.</p> <p>The implication of this merging scheme, coupled with the lua language, is that you cannot unset a metadata key using this syntax, because trying to explicitly assign a value of <code>nil</code> is equivalent to not specifying a value.  You can replace the value with some other non-nil value though.</p>"},{"location":"reference/kumo/start_esmtp_listener/peer/","title":"peer","text":"Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Define peer-specific parameters.  The value is a cidr-map that is keyed by the peer address and whose values are esmtp listener parameters.</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n\n  -- This is the banner that will be used by default\n  banner = 'Welcome to KumoMTA!',\n\n  peer = {\n    -- Clients connecting from the loopback address\n    -- will match this section, and the values defined\n    -- within will override any values defined in the\n    -- base set of parameters passed directly to start_esmtp_listener.\n    ['127.0.0.1'] = {\n      -- So they will have this customized banner\n      banner = 'Welcome loopback!',\n    },\n    -- Similarly, clients connecting from any address\n    -- in the range 192.168.1.0 through 192.168.1.255\n    -- will match this block\n    ['192.168.1.0/24'] = {\n      banner = 'Welcome LAN!',\n    },\n  },\n}\n</code></pre> <p>See also:</p> <ul> <li>smtp_server_get_dynamic_parameters</li> </ul>"},{"location":"reference/kumo/start_esmtp_listener/relay_hosts/","title":"relay_hosts","text":"<p>Specify the hosts which are allowed to relay email via this ESMTP service. Each item can be an IP literal or a CIDR mask. Note that the CIDR notation  is strict, so that 192.168.1.0/24 is valid but 192.168.1.1/24 is not because  that final octet isn\u2019t valid in a /24.</p> <p>The defaults are to allow relaying only from the local host:</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  relay_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/require_proxy_protocol/","title":"require_proxy_protocol","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Danger</p> <p>Take care to apply this ONLY in an appropriate <code>peer</code> block, otherwise you risk a variety of security/authentication related bypasses.  Furthermore, this changes the semantics of the SMTP session and will prevent non-proxy clients from connecting to the server.</p> <p>When set to <code>true</code>, incoming SMTP sessions are required to pass an HA Proxy Protocol header to override the effective <code>received_from</code> and/or <code>received_via</code> connection level metadata items.</p> <p>Since the proxy protocol header must be unilaterally sent by the client before the server can return the SMTP banner (which is normally unilaterally sent by the server), requiring the proxy protocol prevents non-proxy clients from connecting to the listener when this configuration is in effect.</p> <p>Both V1 and V2 proxy header packets are supported.</p> <p>If the proxy header is missing, the connection will be torn down and no service will be permitted.</p> <p>After the proxy header is received and successfully parsed, the ESMTP listener re-evaluates the parameters (especially the via and peer blocks), and triggers smtp_server_get_dynamic_parameters to ensure that all the listener configuration has been updated to match the adjusted <code>via</code> and <code>from</code> addresses.</p> <pre><code>kumo.start_esmtp_listener {\n  -- Always use an appropriate `peer` block to scope the\n  -- proxy protocol to networks that you trust at the\n  -- highest levels\n  peer = {\n    ['127.0.0.1'] = {\n      require_proxy_protocol = true,\n    },\n  },\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/tls_certificate/","title":"tls_certificate","text":"<p>Specify the path to a TLS certificate file to use for the server identity when the client issues <code>STARTTLS</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <p>Since: Version 2025.05.06-b29689af</p> <p>The functionality described in this outlined box requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>The certificate will be cached for 5 minutes, then re-evaluated, allowing for the certificate to be updated without restarting the service. In prior versions of KumoMTA you would need to restart kumod in order to pick up an updated certificate.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_certificate = '/path/to/cert.pem',\n}\n</code></pre> <p>You may specify that the certificate be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.cert',\n    -- Optional: specify a custom key name (defaults to \"key\")\n    -- vault_key = \"certificate\"\n\n    -- Specify how to reach the vault; if you omit these,\n    -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n\n    -- vault_address = \"http://127.0.0.1:8200\"\n    -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n  },\n}\n</code></pre> <p>The certificate must be stored under the <code>path</code> specified. By default, it looks for a field named <code>key</code> in the vault secret. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert key=@mail.example.com.cert\n</code></pre> <p>If you want to use a different field name, you can specify it with <code>vault_key</code> (Since: Version 2025.10.06-5ec871ab):</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.cert',\n    vault_key = 'certificate', -- Look for 'certificate' instead of 'key'\n  },\n}\n</code></pre> <p>And store it in vault like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert certificate=@mail.example.com.cert\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/tls_private_key/","title":"tls_private_key","text":"<p>Specify the path to the TLS private key file that corresponds to the <code>tls_certificate</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <p>Since: Version 2025.05.06-b29689af</p> <p>The functionality described in this outlined box requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>The private key will be cached for 5 minutes, then re-evaluated, allowing for the privae key to be updated without restarting the service. In prior versions of KumoMTA you would need to restart kumod in order to pick up an updated private key.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_private_key = '/path/to/key.pem',\n}\n</code></pre> <p>You may specify that the key be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_private_key = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.key',\n    -- Optional: specify a custom key name (defaults to \"key\")\n    -- vault_key = \"private_key\"\n\n    -- Specify how to reach the vault; if you omit these,\n    -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n\n    -- vault_address = \"http://127.0.0.1:8200\"\n    -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n  },\n}\n</code></pre> <p>The key must be stored under the <code>path</code> specified. By default, it looks for a field named <code>key</code> in the vault secret. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com key=@mail.example.com.key\n</code></pre> <p>If you want to use a different field name, you can specify it with <code>vault_key</code> (Since: Version 2025.10.06-5ec871ab):</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_private_key = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.key',\n    vault_key = 'private_key', -- Look for 'private_key' instead of 'key'\n  },\n}\n</code></pre> <p>And store it in vault like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com private_key=@mail.example.com.key\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/tls_required_client_ca/","title":"tls_required_client_ca","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Specify the path to a TLS certificate file to use to verify a client certificate presented by a client when it issues <code>STARTTLS</code>.</p> <p>The value is an optional KeySource.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  tls_required_client_ca = '/path/to/client-cert.pem',\n}\n</code></pre> <p>If <code>tls_required_client_ca</code> is configured, and a client presents a TLS certificate, if that client certificate was issued by any of the certificate authorities contained in the <code>tls_required_client_ca</code> PEM file, then the client certificate is considered to be verified and the <code>tls_peer_subject_name</code> meta value will be set in the connection context and will also get logged in any associated <code>Reception</code> log that may be produced after that point.</p> <p>If no client certificate was provided, or the client certificate doesn't verify as being issued by any of the permitted authorities, then the <code>tls_peer_subject_name</code> meta value will be left unassigned.</p>"},{"location":"reference/kumo/start_esmtp_listener/trace_headers/","title":"trace_headers","text":"<p>Controls the addition of tracing headers to received messages.</p> <p>KumoMTA can add two different headers to aid in later tracing:</p> <ul> <li>The standard <code>\"Received\"</code> header which captures SMTP relay hops on their path to the inbox</li> <li>A supplemental header which can be used to match feedback reports back to the   originating mailing</li> </ul> <p>Prior to triggering the smtp_server_message_received event the standard <code>\"Received\"</code> header will be added to the message.  Then, once the event completes and your policy has had the opportunity to alter the meta data associated with the message, the supplemental header will be added.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  trace_headers = {\n    -- this is the default: add the Received: header\n    received_header = true,\n\n    -- this is the default: add the supplemental header\n    supplemental_header = true,\n\n    -- this is the default: the name of the supplemental header\n    header_name = 'X-KumoRef',\n\n    -- names of additional meta data fields\n    -- to include in the header. TAKE CARE! The header will be\n    -- base64 encoded to prevent casual introspection, but the\n    -- header is NOT encrypted and the values of the meta data\n    -- fields included here should be considered to be public.\n    -- The default is not to add any meta data fields, but you\n    -- might consider setting something like:\n    -- include_meta_names = { 'tenant', 'campaign' },\n    include_meta_names = {},\n  },\n}\n</code></pre> <p>Here's an example of a supplemental header from a message:</p> <pre><code>X-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\n</code></pre> <p>the decoded payload contains a magic marker key as well as the recipient of the original message:</p> <pre><code>{\"_@_\":\"\\\\_/\",\"recipient\":\"test@example.com\"}\n</code></pre> <p>Any meta data fields that were listed in <code>include_meta_names</code>, if the corresponding meta data was set in the message, would also be captured in the decoded payload.</p> <p>KumoMTA will automatically extract this supplemental trace header information from any <code>X-</code> header that is successfully parsed and has the magic marker key when processing the original message payload of an incoming ARF report.</p> <p>If you prefer to explicitly and manually insert the supplemental header, you can set <code>supplemental_header = false</code> in your listener configuration and use kumo.apply_supplemental_trace_header to build and insert the header into a message at the appropriate time.</p>"},{"location":"reference/kumo/start_esmtp_listener/via/","title":"via","text":"Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Define listener-ip-specific parameters.  The value is a cidr-map that is keyed by the local IP address and whose values are esmtp listener parameters.</p> <p>Note</p> <p>This option only really makes sense when used together with a wildcard <code>listen</code> value of <code>0.0.0.0</code> for an IPv4 listener or <code>::</code> for an IPv6 listener.</p> <p>This option can be useful to implement IP-based virtual hosting on multi-homed systems where many IP addresses are served from the same service on the same port.</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n\n  via = {\n    -- When clients connect to this server via its 10.0.0.1 IP\n    -- address, we will use the hostname and TLS parameters\n    -- defined in this block\n    ['10.0.0.1'] = {\n      hostname = 'mx.example-customer.com',\n      tls_certificate = '/path/to/customer1.cert',\n      tls_private_key = '/path/to/customer1.key',\n    },\n    -- When clients connect to this server via its 10.0.0.2 IP\n    -- address, we will use the hostname and TLS parameters\n    -- defined in this block\n    ['10.0.0.2'] = {\n      hostname = 'mx.other-customer.com',\n      tls_certificate = '/path/to/customer2.cert',\n      tls_private_key = '/path/to/customer2.key',\n    },\n  },\n}\n</code></pre> <p>See also:</p> <ul> <li>smtp_server_get_dynamic_parameters</li> </ul>"},{"location":"reference/kumo/start_http_listener/","title":"kumo.start_http_listener","text":"<pre><code>kumo.start_http_listener { PARAMS }\n</code></pre> <p>Configure and start HTTP service.</p> <p>This function should be called only from inside your init event handler.</p> <p><code>PARAMS</code> is a lua table that can accept the keys listed below.</p>"},{"location":"reference/kumo/start_http_listener/hostname/","title":"hostname","text":"<p>Specifies the hostname to use when configuring TLS. The default, if unspecified, is to use the hostname of the local machine.</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  hostname = 'mail.example.com',\n}\n</code></pre>"},{"location":"reference/kumo/start_http_listener/listen/","title":"listen","text":"<p>Specifies the local IP and port number to which the HTTP service should bind and listen.</p> <p>Use <code>0.0.0.0</code> to bind to all IPv4 addresses.</p> <pre><code>kumo.start_http_listener {\n  listen = '0.0.0.0:80',\n}\n</code></pre>"},{"location":"reference/kumo/start_http_listener/request_body_limit/","title":"request_body_limit","text":"Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Specifies the maximum acceptable size of an incoming HTTP request, after decompressing any compressed body, in bytes.  This option limits the RAM usage rather than the wire usage.</p> <p>The default limit is 2MB.</p> <p>If an incoming request exceeds this limit, a <code>413 Payload Too Large</code> HTTP response will be returned, with the body <code>Failed to buffer the request body: length limit exceeded</code>.</p>"},{"location":"reference/kumo/start_http_listener/tls_certificate/","title":"tls_certificate","text":"<p>Specify the path to a TLS certificate file to use for the server identity when use_tls is set to <code>true</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  tls_certificate = '/path/to/cert.pem',\n}\n</code></pre> <p>You may specify that the certificate be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.cert',\n    -- Optional: specify a custom key name (defaults to \"key\")\n    -- vault_key = \"certificate\"\n\n    -- Specify how to reach the vault; if you omit these,\n    -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n\n    -- vault_address = \"http://127.0.0.1:8200\"\n    -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n  },\n}\n</code></pre> <p>The certificate must be stored under the <code>path</code> specified. By default, it looks for a field named <code>key</code> in the vault secret. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert key=@mail.example.com.cert\n</code></pre> <p>If you want to use a different field name, you can specify it with <code>vault_key</code> (Since: Version 2025.10.06-5ec871ab):</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.cert',\n    vault_key = 'certificate', -- Look for 'certificate' instead of 'key'\n  },\n}\n</code></pre> <p>And store it in vault like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert certificate=@mail.example.com.cert\n</code></pre>"},{"location":"reference/kumo/start_http_listener/tls_private_key/","title":"tls_private_key","text":"<p>Specify the path to the TLS private key file that corresponds to the <code>tls_certificate</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  tls_private_key = '/path/to/key.pem',\n}\n</code></pre> <p>You may specify that the key be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  tls_private_key = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.key',\n    -- Optional: specify a custom key name (defaults to \"key\")\n    -- vault_key = \"private_key\"\n\n    -- Specify how to reach the vault; if you omit these,\n    -- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n\n    -- vault_address = \"http://127.0.0.1:8200\"\n    -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n  },\n}\n</code></pre> <p>The key must be stored under the <code>path</code> specified. By default, it looks for a field named <code>key</code> in the vault secret. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com key=@mail.example.com.key\n</code></pre> <p>If you want to use a different field name, you can specify it with <code>vault_key</code> (Since: Version 2025.10.06-5ec871ab):</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  tls_private_key = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.key',\n    vault_key = 'private_key', -- Look for 'private_key' instead of 'key'\n  },\n}\n</code></pre> <p>And store it in vault like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com private_key=@mail.example.com.key\n</code></pre>"},{"location":"reference/kumo/start_http_listener/trusted_hosts/","title":"trusted_hosts","text":"<p>Specify the hosts which are trusted to access the HTTP service. Each item can be an IP literal or a CIDR mask.</p> <p>The defaults are to allow the local host.</p> <pre><code>kumo.start_http_listener {\n  -- ..\n  trusted_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre>"},{"location":"reference/kumo/start_http_listener/use_tls/","title":"use_tls","text":"<p>If true, the listener will start with TLS enabled and require clients to use <code>https</code>.</p>"},{"location":"reference/kumo.aaa/","title":"kumo.aaa","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>The <code>kumo.aaa</code> module provides Authentication, Authorization, and Accounting related functionality.</p>"},{"location":"reference/kumo.aaa/auth_info/","title":"AuthInfo Object","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>AuthInfo Objects are used to represent the authentication state of a session. There are two main ways that you might interact with them in KumoMTA:</p> <ul> <li>When performing ad-hoc authorization checks via kumo.aaa.query_resource_access</li> <li>When handling authentication checks via smtp_server_auth_plain or http_server_validate_auth_basic.</li> </ul>"},{"location":"reference/kumo.aaa/auth_info/#authinfo-fields","title":"AuthInfo fields","text":"<p>The following fields may be present in an AuthInfo object:</p> <ul> <li><code>identities</code> - an array style table listing each authenticated identity.  An identity is itself an object of the form <code>{identity = 'username', context = 'GenericAuth'}</code> where the context describes where the credential came from.  Context can be one of the following values:<ul> <li><code>SmtpAuthPlainAuthorization</code> - the identity came from the SMTP AUTH PLAIN <code>authz</code> field, the authorization identity.</li> <li><code>SmtpAuthPlainAuthentication</code> - the identity came from the SMTP AUTH PLAIN <code>authc</code> field, the authenticated identity.</li> <li><code>HttpBasicAuth</code> - the identity came from an HTTP Basic auth header</li> <li><code>BearerToken</code> - the identity came from an HTTP Bearer token</li> <li><code>ProxyAuthRfc1929</code> - the identity came from a SOCKS 5 RFC 1929 authentication packet</li> <li><code>LocalSystem</code> - a special identity representing the system itself</li> <li><code>GenericAuth</code> - the identity was produced by some generic authentication processing/handling and doesn't provide any additional context on the provenance of the authenticated identity</li> </ul> </li> <li><code>groups</code> - an array style table listing each group name to which the session belongs</li> <li><code>peer_address</code> - an optional string representing the ip address of the connected peer</li> </ul>"},{"location":"reference/kumo.aaa/auth_info/#constructing-an-authinfo","title":"Constructing an AuthInfo","text":"<p>When implementing smtp_server_auth_plain or http_server_validate_auth_basic, you may optionally return an <code>AuthInfo</code> object representing the overall identity and group membership:</p> <pre><code>-- This is just an example of how to populate the return value,\n-- not a recommended way to handle passwords in production!\n-- In particular, it is an absolutely terrible idea to hard code\n-- a password here in plain text!\n\nlocal password_database = {\n  ['daniel'] = {\n    password = 'tiger',\n    groups = { 'group1', 'group2' },\n  },\n}\n\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\n  local entry = password_database[authc]\n  if not entry then\n    return false\n  end\n  if entry.password ~= password then\n    return false\n  end\n\n  -- Return an AuthInfo that lists out the identity and group\n  -- membership\n  return {\n    identities = {\n      { identity = authz, context = 'SmtpAuthPlainAuthorization' },\n      { identity = authc, context = 'SmtpAuthPlainAuthentication' },\n    },\n    groups = entry.groups,\n  }\nend)\n\nkumo.on('http_server_validate_auth_basic', function(user, password)\n  local entry = password_database[user]\n  if not entry then\n    return false\n  end\n  if entry.password ~= password then\n    return false\n  end\n\n  -- Return an AuthInfo that lists out the identity and group\n  -- membership\n  return {\n    identities = {\n      { identity = user, context = 'HttpBasicAuth' },\n    },\n    groups = entry.groups,\n  }\nend)\n</code></pre>"},{"location":"reference/kumo.aaa/configure_acct_log/","title":"kumo.aaa.configure_acct_log","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.on('init', function()\n  kumo.aaa.configure_acct_log(PARAMS)\nend)\n</code></pre> <p>This function configures and enables the accounting logs for both authentication and authorization.</p> <p>This function is intended to be called during the <code>init</code> or <code>pre_init</code> event callback. Calling it multiple times is an error.</p> <p><code>PARAMS</code> is an object style lua table that can have fields as described in the Log Parameters section below.</p> <p>The minimal configuration looks like:</p> <pre><code>kumo.on('init', function()\n  kumo.aaa.configure_acct_log {\n    log_dir = '/var/log/kumo-logs/acct',\n    -- If you find that the logs are big and busy, you might consider\n    -- disabling logging successful authentication and authorization\n    -- events, leaving the logs to focus on failures\n    -- log_authn_ok = false,\n    -- log_authz_allow = false,\n  }\nend)\n</code></pre> <p>Logs are written as zstd-compressed log file segments under the specified <code>log_dir</code> directory. Each line of the file is a JSON object holding information about an authentication or authorization event.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log-records","title":"Log Records","text":"<p>There are two types of records that could be logged to the accounting log:</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#authentication-events","title":"Authentication Events","text":"<pre><code>{\n  // Indicates that this is an Authentication record\n  \"type\": \"Authentication\",\n  // When the event occurred\n  \"timestamp\":\"2025-12-18T06:52:47.798373949Z\",\n  // Who were they trying to authenticate as?\n  \"attempted_identity\": {\n    // the username, if known (in some contexts, we may not\n    // have a human readable identity string, and this may be\n    // an empty string)\n    \"identity\": \"daniel\",\n    // How were they trying to authenticate?\n    \"context\": \"HttpBasicAuth\"\n  },\n  // Was authentication successful?\n  \"success\": false,\n  // The auth info from the session, which will include the\n  // attempted_identity if the authentication was successful\n  \"auth_info\": {\n    // The IP address of the system making the request\n    \"peer_address\": \"127.0.0.1\",\n    // The set of identities which are active for the session\n    \"identities\": [],\n    // any groups that are active for the session\n    \"groups\": [\n      \"kumomta:http-listener-trusted-ip\"\n    ]\n  }\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#authorization-events","title":"Authorization Events","text":"<pre><code>{\n  // Indicates that this is an Authorization record\n  \"type\": \"Authorization\",\n  // When the event occurred\n  \"timestamp\":\"2025-12-18T06:52:47.798373949Z\",\n  // Which resource was being accessed?\n  \"target_resource\": \"http_listener/0.0.0.0:8000/api/admin/suspend/v1\",\n  // What privilege was being requested of that resource?\n  \"privilege\": \"GET\",\n  // Was access `Allow`d or `Deny`d?\n  \"access\": \"Allow\",\n  // If an ACL rule was responsible for deciding the access level,\n  // which resource did that rule belong to?  This aids in tracing\n  // and debugging ACL rules.  This may be missing or null if\n  // no rule matched.\n  \"matching_resource\": \"http_listener/*/api/admin\",\n  // If a rule matched, this is a copy of that matching rule, to aid\n  // in tracing and debugging ACL rules.\n  \"rule\": {\n    \"criteria\": {\n      \"Identity\": {\n        \"Group\": \"kumomta:http-listener-trusted-ip\"\n      }\n    },\n    \"privilege\": \"GET\",\n    \"access\": \"Allow\"\n  },\n  // A copy of the auth info from the session\n  \"auth_info\": {\n    \"peer_address\": \"127.0.0.1\",\n    \"identities\": [],\n    \"groups\": [\n      \"kumomta:http-listener-trusted-ip\"\n    ]\n  },\n  // A list of the resources that were considered, in the order that\n  // they were considered, before we reached the matching_resource.\n  // This aids in tracing and debugging ACL rules.\n  \"considered_resources\": [\n    \"http_listener/0.0.0.0:8000/api/admin/suspend/v1\",\n    \"http_listener/0.0.0.0:8000/api/admin/suspend\",\n    \"http_listener/0.0.0.0:8000/api/admin\",\n    \"http_listener/0.0.0.0:8000/api\",\n    \"http_listener/0.0.0.0:8000\",\n    \"http_listener/*/api/admin/suspend/v1\",\n    \"http_listener/*/api/admin/suspend\"\n  ]\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log-parameters","title":"Log Parameters","text":"","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log_authz_allow","title":"log_authz_allow","text":"<p>If set to <code>true</code> (the default), then successful authorization events will be logged.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log_authz_deny","title":"log_authz_deny","text":"<p>If set to <code>true</code> (the default), then failed authorization events will be logged.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log_authn_ok","title":"log_authn_ok","text":"<p>If set to <code>true</code> (the default), then successful authentication events will be logged.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log_authn_fail","title":"log_authn_fail","text":"<p>If set to <code>true</code> (the default), then failed authentication events will be logged.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#back_pressure","title":"back_pressure","text":"<p>Maximum number of outstanding items to be logged before the submission will block; helps to avoid runaway issues spiralling out of control.</p> <pre><code>kumo.aaa.configure_acct_log {\n  -- ..\n  back_pressure = 128000,\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#compression_level","title":"compression_level","text":"<p>Specifies the level of zstd compression that should be used.  Compression cannot be disabled.</p> <p>Specifying <code>0</code> uses the zstd default compression level, which is <code>3</code> at the time of writing.</p> <p>Possible values are <code>1</code> (cheapest, lightest) through to <code>21</code>.</p> <pre><code>kumo.aaa.configure_acct_log {\n  -- ..\n  compression_level = 3,\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#log_dir","title":"log_dir","text":"<p>Specifies the directory into which log file segments will be written. This is a required key; there is no default value.</p> <pre><code>kumo.aaa.configure_acct_log {\n  -- ..\n  log_dir = '/var/log/kumo-logs/acct',\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#max_file_size","title":"max_file_size","text":"<p>Specify how many uncompressed bytes to allow per file segment. When this number is exceeded, the current segment is finished and a new segment is created.</p> <p>Segments are created using the current time in the form <code>YYYYMMDD-HHMMSS</code> so that it is easy to sort the segments in chronological order.</p> <p>The default value is ~1GB of uncompressed data, which compresses down to around 50MB of data per segment with the default compression settings.</p> <pre><code>kumo.aaa.configure_acct_log {\n  -- ..\n  max_file_size = 1000000000,\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#max_segment_duration","title":"max_segment_duration","text":"<p>Specify the maximum time period for a file segment.  The default is unlimited.</p> <p>If you set this to <code>\"1min\"</code>, you indicate that any given file should cover a time period of 1 minute in duration; when that time period elapses, the current file segment, if any, will be flushed and closed and any subsequent events will cause a new file segment to be created.</p> <pre><code>kumo.aaa.configure_acct_log {\n  -- ..\n  max_segment_duration = '5 minutes',\n}\n</code></pre>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#min_free_inodes","title":"min_free_inodes","text":"<p>Specifies the desired minimum amount of free inodes for the log storage in this location.  Can be specified using either a string like <code>\"10%\"</code> to indicate the percentage of available inodes, or a number to indicate the number of available inodes.</p> <p>If the available inodes are below the specified amount then kumomta will reject incoming SMTP and HTTP injection requests and the check-liveness endpoint will indicate that new messages cannot be received.</p> <p>The default value for this option is <code>\"10%\"</code>.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/configure_acct_log/#min_free_space","title":"min_free_space","text":"<p>Specifies the desired minimum amount of free disk space for the log storage in this location.  Can be specified using either a string like <code>\"10%\"</code> to indicate the percentage of available space, or a number to indicate the number of available bytes.</p> <p>If the available storage is below the specified amount then kumomta will reject incoming SMTP and HTTP injection requests and the check-liveness endpoint will indicate that new messages cannot be received.</p> <p>The default value for this option is <code>\"10%\"</code>.</p>","tags":["logging"]},{"location":"reference/kumo.aaa/load_acl_map/","title":"kumo.aaa.load_acl_map","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>local map = kumo.aaa.load_acl_map(KEYSOURCE)\n</code></pre> <p>This function loads an ACL map definition file (whose syntax is described below) and parses it into an ACL Map object which can be queried to provide an implementation for the get_acl_definition event callback.</p> <p>The parameter is a keysource object which enables the ACL definition to be loaded from a file, from an inline string, a hashicorp vault or through a data loading event callback.</p> <p>You can load from a file like so:</p> <pre><code>local map = kumo.aaa.load_acl_map '/opt/kumomta/etc/custom_acl.toml'\n</code></pre> <p>Or from an inline string:</p> <pre><code>local map = kumo.aaa.load_acl_map {\n  key_data = [=[\n[[acl.\"http_listener/*/api/admin/baz\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n    ]=],\n}\n</code></pre> <p>or any of the other forms allowed by a keysource.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#acl-map-file-syntax","title":"ACL Map File Syntax","text":"<p>The purpose of an ACL Map File is to map a given resource name to an access control list that defines an ordered sequence of rules that might apply to that resource. The first rule that matches defines the access level that is allowed for the session.</p> <p>The following excerpt adds a new ACL rule to the resource named <code>http_listener/*/api/check-liveness</code>. That rule allows any access, either Authenticated or Unauthenticated sessions, to perform <code>GET</code> requests to URLs with a path of <code>/api/check-liveness</code>.  Note the use of <code>[[</code> and <code>]]</code> around the rule definition--that is TOML syntax for appending a new array entry to the definition, which has the effect of adding a new rule to the ACL:</p> <pre><code># Explicitly allow blanket unauthenticated access to the health status endpoint\n[[acl.\"http_listener/*/api/check-liveness\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Any = {}\n</code></pre> <p>This example shows how two rules are added to the same entry; the first one grants <code>POST</code> access to members of the <code>kumomta:http-listener-trusted-ip</code> group (which matches peer addresses that match the trusted_hosts config option), while the second grants <code>POST</code> access to any authenticated HTTP client:</p> <pre><code># Trusted ips can use the injection API\n[[acl.\"http_listener/*/api/inject\"]]\nallow = true\nprivileges = [\"POST\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n# Allow injection by other authenticated users\n[[acl.\"http_listener/*/api/inject\"]]\nallow = true\nprivileges = [\"POST\"]\nidentity.Authenticated = {}\n</code></pre> <p>Each ACL rule comprises of the following fields:</p> <ul> <li> <p><code>allow</code> - a boolean indicating whether this rule allows (<code>true</code>) or denies    (<code>false</code>) access when the other criteria in the rule match.</p> </li> <li> <p><code>privileges</code> - an array listing the set of privilege names which are covered    by this rule.  For example <code>[\"POST\", \"GET\"]</code> means that an auth check for    a privilege of either <code>POST</code> OR <code>GET</code> will potentially match this rule,    assuming that the other criteria are a match.</p> </li> <li> <p><code>identity</code> - defines the identity matching criteria, for example, a required    group or authentication identity.  This field is mutually exclusive with    <code>criteria</code>, described in the next bullet.</p> </li> <li> <p><code>criteria</code> - an extended set of matching criteria that allows using logical    operators to group or invert other identity criteria.  This is useful to    define a rule that allows certain identities access but only if they    are connected from an approved IP address.  This field is mutually exclusive    with the <code>identity</code> field described in the bullet above this one.</p> </li> </ul> <p><code>identity</code> and <code>criteria</code> examples are found below:</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#individual-identity","title":"Individual Identity","text":"<pre><code>identity.Individual = \"john.smith\"\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth into lists the specified user name in its list of authenticated identities.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#group-membership","title":"Group Membership","text":"<pre><code>identity.Group = 'kumomta:http-listener-trusted-ip'\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth info lists the specified group name in its list of groups.</p> <p>In the example above the <code>kumomta:http-listener-trusted-ip</code> group is automatically added to the group membership when the peer-ip associated with the incoming IP address is among the set of trusted_hosts defined in the HTTP listener.</p> <p>Other groups may be populated into the auth info through authentication related event callbacks, depending on the context.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#any-authenticated-identity","title":"Any Authenticated Identity","text":"<pre><code>identity.Authenticated = {}\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth info lists at least one user identity in its list of identities, which is the case when authentication has been performed successfully.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#unauthenticated-identity","title":"Unauthenticated Identity","text":"<pre><code>identity.Unauthenticated = {}\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth info has no authenticated identities associated with it, which is true when no authentication has been performed, or has not been performed successfully.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#matching-any-authentication-state","title":"Matching any authentication state","text":"<pre><code>identity.Any = {}\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#grouping-allof","title":"Grouping: AllOf","text":"<p>The <code>AllOf</code> condition is satisifed (evaluates as <code>true</code>) when all of the conditions defined within it also evaluate to true.  This is a logical <code>AND</code> operation.</p> <p>In the example below, the critiera will only evaluate as true if the session belongs to a hypothetical <code>admins</code> group AND if the peer address is <code>10.0.0.1</code>:</p> <pre><code>criteria.AllOf = [ {Identity = { Group = 'admins' }}, {Identity={Machine = \"10.0.0.1\"}} ]\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#grouping-anyof","title":"Grouping: AnyOf","text":"<p>The <code>AnyOf</code> condition is satisifed (evaluates as <code>true</code>) when any of the conditions defined within it also evaluate to true.  This is a logical <code>OR</code> operation.</p> <p>In the example below, the critiera will evaluate as true if either the session belongs to a hypothetical <code>admins</code> group OR if the peer address is <code>10.0.0.1</code>:</p> <pre><code>criteria.AnyOf = [ {Identity = { Group = 'admins' }}, {Identity={Machine = \"10.0.0.1\"}} ]\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#inverting-criteria","title":"Inverting Criteria","text":"<p>The <code>Not</code> condition is satisifed (evaluates as <code>true</code>) when the term within it evaluates to <code>false</code>.  This is a logical <code>NOT</code> operation.</p> <p>In the example below, the critiera will evaluate as true if the session is NOT a member of a hypothetical <code>admins</code> group.</p> <pre><code>criteria.Not = {Identity = { Group = 'admins' }}\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/load_acl_map/#the-default-acl-map","title":"The Default ACL map","text":"<p>The default ACL map from the <code>main</code> branch at the time that this documentation was built is included below, which may be different from the ACL in your currently deployed version of KumoMTA.</p> <pre><code># This file encodes the default ACLs in the kumomta software suite.\n# It is compiled into the software at build time.\n#\n# These defaults are not necessarily the best configuration for\n# any specific purpose, they are just a reasonable base.\n#\n# To make changes at runtime you must load your own ACL file via\n# your policy configuration. Consult the docs at:\n# &lt;https://docs.kumomta.com/reference/events/get_acl_definition.md&gt;\n# for information on how to do that.\n\n## KumoMTA HTTP Listener ACL rules -----------------------------------\n\n# Explicitly allow blanket unauthenticated access to the health status endpoint\n[[acl.\"http_listener/*/api/check-liveness\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Any = {}\n\n# Expose OpenAPI spec/schema/explorer to all\n[[acl.\"http_listener/*/rapidoc\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Any = {}\n\n[[acl.\"http_listener/*/api-docs/openapi.json\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Any = {}\n\n### Message Injection -----------------\n\n# Trusted ips can use the injection API\n[[acl.\"http_listener/*/api/inject\"]]\nallow = true\nprivileges = [\"POST\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n# Allow injection by other authenticated users\n[[acl.\"http_listener/*/api/inject\"]]\nallow = true\nprivileges = [\"POST\"]\nidentity.Authenticated = {}\n\n### Admin Functions --------------------------------\n\n# Allow trusted ips that were defined in the http listener to do admin\n[[acl.\"http_listener/*/api/admin\"]]\nallow = true\nprivileges = [\"GET\", \"DELETE\", \"POST\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n# Retrieving system info is a trust admin/machine function\n[[acl.\"http_listener/*/api/machine-info\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n# Metrics are a read-only admin function\n[[acl.\"http_listener/*/metrics\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n[[acl.\"http_listener/*/metrics.json\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n### Message Transfer -------------------------------\n# Trusted IPs can perform message transfer\n[[acl.\"http_listener/*/api/xfer\"]]\nallow = true\nprivileges = [\"POST\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n##############################################################\n### This ACL file is also loaded by tsa-daemon.\n### The following rules apply to its HTTP listener\n\n### TSA log publishing -----------------------------\n[[acl.\"http_listener/*/publish_log_v1\"]]\nallow = true\nprivileges = [\"POST\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n### TSA config access -----------------------------\n[[acl.\"http_listener/*/get_config_v1\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n### TSA suspension access -----------------------------\n[[acl.\"http_listener/*/get_suspension_v1\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n### TSA suspension subscription -----------------------------\n[[acl.\"http_listener/*/subscribe_suspension_v1\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n### TSA bounce access -----------------------------\n[[acl.\"http_listener/*/get_bounce_v1\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n\n### TSA event access -----------------------------\n[[acl.\"http_listener/*/subscribe_event_v1\"]]\nallow = true\nprivileges = [\"GET\"]\nidentity.Group = \"kumomta:http-listener-trusted-ip\"\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/","title":"kumo.aaa.make_access_control_list","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>local acl = kumo.aaa.make_access_control_list(RULES)\n</code></pre> <p>This function creates an access control list (ACL) and returns it.</p> <p>An access control list is comprised of a list of access control rules.</p> <p>In the example below, an ACL is created that comprises of a single rule that allows <code>GET</code> access to the protected resource for members of a group named <code>kumomta:http-listener-trusted-ip</code>:</p> <pre><code>local acl = kumo.aaa.make_access_control_list {\n  {\n    criteria = {\n      Identity = { Group = 'kumomta:http-listener-trusted-ip' },\n    },\n    privilege = 'GET',\n    access = 'Allow',\n  },\n}\n</code></pre> <p>This function is generally only useful within the context of the get_acl_definition event callback, where you might use it something like this:</p> <pre><code>kumo.on('get_acl_definition', function(resource)\n  if resource == 'http_listener/*/api/admin' then\n    return kumo.aaa.make_access_control_list {\n      {\n        criteria = {\n          Identity = { Group = 'kumomta:http-listener-trusted-ip' },\n        },\n        privilege = 'GET',\n        access = 'Allow',\n      },\n    }\n  end\n  -- Unknown resource, don't return an ACL\n  return nil\nend)\n</code></pre> <p>Note</p> <p>It is generally much more convenient to define ACLs using the TOML file syntax described in kumo.aaa.load_acl_map, so it is recommended to use that approach when possible.</p> <p>The <code>RULES</code> parameter to <code>kumo.aaa.make_access_control_list</code> is an array-style holding one rule per entry.</p> <p>Each rule has the following fields:</p> <ul> <li><code>criteria</code> - the condition that must evaluated to true in order for this    particular rule to match and apply.  See below for more details on this.</li> <li><code>privilege</code> - the name of the privilege that is being requested.  The    privilege and criteria must match in order for the rule to apply to    the current ACL query.  A <code>privilege</code> is a string that defines some action    on a particular resource.  For example, the HTTP listener will take the    HTTP request method and use that as the privilege string when deciding    when a given request is authorized.</li> <li><code>access</code> - the access level that is applied when both criteria and privilege    match.  This is either the string <code>Allow</code> to indicate that access is granted,    or <code>Deny</code> to indicate that access is denied.</li> </ul> <p>The criteria allows matching authenticated identities, group membership, peer ip addresses and simple boolean operations that allow grouping together multiple criteria.</p> <p>The Identity primitives are:</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#individual-identity","title":"Individual Identity","text":"<pre><code>criteria = {\n  Identity = { Individual = 'john.smith' },\n}\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth into lists the specified user name in its list of authenticated identities.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#group-membership","title":"Group Membership","text":"<pre><code>criteria = {\n  Identity = { Group = 'kumomta:http-listener-trusted-ip' },\n}\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth info lists the specified group name in its list of groups.</p> <p>In the example above the <code>kumomta:http-listener-trusted-ip</code> group is automatically added to the group membership when the peer-ip associated with the incoming IP address is among the set of trusted_hosts defined in the HTTP listener.</p> <p>Other groups may be populated into the auth info through authentication related event callbacks, depending on the context.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#any-authenticated-identity","title":"Any Authenticated Identity","text":"<pre><code>criteria = {\n  Identity = { Authenticated = {} },\n}\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth info lists at least one user identity in its list of identities, which is the case when authentication has been performed successfully.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#unauthenticated-identity","title":"Unauthenticated Identity","text":"<pre><code>criteria = {\n  Identity = { Unauthenticated = {} },\n}\n</code></pre> <p>This condition is satisfied (evaluates as <code>true</code>) when the auth info has no authenticated identities associated with it, which is true when no authentication has been performed, or has not been performed successfully.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#matching-any-authentication-state","title":"Matching any authentication state","text":"<pre><code>criteria = {\n  Identity = { Any = {} },\n}\n</code></pre> <p>This condition is always satisfied (evaluates as <code>true</code>) regardless of the authentication state, identity or group membership of the current session.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#grouping-allof","title":"Grouping: AllOf","text":"<p>The <code>AllOf</code> condition is satisifed (evaluates as <code>true</code>) when all of the conditions defined within it also evaluate to true.  This is a logical <code>AND</code> operation.</p> <p>In the example below, the critiera will only evaluate as true if the session belongs to a hypothetical <code>admins</code> group AND if the peer address is <code>10.0.0.1</code>:</p> <pre><code>criteria = {\n  AllOf = {\n    { Identity = { Group = 'admins' } },\n    { Machine = '10.0.0.1' },\n  },\n}\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#grouping-anyof","title":"Grouping: AnyOf","text":"<p>The <code>AnyOf</code> condition is satisifed (evaluates as <code>true</code>) when any of the conditions defined within it also evaluate to true.  This is a logical <code>OR</code> operation.</p> <p>In the example below, the critiera will evaluate as true if either the session belongs to a hypothetical <code>admins</code> group OR if the peer address is <code>10.0.0.1</code>:</p> <pre><code>criteria = {\n  AnyOf = {\n    { Identity = { Group = 'admins' } },\n    { Machine = '10.0.0.1' },\n  },\n}\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_access_control_list/#inverting-criteria","title":"Inverting Criteria","text":"<p>The <code>Not</code> condition is satisifed (evaluates as <code>true</code>) when the term within it evaluates to <code>false</code>.  This is a logical <code>NOT</code> operation.</p> <p>In the example below, the critiera will evaluate as true if the session is NOT a member of a hypothetical <code>admins</code> group.</p> <pre><code>criteria = {\n  Not = { Identity = { Group = 'admins' } },\n}\n</code></pre>","tags":["aaa"]},{"location":"reference/kumo.aaa/make_http_url_resource/","title":"kumo.aaa.make_http_url_resource","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>local resource = kumo.aaa.make_http_url_resource(LOCAL_ADDR, HTTP_URL)\n</code></pre> <p>This function can be used to create a resource object that represents an HTTP URL in the HTTP listener.  The two parameters are:</p> <ul> <li><code>LOCAL_ADDR</code> - a string like <code>127.0.0.1:8080</code> defining the local address    (NOT the peer address!) of the HTTP listener endpoint.  This local address    doesn't have to be a loopback address; it should map to the local \"sockname\"    of the connected HTTP session and can be the external/public IP of the local    system.</li> <li><code>HTTP_URL</code> - a URL string like <code>https://localhost/api/admin/baz</code> defining    the endpoint to which access is being requested.</li> </ul> <p>The eagle eyed reader will realize that <code>LOCAL_ADDR</code> is somewhat redundant with the host portion of the URL.  They are separate parameters because the underlying Rust logic needs to process an URL from a live HTTP request and that may have a hostname supplied by the client.  Authorization checks are always performed using the local address regardless of the hostname coming from the client.</p> <p>The HTTP URL Resource object encodes the specific resource name that exactly matches the combination of <code>LOCAL_ADDR</code> and <code>HTTP_URL</code>, but also encodes a list of fall-back resource names that allow ACL rules to be effectively inherited when performing ACL checks.</p> <p>For example, when constructing a resource object like this:</p> <pre><code>local resource = kumo.aaa.make_http_url_resource(\n  '127.0.0.1:8080',\n  'https://localhost/foo/bar/baz'\n)\n</code></pre> <p>produces a resource object that, when used as part of an ACL query via kumo.aaa.query_resource_access, will cause the following sequence of resource names to be loaded via get_acl_definition until that event returns an ACL:</p> <ul> <li><code>http_listener/127.0.0.1:8080/foo/bar/baz</code></li> <li><code>http_listener/127.0.0.1:8080/foo/bar</code></li> <li><code>http_listener/127.0.0.1:8080/foo</code></li> <li><code>http_listener/127.0.0.1:8080</code></li> <li><code>http_listener/*/foo/bar/baz</code></li> <li><code>http_listener/*/foo/bar</code></li> <li><code>http_listener/*/foo</code></li> <li><code>http_listener</code></li> </ul> <p>You can see that this sequence of resource names corresponds to a tree-like structure that allows you to, for example, set rules on a very specific resource path such as <code>http_listener/127.0.0.1:8080/foo/bar/baz</code> that either widen or narrow the scope of a more general rule that might be defined on a path such as <code>http_listener/*/foo/bar</code>.</p> <p>The product default ACLs take advantage of this structure to define a general access rule for <code>http_listener/*/api/admin</code>.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/query_resource_access/","title":"kumo.aaa.query_resource_access","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>local result = kumo.aaa.query_resource_access(RESOURCE, AUTH_INFO, PRIVILEGE)\n</code></pre> <p>Note</p> <p>This function is currently rather abstract and of limited utility, and that is reflected by the lack of examples on this page.</p> <p>This function can be used to check whether an <code>AUTH_INFO</code> has <code>PRIVILEGE</code> access to <code>RESOURCE</code>.  This is useful when performing access control checks within your own custom policy.</p> <p><code>RESOURCE</code> is a resource object identifying the resource that is being accessed.</p> <p><code>PRIVILEGE</code> is a string describing the nature of the access privilege that is being attempted.</p> <p><code>AUTH_INFO</code> is an AuthInfo describing the authentication status of the current session. You will typically obtain the auth info from the connection metadata, but you can also define an auth info for yourself in code if you have an advanced use case.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/set_acl_cache_ttl/","title":"kumo.aaa.set_acl_cache_ttl","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.aaa.set_acl_cache_ttl '5 minutes'\nend)\n</code></pre> <p>This function sets the Time To Live (TTL) duration for the ACL-definition cache.</p> <p>The ACL-definition cache is used to cache the result of the get_acl_definition event callback for a given resource.</p> <p>The default duration is <code>5 minutes</code>.</p> <p>Note</p> <p>This function is intended to be used in <code>pre_init</code> as shown above. It can be called at any time, but reducing the TTL after init will not automatically trigger a cache eviction.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/set_check_cache_ttl/","title":"kumo.aaa.set_check_cache_ttl","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.aaa.set_check_cache_ttl '5 minutes'\nend)\n</code></pre> <p>This function sets the Time To Live (TTL) duration for the ACL-check cache.</p> <p>The ACL-check cache is used to cache the overall status of an authorization check for a given <code>resource</code>, <code>privilege</code>, and <code>auth_info</code> combination.</p> <p>The default duration is <code>5 minutes</code>.</p> <p>Note</p> <p>This function is intended to be used in <code>pre_init</code> as shown above. It can be called at any time, but reducing the TTL after init will not automatically trigger a cache eviction.</p>","tags":["aaa"]},{"location":"reference/kumo.aaa/set_fall_back_to_acl_map/","title":"kumo.aaa.set_fall_back_to_acl_map","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.aaa.set_fall_back_to_acl_map(true)\nend)\n</code></pre> <p>This function accepts a single <code>boolean</code> argument that controls whether or not the default ACL map will be used as a fallback source for an ACL definition if the get_acl_definition event doesn't return an ACL.</p> <p>The default is <code>true</code>.</p> <p>If you set this to <code>false</code> then your <code>get_acl_definition</code> implementation is considered to the definitive and only source of ACL definitions in your deployment, completely replacing the product default ACL definitions.</p> <p>Note</p> <p>This function is intended to be used in <code>pre_init</code> as shown above. It can be called at any time, but it is recommended that you call it within <code>pre_init</code> and restart the service if you want to change its value, in order for your overall AAA configuration to apply consistently.</p>","tags":["aaa"]},{"location":"reference/kumo.amqp/","title":"Module <code>kumo.amqp</code>","text":"<p>This module provides AMQP/RabbitMQ client functionality.</p>"},{"location":"reference/kumo.amqp/basic_publish/","title":"basic_publish","text":"<pre><code>kumo.amqp.basic_publish { PARAMS }\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Publishes a message using the amqprs AMQP client. This function differs from kumo.amqp.build_client in that it encapsulates the entire publish operation in a single function that manages a connection pool of client(s) and performs the publish without manually dealing with the client connection lifetime.</p> <p>PARAMS is an object style table with the following possible fields:</p> <ul> <li><code>routing_key</code> - required string; the name of the queue to which to send the message</li> <li><code>payload</code> - required string; the message to send</li> <li><code>exchange</code> - optional string; the exchange through which to send the message. If unspecified,   the empty string is used, which corresponds to a default exchange.</li> <li><code>connection</code> - the connection information, which is in turn an object with the following fields:<ul> <li><code>host</code> - required string; the hostname or IP address of the AMQP server</li> <li><code>port</code> - optional integer; the port number of the AMQP service.</li> <li><code>username</code> - optional string</li> <li><code>password</code> - optional string</li> <li><code>vhost</code> - optional string</li> <li><code>connection_name</code> - optional string</li> <li><code>heartbeat</code> - optional integer</li> <li><code>enable_tls</code> - optional boolean</li> <li><code>root_ca_cert</code> - optional string; the path to a CA certificate file.</li> <li><code>client_cert</code> - optional string; the path to a client certificate file.</li> <li><code>client_private_key</code> - optional string; the path to the private key associated with the client certificate.</li> <li><code>pool_size</code> - optional integer; specifies the maximum number of AMQP connections to pool. The default is the number of CPUs * 4.</li> <li><code>connect_timeout</code> - optional duration string; the timeout to use around the connect operation.</li> <li><code>recycle_timeout</code> - optional duration string; the timeout to use around the recycle operation, which is where the liveness of   an existing connection is tested prior to reuse.</li> <li><code>wait_timeout</code> - optional duration string; the timeout to use while waiting for a fully saturated pool to have an available AMQP client.</li> <li><code>publish_timeout</code> - optional duration string; the timeout to use around the <code>basic_publish</code> operation.</li> </ul> </li> <li><code>app_id</code> - optional string</li> <li><code>cluster_id</code> - optional string</li> <li><code>content_encoding</code> - optional string</li> <li><code>content_type</code> - optional string</li> <li><code>correlation_id</code> - optional string</li> <li><code>delivery_mode</code> - optional integer</li> <li><code>expiration</code> - optional string</li> <li><code>headers</code> - optional field table</li> <li><code>message_id</code> - optional string</li> <li><code>message_type</code> - optional string</li> <li><code>priority</code> - optional integer</li> <li><code>reply_to</code> - optional string</li> <li><code>timestamp</code> - optional timestamp</li> <li><code>user_id</code> - optional string</li> <li><code>mandatory</code> - optional boolean</li> <li><code>immediate</code> - optional boolean</li> </ul>"},{"location":"reference/kumo.amqp/build_client/","title":"build_client","text":"<pre><code>kumo.amqp.build_client(URI)\n</code></pre> <p>Note</p> <p>This function is deprecated and will be removed in a future release. Please migrate to kumo.amqp.basic_publish.</p> <p>Constructs an AMQP client object, using the underlying lapin client implementation.</p> <p><code>URI</code> is the URI that references the AMQP server to which you want to connect.</p> <pre><code>local client = kumo.amqp.build_client 'amqp://localhost'\nlocal confirm = client:publish {\n  routing_key = 'hello',\n  payload = 'w00t!',\n}\nlocal result = confirm:wait()\nassert(result.status == 'NotRequested')\n</code></pre>"},{"location":"reference/kumo.amqp/build_client/#client-methods","title":"Client Methods","text":"<p>The returned client object has the following methods:</p>"},{"location":"reference/kumo.amqp/build_client/#clientpublishparams","title":"client:publish({PARAMS})","text":"<p>Publishes a message. <code>PARAMS</code> is an object style table with the following keys:</p> <ul> <li><code>routing_key</code> - required string; the name of the queue to which to send the message</li> <li><code>payload</code> - required string; the message to send</li> <li><code>exchange</code> - optional string; the exchange through which to send the message.   If unspecified, the empty string is used, which corresponds to a default   exchange.</li> </ul> <p>Returns a confirmation object that can be used to await the final disposition of the send.  That confirmation object has a single <code>wait</code> method which returns a confirmation object with the following fields:</p> <ul> <li><code>status</code> - one of <code>\"NotRequested\"</code>, <code>\"Ack\"</code>, or <code>\"Nack\"</code> depending on the   disposition of the message delivery attempt.</li> <li><code>reply_code</code> - may be nil, but is otherwise a status code from the ack   returned from the queue machinery.</li> <li><code>reply_text</code> - may be nil, but is otherwise status text from the ack   returned from the queue machinery.</li> </ul> <pre><code>local client = kumo.amqp.build_client 'amqp://localhost'\nlocal confirm = client:publish {\n  routing_key = 'hello',\n  payload = 'w00t!',\n}\nlocal result = confirm:wait()\nassert(result.status == 'NotRequested')\n</code></pre>"},{"location":"reference/kumo.amqp/build_client/#clientclose","title":"client:close()","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Explicitly and cleanly closes the connection to the AMQP server. Calling it multiple times will yield an error.</p>"},{"location":"reference/kumo.api.inject/","title":"Module <code>kumo.api.inject</code>","text":"<p>This module provides message injection functionality</p>"},{"location":"reference/kumo.api.inject/inject_v1/","title":"inject_v1","text":"<pre><code>kumo.api.inject.inject_v1(request)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>This is a Lua entrypoint that calls into the HTTP injection API.  The parameter is a request object with precisely the same semantics as described in the HTTP injection API documentation.</p> <p>The request will appear to come from the IPv4 loopback address, even though no HTTP request is actually involved in this call; it is plumbed through the same underlying implementation.</p> <p>Any messages generated by this function will trigger the http_message_generated event as per the HTTP injection API.</p> <p>In this example, a copy of the current incoming SMTP message is taken and sent to an archival service:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  kumo.api.inject.inject_v1 {\n    envelope_sender = msg:sender().email,\n    content = msg:get_data(),\n    recipients = { { email = 'archive@example.com' } },\n  }\nend)\n</code></pre>"},{"location":"reference/kumo.cidr/","title":"Module <code>kumo.cidr</code>","text":"<p>This module provides functions that help working with CIDR blocks and maps</p>"},{"location":"reference/kumo.cidr/make_map/","title":"make_map","text":"<pre><code>kumo.cidr.make_map(MAP)\n</code></pre> <p>Create a new CIDR map, optionally seeded with an initial set of key/value pairs.</p> <p>A CIDR map is a dictionary type that allows resolving the value associated with an IP address key, supporting matches based on CIDR blocks in the mapping.</p> <p>For simple inputs, the mapping behaves as you might expect for a dictionary type:</p> <pre><code>local cmap = kumo.cidr.make_map()\ncmap['127.0.0.1'] = 'bar'\nassert(cmap['127.0.0.1'] == 'bar')\nassert(cmap['not.set'] == nil)\n</code></pre> <p>you can define keys based on net blocks using CIDR notation:</p> <pre><code>local cmap = kumo.cidr.make_map()\n\ncmap['10.0.0.0/24'] = '10. block'\n\n-- any address in that /24 will return the mapped value\nassert(cmap['10.0.0.1'] == '10. block')\nassert(cmap['10.0.0.42'] == '10. block')\n\n-- other addresses won't\nassert(cmap['100.0.0.100'] == nil)\n</code></pre> <p>You may seed an initial value from a pre-existing lua table:</p> <pre><code>local cmap = kumo.cidr.make_map {\n  ['127.0.0.0/24'] = 'loopback',\n  ['10.0.0.0/24'] = 'lan',\n}\n\n-- and mutate the table after is has been constructed:\ncmap['4.2.4.2'] = 4242\n</code></pre> <p>Keys to the map are IPv4 or IPv6 addresses, but for convenience, domain literals and IP and port number combinations such as <code>\"127.0.0.1:25\"</code>, <code>\"[127.0.0.1]\"</code> <code>\"[::1]:25\"</code> are understood to facilitate more ergonomic use in policy:</p> <pre><code>local SOURCE_CLASSIFICATION = kumo.cidr.make_map {\n  ['127.0.0.0/24'] = 'loopback',\n  ['10.0.0.0/24'] = 'lan',\n}\n\nkumo.on('smtp_server_message_received', function(msg)\n  local source_type = SOURCE_CLASSIFICATION[msg:get_meta 'received_from']\nend)\n</code></pre>"},{"location":"reference/kumo.crypto/","title":"Module <code>kumo.crypto</code>","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This module provides cryptographic functions built on top of aws-lc.</p>"},{"location":"reference/kumo.crypto/aes_decrypt_block/","title":"aes_decrypt_block","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>kumo.crypto.aes_decrypt_block(ALGORITHM, CIPHERTEXT, KEY)\n</code></pre> <p><code>ALGORITHM</code> can be one of:</p> <ul> <li><code>'Cbc'</code> - Cipher block chaining (CBC).</li> <li><code>'Ecb'</code> - Electronic Code Book (ECB).</li> </ul> <p><code>CIPHERTEXT</code> is the (likely binary) string holding the encrypted payload that you wish to decrypt.</p> <p><code>KEY</code> describes the decryption key. It must be keysource object that references the source of the key.  Supported key sizes are 16 or 32 binary bytes, allowing for AES-128 or AES-256 ciphers.</p> <p>The return value is the decrypted data.</p> <p>The kumo.crypto.aes_encrypt_block function can be used to encrypt data suitable for decrypting with <code>kumo.crypto.aes_decrypt_block</code>.</p>"},{"location":"reference/kumo.crypto/aes_decrypt_block/#example-encryptingdecrypting-with-a-key-stored-in-a-file","title":"Example: encrypting/decrypting with a key stored in a file","text":"<pre><code>local message = 'secret message'\n\nlocal encrypted = kumo.crypto.aes_encrypt_block('Cbc', message, {\n  key = '/path/to/key.bin',\n})\n\n-- NOTE: encrypted is a BinaryResult object. You will likely want\n-- to use encrypted.bytes to access its bytes!\n\nlocal decrypted = kumo.crypto.aes_decrypt_block('Cbc', encrypted.bytes, {\n  key = '/path/to/key.bin',\n})\n\nassert(decrypted == message)\n</code></pre>"},{"location":"reference/kumo.crypto/aes_decrypt_block/#example-encrypting-with-a-key-stored-in-a-vault","title":"Example: encrypting with a key stored in a vault","text":"<pre><code>local message = 'secret message'\n\nlocal encrypted = kumo.crypto.aes_encrypt_block('Cbc', message, {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'keys/some-path',\n  },\n})\n\n-- NOTE: encrypted is a BinaryResult object. You will likely want\n-- to use encrypted.bytes to access its bytes!\n\nlocal decrypted = kumo.crypto.aes_decrypt_block('Cbc', encrypted.bytes, {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'keys/some-path',\n  },\n})\n\nassert(decrypted == message)\n</code></pre>"},{"location":"reference/kumo.crypto/aes_encrypt_block/","title":"aes_encrypt_block","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>kumo.crypto.aes_encrypt_block(ALGORITHM, PLAINTEXT, KEY)\n</code></pre> <p><code>ALGORITHM</code> can be one of:</p> <ul> <li><code>'Cbc'</code> - Cipher block chaining (CBC).</li> <li><code>'Ecb'</code> - Electronic Code Book (ECB).</li> </ul> <p><code>PLAINTEXT</code> is the string (which may be binary) to be encrypted.</p> <p><code>KEY</code> describes the encryption key. It must be keysource object that references the source of the key.  Supported key sizes are 16 or 32 binary bytes, allowing for AES-128 or AES-256 ciphers.</p> <p>The return value is the encrypted data wrapped into a BinaryResult object with the same format as that of the <code>kumo.digest</code> crate.  You will likely want to access the raw bytes via its <code>.bytes</code> field, as shown in the examples below.</p> <p>The kumo.crypto.aes_decrypt_block function can be used to reverse the encryption.</p>"},{"location":"reference/kumo.crypto/aes_encrypt_block/#example-encryptingdecrypting-with-a-key-stored-in-a-file","title":"Example: encrypting/decrypting with a key stored in a file","text":"<pre><code>local message = 'secret message'\n\nlocal encrypted = kumo.crypto.aes_encrypt_block('Cbc', message, {\n  key = '/path/to/key.bin',\n})\n\n-- NOTE: encrypted is a BinaryResult object. You will likely want\n-- to use encrypted.bytes to access its bytes!\n\nlocal decrypted = kumo.crypto.aes_decrypt_block('Cbc', encrypted.bytes, {\n  key = '/path/to/key.bin',\n})\n\nassert(decrypted == message)\n</code></pre>"},{"location":"reference/kumo.crypto/aes_encrypt_block/#example-encrypting-with-a-key-stored-in-a-vault","title":"Example: encrypting with a key stored in a vault","text":"<pre><code>local message = 'secret message'\n\nlocal encrypted = kumo.crypto.aes_encrypt_block('Cbc', message, {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'keys/some-path',\n  },\n})\n\n-- NOTE: encrypted is a BinaryResult object. You will likely want\n-- to use encrypted.bytes to access its bytes!\n\nlocal decrypted = kumo.crypto.aes_decrypt_block('Cbc', encrypted.bytes, {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'keys/some-path',\n  },\n})\n\nassert(decrypted == message)\n</code></pre>"},{"location":"reference/kumo.crypto/aws_sign_v4/","title":"aws_sign_v4","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>kumo.crypto.aws_sign_v4(PARAMS)\n</code></pre> <p>Signs an HTTP request using AWS Signature Version 4 (SigV4). This is useful when integrating KumoMTA with AWS services such as S3, SNS, SQS, Kinesis Firehose or Lambda directly from Lua.</p> <p><code>PARAMS</code> is a table with the following fields:</p> Parameter Type Required Description <code>access_key</code> KeySource Yes AWS Access Key ID (see keysource) <code>secret_key</code> KeySource Yes AWS Secret Access Key (see keysource) <code>region</code> string Yes AWS region (e.g. <code>\"us-east-1\"</code>) <code>service</code> string Yes AWS service name (e.g. <code>\"s3\"</code>, <code>\"sns\"</code>, <code>\"sqs\"</code>) <code>method</code> string Yes HTTP method (e.g. <code>\"GET\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>) <code>uri</code> string Yes Request URI path (e.g. <code>\"/my-bucket/object\"</code>) <code>query_params</code> table No Query string parameters as key/value pairs <code>headers</code> table No HTTP headers to include in the signature <code>payload</code> string No Request body (empty string for <code>GET</code> requests) <code>timestamp</code> DateTime No Override timestamp; defaults to current time <code>session_token</code> string No Session token for temporary credentials <p>The function returns a table <code>RESULT</code> with these fields:</p> Field Type Description <code>authorization</code> string Authorization header value (<code>AWS4-HMAC-SHA256 ...</code>) <code>timestamp</code> string AWS timestamp (<code>YYYYMMDD'T'HHMMSS'Z'</code>) <code>signature</code> string Hex-encoded signature <code>canonical_request</code> string Canonical request string (for debugging) <code>string_to_sign</code> string String-to-sign (for debugging)"},{"location":"reference/kumo.crypto/aws_sign_v4/#http-client-integration","title":"HTTP client integration","text":"<p>If you are using the built-in HTTP client, you can use <code>kumo.http.Request:aws_sign_v4({PARAMS})</code> as a convenience wrapper around this function. It derives the HTTP method, URI path, query parameters and <code>host</code> header from the <code>Request</code> object and then calls <code>kumo.crypto.aws_sign_v4</code> internally to compute the signature.</p> <p>For details and an end-to-end example, see <code>kumo.http.Request</code>.</p>"},{"location":"reference/kumo.crypto/aws_sign_v4/#examples","title":"Examples","text":""},{"location":"reference/kumo.crypto/aws_sign_v4/#s3-get-request","title":"S3 GET request","text":"<pre><code>local kumo = require 'kumo'\n\nlocal result = kumo.crypto.aws_sign_v4 {\n  access_key = {\n    key_data = 'AKIAIOSFODNN7EXAMPLE',\n  },\n  secret_key = {\n    key_data = 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',\n  },\n  region = 'us-east-1',\n  service = 's3',\n  method = 'GET',\n  uri = '/my-bucket/my-object.txt',\n  query_params = {},\n  headers = {\n    host = 'my-bucket.s3.amazonaws.com',\n  },\n  payload = '',\n}\n\nhttp.request {\n  url = 'https://my-bucket.s3.amazonaws.com/my-object.txt',\n  method = 'GET',\n  headers = {\n    ['Authorization'] = result.authorization,\n    ['X-Amz-Date'] = result.timestamp,\n    ['Host'] = 'my-bucket.s3.amazonaws.com',\n  },\n}\n</code></pre>"},{"location":"reference/kumo.crypto/aws_sign_v4/#sns-publish-request","title":"SNS Publish request","text":"<pre><code>local kumo = require 'kumo'\n\nlocal body =\n  'Action=Publish&amp;Message=Hello&amp;TopicArn=arn:aws:sns:us-east-1:123456789012:MyTopic'\n\nlocal sig = kumo.crypto.aws_sign_v4 {\n  access_key = {\n    key_data = 'AKIAIOSFODNN7EXAMPLE',\n  },\n  secret_key = {\n    key_data = 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',\n  },\n  region = 'us-east-1',\n  service = 'sns',\n  method = 'POST',\n  uri = '/',\n  headers = {\n    host = 'sns.us-east-1.amazonaws.com',\n    ['content-type'] = 'application/x-www-form-urlencoded',\n  },\n  payload = body,\n}\n</code></pre>"},{"location":"reference/kumo.crypto/aws_sign_v4/#kinesis-putrecord-request","title":"Kinesis PutRecord request","text":"<pre><code>local kumo = require 'kumo'\nlocal http = require 'kumo.http'\n\nlocal payload = kumo.serde.json_encode {\n  StreamName = 'my-stream',\n  PartitionKey = 'example-partition',\n  Data = kumo.encode.base64_encode 'Hello from KumoMTA',\n}\n\nlocal sig = kumo.crypto.aws_sign_v4 {\n  access_key = {\n    key_data = os.getenv 'AWS_ACCESS_KEY_ID',\n  },\n  secret_key = {\n    key_data = os.getenv 'AWS_SECRET_ACCESS_KEY',\n  },\n  region = 'us-east-1',\n  service = 'kinesis',\n  method = 'POST',\n  uri = '/',\n  headers = {\n    host = 'kinesis.us-east-1.amazonaws.com',\n    ['content-type'] = 'application/x-amz-json-1.1',\n    ['x-amz-target'] = 'Kinesis_20131202.PutRecord',\n  },\n  payload = payload,\n}\n\nlocal resp = http.request {\n  url = 'https://kinesis.us-east-1.amazonaws.com/',\n  method = 'POST',\n  headers = {\n    ['Authorization'] = sig.authorization,\n    ['X-Amz-Date'] = sig.timestamp,\n    ['X-Amz-Target'] = 'Kinesis_20131202.PutRecord',\n    ['Content-Type'] = 'application/x-amz-json-1.1',\n    ['Host'] = 'kinesis.us-east-1.amazonaws.com',\n  },\n  body = payload,\n}\n</code></pre>"},{"location":"reference/kumo.crypto/aws_sign_v4/#lambda-invoke-request","title":"Lambda Invoke request","text":"<pre><code>local kumo = require 'kumo'\nlocal http = require 'kumo.http'\n\nlocal invoke_payload = kumo.serde.json_encode {\n  key = 'value',\n}\n\nlocal function_name = 'my-function'\n\nlocal sig = kumo.crypto.aws_sign_v4 {\n  access_key = {\n    key_data = os.getenv 'AWS_ACCESS_KEY_ID',\n  },\n  secret_key = {\n    key_data = os.getenv 'AWS_SECRET_ACCESS_KEY',\n  },\n  region = 'us-east-1',\n  service = 'lambda',\n  method = 'POST',\n  uri = ('/2015-03-31/functions/%s/invocations'):format(function_name),\n  headers = {\n    host = 'lambda.us-east-1.amazonaws.com',\n    ['content-type'] = 'application/json',\n  },\n  payload = invoke_payload,\n}\n\nlocal resp = http.request {\n  url = ('https://lambda.us-east-1.amazonaws.com/2015-03-31/functions/%s/invocations'):format(\n    function_name\n  ),\n  method = 'POST',\n  headers = {\n    ['Authorization'] = sig.authorization,\n    ['X-Amz-Date'] = sig.timestamp,\n    ['Host'] = 'lambda.us-east-1.amazonaws.com',\n    ['Content-Type'] = 'application/json',\n  },\n  body = invoke_payload,\n}\n</code></pre>"},{"location":"reference/kumo.digest/","title":"Module <code>kumo.digest</code>","text":"<p>This module provides functions for hashing/digesting data.</p>"},{"location":"reference/kumo.digest/#the-binaryresult-object","title":"The BinaryResult Object","text":"<p>The functions in this module return a <code>BinaryResult</code> object.</p> <p>Printing or otherwise explicitly converting a <code>BinaryResult</code> object as a string will produce the digest bytes encoded in hex.</p> <p>The following fields are available to return the bytes encoded in various ways.</p> <ul> <li><code>bytes</code> - returns the data as a binary byte string. This is the most compact representation, but is difficult to pass into other systems without encoding in some way. Case sensitive.</li> <li><code>hex</code> - returns the data encoded as lowercase hexadecimal. This is the largest representation. Case insensitive.</li> <li><code>base32</code> - returns the data encoded as base32. Case insensitive.</li> <li><code>base32_nopad</code> - same as <code>base32</code>, but does not include padding characters.</li> <li><code>base32hex</code> - returns the data encoded as base32hex. This is similar to <code>base32</code>, but the encoded version preserve the sort order of the input data. Case insensitive.</li> <li><code>base32hex_nopad</code> - same as <code>base32hex</code>, but does not include padding characters.</li> <li><code>base64</code> - returns the data encoded as base64. Case sensitive.</li> <li><code>base64_nopad</code> - same as <code>base64</code>, but does not include padding characters.</li> <li><code>base64url</code> - returns the data encoded as base64, with a URL-safe alphabet. Case sensitive.</li> <li><code>base64url_nopad</code> - same as <code>base64url</code>, but does not include padding characters.</li> </ul> <pre><code>-- Compute the digest of 'hello'\nlocal d = kumo.digest.sha1 'hello'\n-- Demonstrate the various output properties of the digest object\nassert(tostring(d) == d.hex)\nassert(d.hex == 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d')\nassert(\n  d.bytes\n    == '\\xaa\\xf4\\xc6\\x1d\\xdc\\xc5\\xe8\\xa2\\xda\\xbe\\xde\\x0f\\x3b\\x48\\x2c\\xd9\\xae\\xa9\\x43\\x4d'\n)\nassert(d.base32 == 'VL2MMHO4YXUKFWV63YHTWSBM3GXKSQ2N')\nassert(d.base32_nopad == 'VL2MMHO4YXUKFWV63YHTWSBM3GXKSQ2N')\nassert(d.base32hex == 'LBQCC7ESONKA5MLURO7JMI1CR6NAIGQD')\nassert(d.base64 == 'qvTGHdzF6KLavt4PO0gs2a6pQ00=')\nassert(d.base64_nopad == 'qvTGHdzF6KLavt4PO0gs2a6pQ00')\nassert(d.base64url == 'qvTGHdzF6KLavt4PO0gs2a6pQ00=')\nassert(d.base64url_nopad == 'qvTGHdzF6KLavt4PO0gs2a6pQ00')\n</code></pre>"},{"location":"reference/kumo.digest/crc32/","title":"crc32","text":"<pre><code>kumo.digest.crc32(ARGS)\n</code></pre> <p>Computes a CRC32 digest over each of the arguments in ARGS.</p> <p>Note</p> <p>CRC32 is not a cryptographic algorithm. Use for the purpose of quick checksum sanity.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/hmac_sha1/","title":"hmac_sha1","text":"<pre><code>kumo.digest.hmac_sha1(KEY, MSG)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes an HMAC digest over the <code>MSG</code> argument, using <code>KEY</code> as the means for signing/authenticating the data.</p> <p>This function uses <code>SHA1</code> as the digest algorithm for the HMAC.</p> <p>Note</p> <p>SHA1 is a deprecated algorithm that is no longer recommended for cryptographic usage.</p> <p>The <code>KEY</code> parameter is expected to be a KeySource defining how to access the secret key bytes.</p> <p>The returned value is a BinaryResult object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/hmac_sha1/#computing-the-hmac-with-a-string-based-key","title":"Computing the HMAC with a string-based key","text":"<pre><code>local kumo = require 'kumo'\n\n-- It is not recommended to use this form in production.\n-- Consider storing the key in either a vault or in a local\n-- file to keep the credential material outside of the repo\n-- where you maintain your lua policy code\nlocal key_bytes = {\n  key_data = 'your key',\n}\nlocal hmac = kumo.digest.hmac_sha1(key_bytes, 'your message')\nassert(hmac.hex == '317d0dfd868a5c06c9444ac1328aa3e2bfd29fb2')\n</code></pre>"},{"location":"reference/kumo.digest/hmac_sha224/","title":"hmac_sha224","text":"<pre><code>kumo.digest.hmac_sha224(KEY, MSG)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes an HMAC digest over the <code>MSG</code> argument, using <code>KEY</code> as the means for signing/authenticating the data.</p> <p>This function uses <code>SHA224</code> as the digest algorithm for the HMAC.</p> <p>The <code>KEY</code> parameter is expected to be a KeySource defining how to access the secret key bytes.</p> <p>The returned value is a BinaryResult object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/hmac_sha224/#computing-the-hmac-with-a-string-based-key","title":"Computing the HMAC with a string-based key","text":"<pre><code>local kumo = require 'kumo'\n\n-- It is not recommended to use this form in production.\n-- Consider storing the key in either a vault or in a local\n-- file to keep the credential material outside of the repo\n-- where you maintain your lua policy code\nlocal key_bytes = {\n  key_data = 'your key',\n}\nlocal hmac = kumo.digest.hmac_sha224(key_bytes, 'your message')\nassert(hmac.hex == '991ff8089bd2a781d10c0568cbf2717794ac7b7fbcc9db049f19fc61')\n</code></pre>"},{"location":"reference/kumo.digest/hmac_sha256/","title":"hmac_sha256","text":"<pre><code>kumo.digest.hmac_sha256(KEY, MSG)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes an HMAC digest over the <code>MSG</code> argument, using <code>KEY</code> as the means for signing/authenticating the data.</p> <p>This function uses <code>SHA256</code> as the digest algorithm for the HMAC.</p> <p>The <code>KEY</code> parameter is expected to be a KeySource defining how to access the secret key bytes.</p> <p>The returned value is a BinaryResult object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/hmac_sha256/#computing-the-hmac-with-a-string-based-key","title":"Computing the HMAC with a string-based key","text":"<pre><code>local kumo = require 'kumo'\n\n-- It is not recommended to use this form in production.\n-- Consider storing the key in either a vault or in a local\n-- file to keep the credential material outside of the repo\n-- where you maintain your lua policy code\nlocal key_bytes = {\n  key_data = 'your key',\n}\nlocal hmac = kumo.digest.hmac_sha256(key_bytes, 'your message')\nassert(\n  hmac.hex\n    == '87fc1cec5c02f0991ae80f50e98eb2eb5213d07fc40417682a74448ac1deb07c'\n)\n</code></pre>"},{"location":"reference/kumo.digest/hmac_sha384/","title":"hmac_sha384","text":"<pre><code>kumo.digest.hmac_sha384(KEY, MSG)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes an HMAC digest over the <code>MSG</code> argument, using <code>KEY</code> as the means for signing/authenticating the data.</p> <p>This function uses <code>SHA384</code> as the digest algorithm for the HMAC.</p> <p>The <code>KEY</code> parameter is expected to be a KeySource defining how to access the secret key bytes.</p> <p>The returned value is a BinaryResult object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/hmac_sha384/#computing-the-hmac-with-a-string-based-key","title":"Computing the HMAC with a string-based key","text":"<pre><code>local kumo = require 'kumo'\n\n-- It is not recommended to use this form in production.\n-- Consider storing the key in either a vault or in a local\n-- file to keep the credential material outside of the repo\n-- where you maintain your lua policy code\nlocal key_bytes = {\n  key_data = 'your key',\n}\nlocal hmac = kumo.digest.hmac_sha384(key_bytes, 'your message')\nassert(\n  hmac.hex\n    == 'cd274957b95ce192d41dd52f83fd2eb9277aa2fa210ec798ee16e978801a89b7e7b956af3976d1a50a60ec|'\n)\n</code></pre>"},{"location":"reference/kumo.digest/hmac_sha512/","title":"hmac_sha512","text":"<pre><code>kumo.digest.hmac_sha512(KEY, MSG)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes an HMAC digest over the <code>MSG</code> argument, using <code>KEY</code> as the means for signing/authenticating the data.</p> <p>This function uses <code>SHA512</code> as the digest algorithm for the HMAC.</p> <p>The <code>KEY</code> parameter is expected to be a KeySource defining how to access the secret key bytes.</p> <p>The returned value is a BinaryResult object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/hmac_sha512/#computing-the-hmac-with-a-string-based-key","title":"Computing the HMAC with a string-based key","text":"<pre><code>local kumo = require 'kumo'\n\n-- It is not recommended to use this form in production.\n-- Consider storing the key in either a vault or in a local\n-- file to keep the credential material outside of the repo\n-- where you maintain your lua policy code\nlocal key_bytes = {\n  key_data = 'your key',\n}\nlocal hmac = kumo.digest.hmac_sha512(key_bytes, 'your message')\nassert(\n  hmac.hex\n    == '2f5ddcdbd062a5392f07b0cd0262bf52c21bfb3db513296240cca8d5accc09d18d96be0a94995be4494c032f1eda946ad549fb61ccbe985d160f0b2f9588d34b'\n)\n</code></pre>"},{"location":"reference/kumo.digest/sha1/","title":"sha1","text":"<pre><code>kumo.digest.sha1(ARGS)\n</code></pre> <p>Computes a SHA1 digest over each of the arguments in ARGS.</p> <p>Note</p> <p>SHA1 is a deprecated algorithm that is no longer recommended for cryptographic usage.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha224/","title":"sha224","text":"<pre><code>kumo.digest.sha224(ARGS)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes a SHA224 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha256/","title":"sha256","text":"<pre><code>kumo.digest.sha256(ARGS)\n</code></pre> <p>Computes a SHA256 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha384/","title":"sha384","text":"<pre><code>kumo.digest.sha384(ARGS)\n</code></pre> <p>Computes a SHA384 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha3_256/","title":"sha3_256","text":"<pre><code>kumo.digest.sha3_256(ARGS)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes a SHA3_256 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha3_384/","title":"sha3_384","text":"<pre><code>kumo.digest.sha3_384(ARGS)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes a SHA3_384 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha3_512/","title":"sha3_512","text":"<pre><code>kumo.digest.sha3_512(ARGS)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Computes a SHA3_512 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha512/","title":"sha512","text":"<pre><code>kumo.digest.sha512(ARGS)\n</code></pre> <p>Computes a SHA512 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha512_256/","title":"sha512_256","text":"<pre><code>kumo.digest.sha512_256(ARGS)\n</code></pre> <p>Computes a <code>SHA512_256</code> digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.dkim/","title":"Module <code>kumo.dkim</code>","text":"<p>This module provides functions that are useful when working with DomainKeys Identified Mail.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/","title":"ed25519_signer","text":"<pre><code>kumo.dkim.ed25519_signer { PARAMS }\n</code></pre> <p>Create a DKIM signer that uses ED25519 keys.</p> <p>The key data must be PKCS8 DER encoded data.</p> <p>This function will attempt to load V2 data first, which must contain the matching public and private key pair.</p> <p>If the data cannot be loaded as V2, then it will fall back to try to load V1 data, which contains just the private key.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>We now support loading either DER or PEM encoded PKCS8 private keys.</p> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\n  local signer = kumo.dkim.ed25519_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.der',\n  }\n  msg:dkim_sign(signer)\nend)\n</code></pre> <p>A signer object employs two-level caching to manage the loading of the underlying key (<code>dkim_key_cache</code>) as well as the higher level signing object itself (<code>dkim_signer_cache</code>).  See kumo.set_lruttl_cache_capacity for tuning the maximum cache capacity.</p> <p><code>PARAMS</code> is a lua table that can have the following keys:</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#domain","title":"domain","text":"<p>Required. The domain for which the mail is being signed.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#selector","title":"selector","text":"<p>Required. The selector used for signing</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#headers","title":"headers","text":"<p>Required. The list of headers which should be signed.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#atps","title":"atps","text":"<p>Optional string. Allows setting the Authorized Third-Party signature.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#atpsh","title":"atpsh","text":"<p>Optional string. Set the Authorized Third-Party Signature hashing algorithm.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#agent_user_identifier","title":"agent_user_identifier","text":"<p>Optional string. Sets the Agent of User Identifier (AUID) to use for signing.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#expiration","title":"expiration","text":"<p>Optional number. Sets the number of seconds from now to use for the signature expiration.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#body_length","title":"body_length","text":"<p>Optional boolean. If <code>true</code>, the body length will be included in the signature.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#reporting","title":"reporting","text":"<p>Optional boolean. If <code>true</code>, the signature will be marked as requesting reports from the receiver/verifier.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#header_canonicalization","title":"header_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message headers.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/ed25519_signer/#body_canonicalization","title":"body_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message body.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/ed25519_signer/#key","title":"key","text":"<p>Required. Specify the signing key.</p> <p>The value is a KeySource.</p> <p>The key data must be PKCS8 DER encoded data.</p> <pre><code>local file_signer = kumo.dkim.ed25519_signer {\n  domain = msg:from_header().domain,\n  selector = 'default',\n  headers = { 'From', 'To', 'Subject' },\n  key = '/path/to/example-private-dkim-key.pem',\n}\n</code></pre> <p>Tip</p> <p>The KeySource page explains how to read from HashiCorp Vault or from an arbitrary source of data.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#ttl","title":"ttl","text":"<p>Optional number. Specifies the time-to-live (TTL) in KumoMTA's DKIM signer cache.  The default is <code>300</code> seconds.</p> <p>Each call to this function with the same parameters is cached for up to the specified TTL in order to avoid the overhead of repeatedly load the key from disk.</p> <p>Since: Version 2025.03.19-1d3f1f67</p> <p>The functionality described in this outlined box requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>The ttl now supports a duration string like <code>\"5 mins\"</code></p>"},{"location":"reference/kumo.dkim/ed25519_signer/#over_sign","title":"over_sign","text":"<p>Since: Version 2024.06.10-84e84b89</p> <p>The functionality described in this outlined box requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Optional boolean. If <code>true</code> then the list of <code>headers</code> will be adjusted to match the email message being signed so that the message is signed in such a way that a replay attack cannot forge additional headers without invalidating the signature.</p> <p>The way this works is by counting the number of headers in the message, so if you set:</p> <pre><code>headers = {'From', 'To', 'Subject'},\n</code></pre> <p>and the message had 1 instance each of <code>From</code> and <code>To</code>, but was, for whatever reason, missing the <code>Subject</code> header, it would compute the effective header list as:</p> <pre><code>headers = {'From', 'From', 'To', 'To', 'Subject'},\n</code></pre> <p>In other words, it will compute <code>N</code> as the number of times each of your listed headers are found in the email to be signed, then treat it as though you listed that name <code>N+1</code> times in your configuration.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/","title":"rsa_sha256_signer","text":"<pre><code>kumo.dkim.rsa_sha256_signer { PARAMS }\n</code></pre> <p>Create a DKIM signer that uses RSA SHA256.</p> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\n  local signer = kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.pem',\n  }\n  msg:dkim_sign(signer)\nend)\n</code></pre> <p>A signer object employs two-level caching to manage the loading of the underlying key (<code>dkim_key_cache</code>) as well as the higher level signing object itself (<code>dkim_signer_cache</code>).  See kumo.set_lruttl_cache_capacity for tuning the maximum cache capacity.</p> <p><code>PARAMS</code> is a lua table that can have the following keys:</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#domain","title":"domain","text":"<p>Required. The domain for which the mail is being signed.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#selector","title":"selector","text":"<p>Required. The selector used for signing</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#headers","title":"headers","text":"<p>Required. The list of headers which should be signed.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#atps","title":"atps","text":"<p>Optional string. Allows setting the Authorized Third-Party signature.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#atpsh","title":"atpsh","text":"<p>Optional string. Set the Authorized Third-Party Signature hashing algorithm.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#agent_user_identifier","title":"agent_user_identifier","text":"<p>Optional string. Sets the Agent of User Identifier (AUID) to use for signing.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#expiration","title":"expiration","text":"<p>Optional number. Sets the number of seconds from now to use for the signature expiration.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#body_length","title":"body_length","text":"<p>Optional boolean. If <code>true</code>, the body length will be included in the signature.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#reporting","title":"reporting","text":"<p>Optional boolean. If <code>true</code>, the signature will be marked as requesting reports from the receiver/verifier.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#header_canonicalization","title":"header_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message headers.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#body_canonicalization","title":"body_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message body.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#key","title":"key","text":"<p>Required. Specify the signing key data.</p> <p>The value is a KeySource.</p> <p>The key data must be either RSA PEM or a PKCS8 PEM encoded.</p> <pre><code>local file_signer = kumo.dkim.rsa_sha256_signer {\n  domain = msg:from_header().domain,\n  selector = 'default',\n  headers = { 'From', 'To', 'Subject' },\n  key = '/path/to/example-private-dkim-key.pem',\n}\n</code></pre> <p>Tip</p> <p>The KeySource page explains how to read from HashiCorp Vault or from an arbitrary source of data.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#ttl","title":"ttl","text":"<p>Optional number. Specifies the time-to-live (TTL) in KumoMTA's DKIM signer cache.  The default is <code>300</code> seconds.</p> <p>Each call to this function with the same parameters is cached for up to the specified TTL in order to avoid the overhead of repeatedly load the key from disk.</p> <p>Since: Version 2025.03.19-1d3f1f67</p> <p>The functionality described in this outlined box requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>The ttl now supports a duration string like <code>\"5 mins\"</code></p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#over_sign","title":"over_sign","text":"<p>Since: Version 2024.06.10-84e84b89</p> <p>The functionality described in this outlined box requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Optional boolean. If <code>true</code> then the list of <code>headers</code> will be adjusted to match the email message being signed so that the message is signed in such a way that a replay attack cannot forge additional headers without invalidating the signature.</p> <p>The way this works is by counting the number of headers in the message, so if you set:</p> <pre><code>headers = {'From', 'To', 'Subject'},\n</code></pre> <p>and the message had 1 instance each of <code>From</code> and <code>To</code>, but was, for whatever reason, missing the <code>Subject</code> header, it would compute the effective header list as:</p> <pre><code>headers = {'From', 'From', 'To', 'To', 'Subject'},\n</code></pre> <p>In other words, it will compute <code>N</code> as the number of times each of your listed headers are found in the email to be signed, then treat it as though you listed that name <code>N+1</code> times in your configuration.</p>"},{"location":"reference/kumo.dkim/set_signing_threads/","title":"set_signing_threads","text":"<pre><code>kumo.dkim.set_signing_threads(N)\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>Sets the number of threads to be used for the <code>dkimsign</code> thread pool.  This thread pool is used to perform DKIM signing, a cryptographic operation that is CPU intensive.</p> <p>By default, there is no <code>dkimsign</code> pool and signing operations happen in the context of the calling thread.</p> <p>Some workloads are a blend of IO and compute, which makes it awkward to appropriately size the thread pool in the calling context.</p> <p>In that situation you can call this function to start up the signing thread pool with an appropriate number of threads like this:</p> <pre><code>kumo.on('pre_init', function()\n  -- Use half the cores on the system for DKIM signing\n  kumo.dkim.set_signing_threads(math.ceil(kumo.available_parallelism() / 2))\nend)\n</code></pre> <p>Using the dkimsign pool adds a bit of overhead in context switching but allows you to have a larger number of threads in the <code>smtpsrv</code> or <code>readyq</code> thread pools to accommodate their more IO-bound workload better.</p>","tags":["threadpool"]},{"location":"reference/kumo.dns/","title":"Module <code>kumo.dns</code>","text":"<p>This module provides functions that work with querying DNS.</p>"},{"location":"reference/kumo.dns/configure_resolver/","title":"configure_resolver","text":"<pre><code>kumo.dns.configure_resolver { PARAMS }\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>By default, KumoMTA will parse the system resolver configuration and use that to drive its internal caching Hickory DNS resolver.</p> <p>This function allows you to configure DNS resolving differently from your system configuration.</p> <p>Note</p> <p>This function should be called only from inside your init event handler.</p> <p><code>PARAMS</code> is a lua table with the following fields:</p> <ul> <li><code>name_servers</code> - required; a list of name servers. Each entry can be either a   simple string of the form <code>\"IP:PORT\"</code> or can be a lua table that allows   specifying the protocol that should be used.</li> <li><code>domain</code> - optional; the local dns domain name to append to names.   Note that MX resolution in KumoMTA always appends a trailing <code>.</code> to   the names from the envelope addresses so this setting should be   irrelevant for MX resolution.</li> <li><code>search</code> - optional; list of additional search domains.   Note that MX resolution in KumoMTA always appends a trailing <code>.</code> to   the names from the envelope addresses so this setting should be   irrelevant for MX resolution.</li> <li><code>options</code> - a lua table listing out additional resolver options.   The possible names, values and meanings are documented in   the hickory DNS resolver documentation; see the table below:</li> </ul> KumoMTA Version Hickory DNS ResolverOpts 2025.03.19-1d3f1f67 hickory DNS 0.24 2025.05.06-b29689af hickory DNS 0.25 <pre><code>kumo.on('init', function()\n  kumo.dns.configure_resolver {\n    name_servers = {\n      -- Simple UDP based entry\n      '10.0.0.1:53',\n      -- Use tcp with a controlled local address\n      {\n        socket_addr = '10.0.0.20:53',\n        protocol = 'tcp',\n        -- an NXDOMAIN entry will be treated as truth and\n        -- we won't query other nameservers to see if they\n        -- can resolve a given query\n        trust_negative_responses = true,\n        bind_addr = '10.0.0.2:0',\n      },\n    },\n    options = {\n      edns0 = true,\n      use_hosts_file = 'Auto',\n    },\n  }\nend)\n</code></pre> <p>See also kumo.dns.configure_unbound_resolver.</p>"},{"location":"reference/kumo.dns/configure_unbound_resolver/","title":"configure_unbound_resolver","text":"<pre><code>kumo.dns.configure_unbound_resolver { PARAMS }\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>By default, KumoMTA will parse the system resolver configuration and use that to drive its internal caching Hickory DNS resolver.</p> <p>This function allows you to configure DNS resolving differently from your system configuration, and to use Unbound embedded DNS resolver.</p> <p>If you have enabled DANE for output SMTP then you must enable the unbound resolver in order to be able to process DNSSEC correctly.</p> <p>Note</p> <p>This function should be called only from inside your init event handler.</p> <p>The parameters to this functions are the same as those to kumo.dns.configure_resolver.</p> <pre><code>kumo.on('init', function()\n  kumo.dns.configure_unbound_resolver {\n    options = {\n      -- Enable DNSSEC\n      validate = true,\n    },\n    -- By default, if you omit `name_servers`, unbound will\n    -- resolve via the root resolvers.\n    -- We strongly recommend deploying local caching nameservers\n    -- and referencing them here:\n    -- name_servers = { '1.1.1.1:53' },\n  }\nend)\n</code></pre>"},{"location":"reference/kumo.dns/define_resolver/","title":"define_resolver","text":"<pre><code>kumo.dns.define_resolver(NAME, CONFIG)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This function defines an alternative resolver from the default configured via configure_resolver, and gives it a name.</p> <p>The alternate resolver name can then be optionally passed as a parameter to a number of other <code>kumo.dns</code> functions.</p> <p>The intended use case is to define an alternate resolver that points to an rbldnsd or similar specialized resolver that provides access to a DNSBL.</p> <p>The <code>NAME</code> parameter is a string that defines the name of the alternate resolver.</p> <p>The <code>CONFIG</code> parameter defines the parameters for the resolver.  It can have one of the following shapes:</p> <p>Note</p> <p>This function should be called only from inside your init event handler.</p>"},{"location":"reference/kumo.dns/define_resolver/#hickory-with-an-explicit-upstream","title":"Hickory with an explicit upstream","text":"<p>If you have <code>rbldnsd</code> or similar available on <code>10.0.0.1:53</code>, then you might use this:</p> <pre><code>kumo.dns.define_resolver('rbl', {\n  Hickory = {\n    name_servers = {\n      '10.0.0.1:53',\n    },\n  },\n})\n</code></pre> <p>You can then query it:</p> <pre><code>local answer, reason = kumo.dns.rbl_lookup(IP, 'rbl.domain', 'rbl')\n</code></pre>"},{"location":"reference/kumo.dns/define_resolver/#test-or-static-dns","title":"Test or static DNS","text":"<p>If you have fixed and locally available zone data, then you can query that explicitly:</p> <p><pre><code>kumo.dns.define_resolver('rbl', {\n  Test = {\n    zones = {\n      [[\n$ORIGIN rbl.domain.\n1.0.0.10 30 IN A   127.0.0.2\n1.0.0.10 300   TXT \"Blocked for a very good reason!\"\n  ]],\n    },\n  },\n})\n</code></pre> You can then query it:</p> <pre><code>local answer, reason = kumo.dns.rbl_lookup('10.0.0.1', 'rbl.domain', 'rbl')\n</code></pre> <p>This mode of operation was originally intended for testing, but may prove useful in other situations.</p>"},{"location":"reference/kumo.dns/define_resolver/#system-default","title":"System Default","text":"<pre><code>kumo.dns.define_resolver('myresolver', 'HickorySystemConfig')\n</code></pre> <p>Parses the system resolver configuration and applies that to a separate instance of the hickory DNS resolver client. This is equivalent to the default resolver settings in kumomta.</p>"},{"location":"reference/kumo.dns/define_resolver/#unbound-with-an-explicit-upstream","title":"Unbound with an explicit upstream","text":"<p>Note</p> <p>We generally recommend sticking with Hickory unless you have a very good reason.</p> <p>If you have <code>rbldnsd</code> or similar available on <code>10.0.0.1:53</code>, then you might use this:</p> <pre><code>kumo.dns.define_resolver('rbl', {\n  Unbound = {\n    name_servers = {\n      '10.0.0.1:53',\n    },\n  },\n})\n</code></pre> <p>You can then query it:</p> <pre><code>local answer, reason = kumo.dns.rbl_lookup(IP, 'rbl.domain', 'rbl')\n</code></pre>"},{"location":"reference/kumo.dns/define_resolver/#aggregating-different-resolvers","title":"Aggregating Different Resolvers","text":"<p>If you have a mixture of local zone files and a remote DNS, then you can mix them together; have the local zones queried before falling back to a remote host.</p> <p>In the example below, the local zone is used first before falling back to querying the upstream specified by the system.</p> <pre><code>kumo.dns.define_resolve('aggregate', {\n  Aggregate = {\n    -- The value of `Aggregate` here is an array style table\n    -- listing out one of the CONFIG options shown in the\n    -- examples above.\n\n    -- First we have a Test setup\n    Test = {\n      zones = {\n        [[\n$ORIGIN 0.0.127.in-addr.arpa.\n1 30 IN PTR localhost.\n  ]],\n      },\n    },\n\n    -- Then we have a system default setup\n    'HickorySystemConfig',\n  },\n})\n</code></pre>"},{"location":"reference/kumo.dns/lookup_addr/","title":"lookup_addr","text":"<pre><code>kumo.dns.lookup_addr(NAME, OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Resolve the <code>A</code> and <code>AAAA</code> records for the requested <code>NAME</code>.</p> <p>Raises an error if the name doesn't exist in DNS.</p> <p>Returns an array style table listing the IPv4 and IPv6 addresses as strings.</p> <p>DNS results are cached according to the TTL specified by the DNS record itself.</p> <pre><code>print(kumo.json_encode(kumo.dns.lookup_addr 'localhost'))\n\n-- prints out:\n-- [\"127.0.0.1\",\"::1\"]\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The <code>OPT_RESOLVER_NAME</code> is an optional string parameter that specifies the name of a alternate resolver defined via define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/kumo.dns/lookup_mx/","title":"lookup_mx","text":"<pre><code>kumo.dns.lookup_mx(DOMAIN)\n</code></pre> <p>Resolve the MX information for the requested <code>DOMAIN</code>.</p> <p>Raises an error if the domain doesn't exist.</p> <p>Returns a lua table with the structure shown in the example below.</p> <p>DNS results are cached according to the TTL specified by the DNS record itself.</p> <p>This example shows the <code>gmail.com</code> MX information.  At the time of writing, the DNS information looks like this:</p> <pre><code>$ dig +nocomments mx gmail.com.\n\n; &lt;&lt;&gt;&gt; DiG 9.18.12 &lt;&lt;&gt;&gt; +nocomments mx gmail.com.\n;; global options: +cmd\n;gmail.com.                     IN      MX\ngmail.com.              1620    IN      MX      30 alt3.gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      40 alt4.gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      5 gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      10 alt1.gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      20 alt2.gmail-smtp-in.l.google.com.\n;; Query time: 0 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)\n;; WHEN: Wed Mar 15 09:24:03 MST 2023\n;; MSG SIZE  rcvd: 161\n</code></pre> <pre><code>-- Query the gmail mx\nlocal gmail_mx = kumo.dns.lookup_mx 'gmail.com'\n\n-- This is what we expect it to look like\nlocal example = {\n  by_pref = {\n    -- Each preference level has a sorted list of hosts\n    -- at that level\n    [5] = {\n      'gmail-smtp-in.l.google.com.',\n    },\n    [10] = {\n      'alt1.gmail-smtp-in.l.google.com.',\n    },\n    [20] = {\n      'alt2.gmail-smtp-in.l.google.com.',\n    },\n    [30] = {\n      'alt3.gmail-smtp-in.l.google.com.',\n    },\n    [40] = {\n      'alt4.gmail-smtp-in.l.google.com.',\n    },\n  },\n\n  -- The site name is deterministically derived from the by_pref information\n  site_name = '(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com',\n\n  -- The FQDN that was resolved\n  domain_name = 'gmail.com.',\n\n  -- The flattened set of hosts in preference order\n  hosts = {\n    'gmail-smtp-in.l.google.com.',\n    'alt1.gmail-smtp-in.l.google.com.',\n    'alt2.gmail-smtp-in.l.google.com.',\n    'alt3.gmail-smtp-in.l.google.com.',\n    'alt4.gmail-smtp-in.l.google.com.',\n  },\n\n  -- true if the domain is a literal IPv4 or IPv6 address such as\n  -- `[10.0.0.1]` or `[IPv6:::1]`\n  is_domain_literal = false,\n  -- true if the hosts are mx records\n  is_mx = true,\n}\n\nassert(gmail_mx == example)\n</code></pre>"},{"location":"reference/kumo.dns/lookup_ptr/","title":"lookup_ptr","text":"<pre><code>kumo.dns.lookup_ptr(IP, OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Resolve PTR records for the requested <code>IP</code>.</p> <p>Raises an error if there was an issue resolving the record.</p> <p>Returns a lua array-style table with the list of PTR records returned from DNS.  The table may be empty.</p> <pre><code>local ok, records = pcall(kumo.dns.lookup_ptr, '127.0.0.1')\nif ok then\n  for _, a in ipairs(records) do\n    print(a)\n  end\nend\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The <code>OPT_RESOLVER_NAME</code> is an optional string parameter that specifies the name of a alternate resolver defined via define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/kumo.dns/lookup_txt/","title":"lookup_txt","text":"<pre><code>kumo.dns.lookup_txt(DOMAIN, OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Resolve a TXT record for the requested <code>DOMAIN</code>.</p> <p>Raises an error if the domain doesn't exist.</p> <p>Returns a lua array-style table with the list of txt records returned from DNS.</p> <pre><code>assert(\n  kumo.serde.json_encode(kumo.dns.lookup_txt 'gmail.com')\n    == '[\"v=spf1 redirect=_spf.google.com\",\"globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=\"]'\n)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The <code>OPT_RESOLVER_NAME</code> is an optional string parameter that specifies the name of a alternate resolver defined via define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/kumo.dns/ptr_host/","title":"ptr_host","text":"<pre><code>local domain = kumo.dns.ptr_host(IP)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Given an IP address in either V4 or V6 format as the input, returns the reversed address plus appropriate top level domain suitable for performing a reverse lookup.</p> <p>This function is purely local string manipulation; no actual DNS queries are performed.</p> <p>You will typically use lookup_ptr to perform an actual PTR lookup; this function is a utility function for the cases where you're doing something unusual.</p> <pre><code>print(kumo.dns.ptr_host '127.0.0.1')\n-- prints out:\n-- 1.0.0.127.in-addr.arpa\n</code></pre> <pre><code>print(kumo.dns.ptr_host '::1')\n-- prints out:\n-- 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\n</code></pre>"},{"location":"reference/kumo.dns/rbl_lookup/","title":"rbl_lookup","text":"<pre><code>local answer, reason = kumo.dns.rbl_lookup(IP, BASE_DOMAIN, OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This is a convenience function that enables looking up an IP address in a DNSBL.</p> <p>The <code>IP</code> parameter is either an IPv4 or IPv6 address string, and for the sake of convenience, allows a socket address with optional port number.</p> <p>The <code>BASE_DOMAIN</code> parameter is the base domain to consult.  The value used here depends on which RBL is being queried and whether you're using a service in public DNS or are running a local resolver that is hosting RBL zones.</p> <p>The <code>OPT_RESOLVER_NAME</code> is an optional string parameter that specifies the name of a alternate resolver defined via define_resolver.  You can omit this parameter and the default resolver will be used.</p> <p>The return value is a tuple consisting of the IP address that the lookup resolves to, if any, and the corresponding TXT record if there was an IP address.</p> <p>Generally speaking, the returned IP address will be <code>127.0.0.2</code> to indicate that an IP is blocked, but it may also be some other non-<code>127.0.0.1</code> loopback address to indicate some other listing status depending on the RBL that you are querying.</p> <p>If the IP is not present on the RBL, both values of the tuple will be <code>nil</code>.</p>"},{"location":"reference/kumo.dns/rbl_lookup/#querying-spamcop","title":"Querying SpamCop","text":"<p>This example shows how to query SpamCop to see if an IP address is listed.  This example is using the test IP <code>127.0.0.2</code> which is always listed, in order to demonstrate the expected results when an IP is blocked:</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nlocal ip, reason = kumo.dns.rbl_lookup('127.0.0.2', 'bl.spamcop.net')\nprint(ip, reason)\nutils.assert_eq(ip, '127.0.0.2')\nutils.assert_eq(\n  reason,\n  'Blocked - see https://www.spamcop.net/bl.shtml?127.0.0.2'\n)\n</code></pre> <p>A more real world example might look something like:</p> <pre><code>local ip, reason =\n  kumo.dns.rbl_lookup(msg:get_meta 'received_from', 'bl.spamcop.net')\nif ip then\n  kumo.reject(550, string.format('5.7.1 %s', reason))\nend\n</code></pre>"},{"location":"reference/kumo.dns/reverse_ip/","title":"reverse_ip","text":"<pre><code>local reversed = kumo.dns.reverse_ip(IP)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Given an IP address in either V4 or V6 format as the input, returns the reversed address.</p> <p>This function is purely local string manipulation; no actual DNS queries are performed.</p> <pre><code>print(kumo.dns.reverse_ip '127.0.0.1')\n-- prints out:\n-- 1.0.0.127\n</code></pre> <pre><code>print(kumo.dns.reverse_ip '::1')\n-- prints out:\n-- 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0\n</code></pre>"},{"location":"reference/kumo.dns/set_mx_concurrency_limit/","title":"set_mx_concurrency_limit","text":"<pre><code>kumo.dns.set_mx_concurrency_limit(LIMIT)\n</code></pre> Since: Version 2025.05.06-b29689af <p>The functionality described in this section requires version 2025.05.06-b29689af of KumoMTA, or a more recent version.</p> <p>Set the maximum number of concurrent MX lookups that we will allow to send to the upstream DNS resolver.</p> <p>The default is 128.</p> <p>In earlier versions of kumomta, there was no default, issuing as many queries as we were requested to make at any given moment.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.dns.set_mx_concurrency_limit(128)\nend)\n</code></pre>"},{"location":"reference/kumo.dns/set_mx_negative_cache_ttl/","title":"set_mx_negative_cache_ttl","text":"<pre><code>kumo.dns.set_mx_negative_cache_ttl(DURATION)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Set the negative cache TTL that should be used when caching an MX resolution failure.</p> <p><code>DURATION</code> is either a number expressed as optionally fractional seconds, or a human readable duration string like <code>\"5s\"</code> to specify the units.</p> <p>The default value for this is <code>\"5 minutes\"</code>.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.dns.set_mx_negative_cache_ttl '10m'\nend)\n</code></pre>"},{"location":"reference/kumo.dns/set_mx_timeout/","title":"set_mx_timeout","text":"<pre><code>kumo.dns.set_mx_timeout(DURATION)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Set overall time limit for MX record resolution.  This applies to the MX record resolution, rather than the resolution of MX hosts into addresses.</p> <p><code>DURATION</code> is either a number expressed as optionally fractional seconds, or a human readable duration string like <code>\"5s\"</code> to specify the units.</p> <p>The default value for this is <code>\"5 seconds\"</code>.</p> <p>Note</p> <p>This timeout is layered over any internal timeout that the underlying DNS resolver might be configured to use, which means that the effective timeout will be the smallest of both this value and what is configured for the underlying resolver.</p> <pre><code>kumo.on('pre_init', function()\n  kumo.dns.set_mx_timeout(5)\n  -- or alternatively: kumo.dns.set_mx_timeout(\"5s\")\nend)\n</code></pre>"},{"location":"reference/kumo.domain_map/","title":"Module <code>kumo.domain_map</code>","text":"<p>This module provides functions that help with making wildcard domain name -&gt; value maps.</p>"},{"location":"reference/kumo.domain_map/new/","title":"kumo.domain_map.new","text":"<pre><code>kumo.domain_map.new([{MAP}])\n</code></pre> <p>Create a new domain map, optionally seeded with an initial set of key/value pairs.</p> <p>A domain map is a dictionary type that allows resolving the value associated with a domain name key, supporting wildcard domain keys in the mapping.</p> <p>For simple inputs, the mapping behaves as you might expect for a dictionary type:</p> <pre><code>local dmap = kumo.domain_map.new()\ndmap['foo'] = 'bar'\nassert(dmap['foo'] == 'bar')\nassert(dmap['not.set'] == nil)\n</code></pre> <p>you can define wildcard keys:</p> <pre><code>local dmap = kumo.domain_map.new()\n\ndmap['*.example.com'] = 'wildcard'\n\n-- An exact lookup for example.com won't match the wildcard\nassert(dmap['example.com'] == nil)\n\n-- but any nodes \"below\" that will match the wildcard entry:\nassert(dmap['foo.example.com'] == 'wildcard')\n\n-- Any explicitly added entries will take precedence\n-- over the wildcard:\ndmap['explicit.example.com'] = 'explicit'\nassert(dmap['explicit.example.com'] == 'explicit')\n</code></pre> <p>You may seed an initial value from a pre-existing lua table:</p> <pre><code>local dmap = kumo.domain_map.new {\n  ['*.woot.com'] = 123,\n  ['example.com'] = 24,\n}\n\n-- and mutate the table after is has been constructed:\ndmap['*.example.com'] = 42\n\nassert(dmap['lemon.example.com'] == 42)\nassert(dmap['example.com'] == 24)\nassert(dmap['woot.com'] == nil)\nassert(dmap['aa.woot.com'] == 123)\n</code></pre>"},{"location":"reference/kumo.encode/","title":"Module <code>kumo.encode</code>","text":"<p>This module provides functions for encoding data in standard representations such as base64 or hex.</p>"},{"location":"reference/kumo.encode/base32_decode/","title":"kumo.encode.base32_decode","text":"<pre><code>kumo.encode.base32_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base32 encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32_encode/","title":"kumo.encode.base32_encode","text":"<pre><code>kumo.encode.base32_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base32 encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base32_nopad_decode/","title":"kumo.encode.base32_nopad_decode","text":"<pre><code>kumo.encode.base32_nopad_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base32_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32_nopad_encode/","title":"kumo.encode.base32_nopad_encode","text":"<pre><code>kumo.encode.base32_nopad_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies <code>base32_nopad</code> encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base32hex_decode/","title":"kumo.encode.base32hex_decode","text":"<pre><code>kumo.encode.base32hex_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base32hex encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32hex_encode/","title":"kumo.encode.base32hex_encode","text":"<pre><code>kumo.encode.base32hex_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base32hex encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base32hex_nopad_decode/","title":"kumo.encode.base32hex_nopad_decode","text":"<pre><code>kumo.encode.base32hex_nopad_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base32hex_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32hex_nopad_encode/","title":"kumo.encode.base32hex_nopad_encode","text":"<pre><code>kumo.encode.base32hex_nopad_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base32hex encoding, with no padding, to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64_decode/","title":"kumo.encode.base64_decode","text":"<pre><code>kumo.encode.base64_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base64 encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64_encode/","title":"kumo.encode.base64_encode","text":"<pre><code>kumo.encode.base64_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base64 encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64_nopad_decode/","title":"kumo.encode.base64_nopad_decode","text":"<pre><code>kumo.encode.base64_nopad_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base64_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64_nopad_encode/","title":"kumo.encode.base64_nopad_encode","text":"<pre><code>kumo.encode.base64_nopad_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies <code>base64_nopad</code> encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64url_decode/","title":"kumo.encode.base64url_decode","text":"<pre><code>kumo.encode.base64url_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base64url encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64url_encode/","title":"kumo.encode.base64url_encode","text":"<pre><code>kumo.encode.base64url_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base64url encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64url_nopad_decode/","title":"kumo.encode.base64url_nopad_decode","text":"<pre><code>kumo.encode.base64url_nopad_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base64url_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64url_nopad_encode/","title":"kumo.encode.base64url_nopad_encode","text":"<pre><code>kumo.encode.base64url_nopad_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies <code>base64url_nopad</code> encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/hex_decode/","title":"kumo.encode.hex_decode","text":"<pre><code>kumo.encode.hex_decode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes hex encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/hex_encode/","title":"kumo.encode.hex_encode","text":"<pre><code>kumo.encode.hex_encode(STRING)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies hex encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.file_type/","title":"kumo.file_type","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The <code>kumo.file_type</code> module includes functions that can help you to reason about the file type of a sequence of bytes, or about the file types associated with mime media types or filename extensions.</p> <p>The underlying implementation of this module is provided by the file_type Rust crate.</p>"},{"location":"reference/kumo.file_type/#filetyperesult","title":"FileTypeResult","text":"<p>The functions in this module all return a file type result which has the following shape:</p> <pre><code>local file_type = {\n  -- The human readable name of the file type\n  name = 'Java class file',\n  -- The file type extensions, not including the dot\n  extensions = { 'class' },\n  -- The [RFC 2046 MIME Media Types](https://www.rfc-editor.org/rfc/rfc2046.html)\n  -- associated with this file type\n  media_types = {\n    'application/java',\n    'application/java-byte-code',\n    'application/java-vm',\n    'application/x-httpd-java',\n    'application/x-java',\n    'application/x-java-class',\n    'application/x-java-vm',\n  },\n}\n</code></pre>"},{"location":"reference/kumo.file_type/from_bytes/","title":"kumo.file_type.from_bytes","text":"<pre><code>local ft = kumo.file_type.from_bytes(BYTES)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Attempts to determine the file type from the provided string, which may also be binary bytes.</p> <p>This function will always succeed in returning a guess, which may or may not be accurate.</p> <p>The return value is a FileTypeResult</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nlocal ft = kumo.file_type.from_bytes '\\xCA\\xFE\\xBA\\xBE'\nutils.assert_eq(ft, {\n  name = 'Java class file',\n  extensions = { 'class' },\n  media_types = {\n    'application/java',\n    'application/java-byte-code',\n    'application/java-vm',\n    'application/x-httpd-java',\n    'application/x-java',\n    'application/x-java-class',\n    'application/x-java-vm',\n  },\n})\n</code></pre>"},{"location":"reference/kumo.file_type/from_extension/","title":"kumo.file_type.from_extension","text":"<pre><code>local ft_list = kumo.file_type.from_extension(EXT)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Returns the list of file types that have the specified filename extension.</p> <p>This function will return an array style table holding one entry for each file type that has the specified filename extension.</p> <p>Each element of the array is a FileTypeResult.</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nlocal markdown = kumo.file_type.from_extension 'markdown'\nutils.assert_eq(markdown, {\n  {\n    name = 'Q1193600',\n    media_types = {\n      'text/markdown',\n    },\n    extensions = {\n      'markdown',\n      'md',\n      'mdown',\n      'mdtext',\n      'mdtxt',\n      'mkd',\n    },\n  },\n})\n</code></pre>"},{"location":"reference/kumo.file_type/from_media_type/","title":"kumo.file_type.from_media_type","text":"<pre><code>local ft_list = kumo.file_type.from_media_type(EXT)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Returns the list of file types that have the specified MIME media type.</p> <p>This function will return an array style table holding one entry for each file type that has the specified media type.</p> <p>Each element of the array is a FileTypeResult.</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nlocal png = kumo.file_type.from_media_type 'image/png'\n-- Note that we're just looking at the first element of\n-- the returned array here; there are a number of entries\n-- returned for this media type\nutils.assert_eq(png[1], {\n  name = 'Portable Network Graphics',\n  media_types = { 'image/png' },\n  extensions = { 'png' },\n})\n</code></pre>"},{"location":"reference/kumo.fs/","title":"Module <code>kumo.fs</code>","text":"<p>This module provides an interface to the filesystem that is aware of kumo's internal event scheduling, and that will avoid blocking threads while waiting for file IO.</p>"},{"location":"reference/kumo.fs/glob/","title":"kumo.fs.glob","text":"<pre><code>kumo.fs.glob(pattern [, relative_to, [, ttl_seconds]])\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>This function evalutes the glob <code>pattern</code> and returns an array containing the absolute file names of the matching results.  Due to limitations in the lua bindings, all of the paths must be able to be represented as UTF-8 or this function will generate an error.</p> <p>The optional <code>relative_to</code> parameter can be used to make the results relative to a path.  If the results have the same prefix as <code>relative_to</code> then it will be removed from the returned path. The default for this parameter is <code>.</code>.</p> <p>The optional <code>ttl_seconds</code> parameter specifies how long the results of the glob operation will be cached.  Subsequent calls to <code>glob</code> with the same <code>pattern</code> and <code>relative_to</code> will return those previously cached results until the TTL expires.  The default TTL is <code>60</code> seconds.</p> <p>Warning</p> <p>This function can cause an expensive filesystem walk to occur, especially if used on a storage volume that is experiencing IO pressure (such as from spooling or logging). Take care to scope the pattern to minimize the impact of the walk, and the <code>ttl_seconds</code> parameter to something that is appropriate to your use case.</p> <p>Note</p> <p>If the specified pattern or path references a directory that doesn't exist, or a directory that is inaccessible to the kumo user, no error will be generated; those paths are silently omitted from the results.</p> <pre><code>local kumo = require 'kumo'\n\n-- logs the names of all of the '*.conf' files under `/etc`\nprint(kumo.json_encode_pretty(kumo.fs.glob '/etc/*.conf'))\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/open/","title":"kumo.fs.open","text":"<pre><code>FILE = kumo.fs.open(FILENAME, OPT_MODE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>This function is similar to the lua builtin <code>io.open</code> function in that it can be used to open a file on the filesystem either for reading or writing. It differs from the builtin lua function in two key ways:</p> <ul> <li> <p><code>kumo.fs.open</code> and the <code>async-file</code> object that it returns will not block    the async runtime used in kumomta, whereas the builtin lua functions will    block.</p> </li> <li> <p>The <code>async-file</code> read and write methods are simpler and operate only on    buffers of bytes; you must manually format or parse the buffers that are    passed to it.</p> </li> </ul> <p>The <code>FILENAME</code> parameter is a string containing the path to the file that is to be opened.</p> <p>The <code>OPT_MODE</code> parameter is a string describing how the file should be opened. If it is not specified, it is assumed to have the value <code>\"r\"</code>.  The supported values are:</p> <ul> <li><code>\"r\"</code> or <code>\"rb\"</code>: open the file for read only</li> <li><code>\"w\"</code> or <code>\"wb\"</code>: open the file for write only. The file will be created if    it doesn't already exist</li> <li><code>\"a\"</code> or <code>\"ab\"</code>: open the file for write only, in append mode. The file will    be created if it doesn't already exist.</li> <li><code>\"r+\"</code> or <code>\"r+b\"</code>: open the file for read and write.  The file will be    created if it doesn't already exist. The contents of the file will be    preserved.</li> <li><code>\"w+\"</code> or <code>\"w+b\"</code>: open the file for read and write.  The file will be    created if it doesn't already exist. The contents of the file will be    truncated.</li> <li><code>\"a+\"</code> or <code>\"a+b\"</code>: open the file for read and write.  The file will be    created if it doesn't already exist. The contents of the file will be    preserved.  Writes will only occur at the end of the file.</li> </ul> <p>If the file cannot be opened, an error will be raised.</p> <p>On success, returns an <code>async-file</code> object that supports the methods shown below.</p> <pre><code>local kumo = require 'kumo'\n\nlocal file = kumo.fs.open('/tmp/somefile.txt', 'w')\nfile:write 'hello there'\nfile:seek 'set'\nassert(file:read() == 'hello there')\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/open/#asyncfileclose","title":"asyncfile:close","text":"<pre><code>file:close()\n</code></pre> <p>Closes the file, releasing its resources.  This will happen implicitly when the file object is garbage collected, but it can be hard to determine exactly when that might happen, so it is often good practice to explicitly close it.</p> <p>Explicitly calling <code>file:close</code> implicitly calls <code>file:flush</code>.</p>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/open/#asyncfileflush","title":"asyncfile:flush","text":"<pre><code>file:flush()\n</code></pre> <p>Flushes any buffered data to the file.</p>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/open/#asyncfileread","title":"asyncfile:read","text":"<pre><code>BUFFER = file:read(OPT_SIZE)\n</code></pre> <p>Reads data from the file.  <code>OPT_SIZE</code> is an optional integer specifying how much data to read. If omitted, the remaining size of the file is assumed.</p> <p>When specifying the size, not that the returned buffer can be smaller than the requested size, and that a subsequent read may return additional data.</p> <p>Returns a string (which may be a binary string) holding the returned buffer.</p>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/open/#asyncfilewrite","title":"asyncfile:write","text":"<pre><code>file:write(BUFFER)\n</code></pre> <p>Writes the complete contents of <code>BUFFER</code> to the file. If the write fails for whatever reason, an error is raised.</p>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/open/#asyncfileseek","title":"asyncfile:seek","text":"<pre><code>POS = file:seek(OPT_WHENCE, OPT_POS)\n</code></pre> <p>Changes the current read/write position of the file, returning the new position, implicitly flushing any buffered write if needed.</p> <p><code>OPT_WHENCE</code> describes how the position should change. If omitted, it will be assumed to be <code>\"cur\"</code>. The possible values are:</p> <ul> <li><code>\"cur\"</code> - compute a new position based on the current position</li> <li><code>\"set\"</code> - compute a new position based on the start of the file</li> <li><code>\"end\"</code> - compute a new position based on the end of the file</li> </ul> <p><code>OPT_POS</code> describes where to move to, relative to <code>OPT_WHENCE</code>. If omitted, it will be assumed to be <code>0</code>.  The position must be an integer, which can be negative.</p> <p><code>file:seek()</code> is equivalent to <code>file:seek('cur', 0)</code> which leaves the position alone (adds <code>0</code> to the current position) and returns the current position.</p> <p><code>file:seek('end')</code> moves to the end of the file and returns the size of the file.</p>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/read_dir/","title":"kumo.fs.read_dir","text":"<pre><code>kumo.fs.read_dir(path)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumo, this function is available via the deprecated alias kumo.read_dir</p> <p>This function returns an array containing the absolute file names of the directory specified.  Due to limitations in the lua bindings, all of the paths must be able to be represented as UTF-8 or this function will generate an error.</p> <pre><code>local kumo = require 'kumo'\n\n-- logs the names of all of the entries under `/etc`\nprint(kumo.json_encode_pretty(kumo.fs.read_dir '/etc'))\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo.fs/uncached_glob/","title":"kumo.fs.uncached_glob","text":"<pre><code>kumo.fs.uncached_glob(pattern [, relative_to])\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Warning</p> <p>This function can cause an expensive filesystem walk to occur, especially if used on a storage volume that is experiencing IO pressure (such as from spooling or logging). You probably should use the implicitly cached glob function instead of this one. If you must use this one, then it is strongly advised that you avoid calling it from the file-level scope of your policy scripts in order to avoid unconditionally triggering the walk on every lua context construction.</p> <p>This function evalutes the glob <code>pattern</code> and returns an array containing the absolute file names of the matching results.  Due to limitations in the lua bindings, all of the paths must be able to be represented as UTF-8 or this function will generate an error.</p> <p>The optional <code>relative_to</code> parameter can be used to make the results relative to a path.  If the results have the same prefix as <code>relative_to</code> then it will be removed from the returned path. The default for for this parameter is <code>.</code>.</p> <p>Note</p> <p>If the specified pattern or path references a directory that doesn't exist, or a directory that is inaccessible to the kumo user, no error will be generated; those paths are silently omitted from the results.</p> <pre><code>local kumo = require 'kumo'\n\n-- logs the names of all of the '*.conf' files under `/etc`\nprint(kumo.json_encode_pretty(kumo.fs.uncached_glob '/etc/*.conf'))\n</code></pre>","tags":["utility","filesystem"]},{"location":"reference/kumo.http/","title":"Module <code>kumo.http</code>","text":"<p>This module provides HTTP client functionality.</p>"},{"location":"reference/kumo.http/Request/","title":"The HTTP Request Object","text":"<p>This object is returned from client:get(), client:post() and client:put() and represents a request that has yet to be sent to the remote server.</p> <p>You can use the methods of this object to further configure the request, and then send the request.</p> <p>The following methods are supported:</p>"},{"location":"reference/kumo.http/Request/#requestheadername-value","title":"request:header(name, value)","text":"<p>Sets an HTTP header.  <code>name</code> and <code>value</code> are both strings and correspond to the header name and value respectively.</p> <pre><code>request:header('Content-Type', 'application/json')\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestheadersheaders","title":"request:headers({HEADERS})","text":"<p>Sets multiple HTTP headers. <code>HEADERS</code> is an object-style table holding name/value pairs for the headers and values that should be set.</p> <pre><code>request:headers {\n  ['Content-Type'] = 'application/json',\n  ['X-Something'] = 'value',\n}\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestbasic_authusername-password","title":"request:basic_auth(username [, password])","text":"<p>Configures the username and optional password that should be used to perform HTTP Basic authentication.</p> <p>Consider using a keysource with kumo.secrets.load to retrieve credentials.</p>"},{"location":"reference/kumo.http/Request/#requestbearer_authtoken","title":"request:bearer_auth(token)","text":"<p>Configures the token to be used for HTTP Bearer authentication</p> <p>Consider using a keysource with kumo.secrets.load to retrieve credentials.</p>"},{"location":"reference/kumo.http/Request/#requestbodybody","title":"request:body(body)","text":"<p>Sets the body of the request. Body must be a string.</p> <pre><code>local request = kumo.http.build_client({}):post 'https://example.com'\nrequest:header('Content-Type', 'application/json')\nrequest:body(kumo.json_encode {\n  key = 'value',\n})\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestform_url_encodedparams","title":"request:form_url_encoded({PARAMS})","text":"<p>Sets the body of the request to the provided parameters, using the <code>application/x-www-form-urlencoded</code> encoding scheme. The <code>Content-Type</code> header is implicitly set to <code>application/x-www-form-urlencoded</code>.</p> <p><code>PARAMS</code> is an object-style table whose values must be UTF-8 strings.</p> <pre><code>local request = kumo.http.build_client({}):post 'https://example.com'\nrequest:form_url_encoded {\n  key = 'value',\n  other_key = 'other_value',\n}\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestform_multipart_dataparams","title":"request:form_multipart_data({PARAMS})","text":"<p>Sets the body of the request to the provided parameters, using the <code>multipart/form-data</code> encoding scheme. The <code>Content-Type</code> header is implicitly set to <code>multipart/form-data</code> with the automatically determined boundary field.</p> <p><code>PARAMS</code> is an object-style table whose values should be either UTF-8 strings or lua binary strings.  Binary strings are encoded as <code>application/octet-stream</code> in the generated form data.</p> <pre><code>local request = kumo.http.build_client({}):post 'https://example.com'\nrequest:form_multipart_data {\n  key = 'value',\n  other_key = 'other_value',\n}\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestsend","title":"request:send()","text":"<p>Sends the request and returns Response object representing the result of the request.</p>"},{"location":"reference/kumo.http/Request/#requesttimeoutduration","title":"request:timeout(duration)","text":"<p>Since: Version 2024.06.10-84e84b89</p> <p>The functionality described in this outlined box requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Sets the timeout duration for the request.  If no response is received within the specified duration, the request will raise an error.</p> <p>The default timeout is <code>\"1 minute\"</code>.</p> <p>You may pass a duration string like <code>\"1 minute\"</code>.</p>"},{"location":"reference/kumo.http/Request/#requestaws_sign_v4params","title":"request:aws_sign_v4({PARAMS})","text":"<p>Since: Dev Builds Only</p> <p>The functionality described in this outlined box requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Signs this request using AWS Signature Version 4 (SigV4).</p> <p>This is a convenience wrapper around kumo.crypto.aws_sign_v4 that derives the HTTP method, URI path and query parameters from the <code>Request</code> object, and then applies the resulting <code>Authorization</code> and <code>X-Amz-Date</code> headers back onto the same request.</p> <p><code>PARAMS</code> is a table with the following fields (a subset of the <code>kumo.crypto.aws_sign_v4</code> parameters):</p> <ul> <li><code>access_key</code> (KeySource, required): AWS access key id</li> <li><code>secret_key</code> (KeySource, required): AWS secret access key</li> <li><code>region</code> (string, required): AWS region such as <code>\"us-east-1\"</code></li> <li><code>service</code> (string, required): AWS service name such as <code>\"s3\"</code>, <code>\"sns\"</code>,   <code>\"sqs\"</code>, <code>\"firehose\"</code>, <code>\"lambda\"</code>, <code>\"kinesis\"</code>, and so on.</li> <li><code>headers</code> (table, optional): additional headers to include in the   signature; these are merged with a <code>host</code> header derived from the   request URL if not already present.</li> <li><code>payload</code> (string, optional): request body to use when computing the   payload hash. When present, this should match the body that is sent   with the request.</li> <li><code>timestamp</code> (DateTime, optional): override the signing timestamp; if   omitted, the current time is used.</li> <li><code>session_token</code> (string, optional): session token for temporary   credentials.</li> </ul> <p>The method does not automatically read or clone the request body; if you are sending a body and need it to be part of the signature, pass the same value in the <code>payload</code> field.</p> <pre><code>local http = require 'kumo.http'\n\nlocal client = http.build_client {}\nlocal req = client:post 'https://kinesis.us-east-1.amazonaws.com/'\n\nlocal payload = kumo.serde.json_encode {\n  StreamName = 'my-stream',\n  PartitionKey = 'example-partition',\n  Data = kumo.encode.base64_encode 'Hello from KumoMTA',\n}\n\nreq:header('content-type', 'application/x-amz-json-1.1')\n  :header('x-amz-target', 'Kinesis_20131202.PutRecord')\n  :body(payload)\n  :aws_sign_v4 {\n    access_key = { key_data = os.getenv 'AWS_ACCESS_KEY_ID' },\n    secret_key = { key_data = os.getenv 'AWS_SECRET_ACCESS_KEY' },\n    region = 'us-east-1',\n    service = 'kinesis',\n    payload = payload,\n  }\n\nlocal resp = req:send()\n</code></pre>"},{"location":"reference/kumo.http/Response/","title":"The HTTP Response Object","text":"<p>This object is returned from request:send() and represents the in-progress response.  Status and header information is available to query from the response object ahead of requesting the body in either text or byte format. Once the body has been retrieved, the other methods of the response object can no longer be called.</p> <p>The following methods are supported:</p>"},{"location":"reference/kumo.http/Response/#responsestatus_code","title":"response:status_code()","text":"<p>Returns the numeric HTTP status code indicating the outcome of the request.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_reason","title":"response:status_reason()","text":"<p>Returns the standardized reason-phrase representation of the status code. May return nil if the status code is non-standard or otherwise unknown.</p> <p>The purpose of the reason is for human understanding and logging. You should not use the reason in conditional logic.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_informational","title":"response:status_is_informational()","text":"<p>Returns true if the status code is in the range <code>100</code> - <code>199</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_success","title":"response:status_is_success()","text":"<p>Returns true if the status code is in the range <code>200</code> - <code>299</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_redirection","title":"response:status_is_redirection()","text":"<p>Returns true if the status code is in the range <code>300</code> - <code>399</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_client_error","title":"response:status_is_client_error()","text":"<p>Returns true if the status code is in the range <code>400</code> - <code>499</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_server_error","title":"response:status_is_server_error()","text":"<p>Returns true if the status code is in the range <code>500</code> - <code>599</code>.</p>"},{"location":"reference/kumo.http/Response/#responseheaders","title":"response:headers()","text":"<p>Returns a headermap object that holds the response headers from the request.</p> <p>You can index the headers to look up a specific result:</p> <pre><code>local headers = response:headers()\nprint('x-header value is', headers['x-header'])\n</code></pre> <p>Indexing into the headermap is case-insensitive, so these are both equivalent:</p> <pre><code>local headers = response:headers()\nprint('x-header value is', headers['x-header'])\nprint('x-header value is', headers['X-Header'])\n</code></pre> <p>You can also iterate over the headers:</p> <pre><code>local headers = response:headers()\nfor k, v in pairs(headers) do\n  print('header', k, v)\nend\n</code></pre>"},{"location":"reference/kumo.http/Response/#responsecontent_length","title":"response:content_length()","text":"<p>Returns the length of the response data in bytes, or nil if no <code>Content-Length</code> header was present in the response.</p> <p>Note that this should be the length of the data returned by the <code>response:bytes()</code> method, but because the <code>response:text()</code> method may perform conversion to produce UTF-8, it may not be the same as the length of the textual result.</p>"},{"location":"reference/kumo.http/Response/#responsebytes","title":"response:bytes()","text":"<p>Returns the raw response content as bytes.</p>"},{"location":"reference/kumo.http/Response/#responsetext","title":"response:text()","text":"<p>This method decodes the response body with BOM sniffing and with malformed sequences replaced with the REPLACEMENT CHARACTER. Encoding is determined from the <code>charset</code> parameter of the <code>Content-Type</code> header, and defaults to utf-8 if not presented.</p>"},{"location":"reference/kumo.http/build_client/","title":"kumo.http.build_client","text":"<pre><code>kumo.http.build_client { PARAMS }\n</code></pre> <p>Constructs an HTTP client object.</p> <p>The client maintains state, including a connection pool, that can be used across multiple HTTP requests.</p> <p><code>PARAMS</code> is an object-style table with the following keys:</p> <ul> <li><code>user_agent</code> - optional string that will be used to set the <code>User-Agent</code> header   for all requests made by the client</li> <li><code>connection_verbose</code> - optional boolean. If true, additional diagnostics   around the connection attempt will be logged and can be seen by setting the   diagnostic filter to include <code>reqwest=trace</code>. (Since: Version 2024.06.10-84e84b89)</li> <li><code>pool_idle_timeout</code> - optional duration. Sets the maximum time that an idle   connection remains in the connection pool. The default is <code>90 seconds</code>.   (Since: Version 2024.06.10-84e84b89).</li> <li><code>timeout</code> - optional duration. Sets the default timeout to use for each   request made by the client. Can be overridden using the Request object.   The default is <code>60 seconds</code>. (Since: Version 2024.06.10-84e84b89).</li> </ul> <pre><code>local response = kumo.http.build_client({}):get('https://example.com/'):send()\nprint(response:status_code(), response:status_reason())\nfor k, v in pairs(response:headers()) do\n  print('Header', k, v)\nend\nprint(response:text())\n</code></pre>"},{"location":"reference/kumo.http/build_client/#client-methods","title":"Client Methods","text":"<p>The returned client object has the following methods:</p>"},{"location":"reference/kumo.http/build_client/#clientgeturl","title":"client:get(URL)","text":"<p>Returns a Request object that has been configured to make a GET request to the specified URL.  The URL is a string.</p>"},{"location":"reference/kumo.http/build_client/#clientposturl","title":"client:post(URL)","text":"<p>Returns a Request object that has been configured to make a POST request to the specified URL.  The URL is a string.</p>"},{"location":"reference/kumo.http/build_client/#clientputurl","title":"client:put(URL)","text":"<p>Returns a Request object that has been configured to make a PUT request to the specified URL.  The URL is a string.</p>"},{"location":"reference/kumo.http/build_client/#clientclose","title":"client:close()","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Explicitly destroy the client, closing any connections in its cache.</p>"},{"location":"reference/kumo.http/build_url/","title":"kumo.http.build_url","text":"<pre><code>kumo.http.build_url(base, { PARAMS })\n</code></pre> <p>Given a base URL and a set of parameters, combine the two together and return the result as a string.</p> <p><code>PARAMS</code> is an object-style table consisting of key/value pairs that should be added as GET parameters to the URL:</p> <pre><code>local url = kumo.http.build_url('https://example.com/?existing=value', {\n  a = 1,\n  b = 2,\n})\nassert(url == 'https://example.com/?existing=value&amp;a=1&amp;b=2')\n</code></pre>"},{"location":"reference/kumo.http/connect_websocket/","title":"kumo.http.connect_websocket","text":"<pre><code>kumo.http.connect_websocket(URL)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Constructs a websocket client.</p> <p><code>URL</code> is the URL to which the websocket will connect. It must be either <code>ws://</code> or <code>wss://</code> rather than <code>http://</code> or <code>https://</code>.</p> <p>If the connection is successful, the return value is a tuple of the resulting websocket stream and the initial HTTP response returned from the URL.</p> <pre><code>kumo.on('init', function()\n  kumo.spawn_task {\n    event_name = 'my.websocket.task',\n  }\nend)\n\nkumo.on('my.websocket.task', function()\n  local stream, response = kumo.http.connect_websocket 'wss://example.com/'\n\n  -- Show the initial response; note that there may not be anything\n  -- significant contained in the initial response\n  print(response:status_code(), response:status_reason())\n  for k, v in pairs(response:headers()) do\n    print('Header', k, v)\n  end\n  print(response:text())\n\n  -- Now process data from the connection.\n  -- This is an infinite loop, so you MUST use `kumo.spawn_task`\n  -- to this websocket processor, otherwise you will harm the\n  -- normal operation of the server process.\n  while true do\n    local data = stream:recv()\n    print(kumo.json.parse(data))\n  end\nend)\n</code></pre>"},{"location":"reference/kumo.http/connect_websocket/#websocketstream-methods","title":"WebSocketStream Methods","text":"<p>The returned stream object has the following methods:</p>"},{"location":"reference/kumo.http/connect_websocket/#clientrecv","title":"client:recv()","text":"<p>Waits for and then returns the next packet sent by the server. The returned data is a string.</p>"},{"location":"reference/kumo.http/connect_websocket/#clientrecv_batchduration","title":"client:recv_batch(duration)","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Waits for up to <code>duration</code> (which can either be a number of seconds, or a duration string like <code>10s</code>) and collects however many messages are sent by the peer into a batch, which is returned as an array style table.</p> <p>If the socket disconnects and no messages have been received, an error is raised.</p> <p>Otherwise, the messages received so far will be returned.</p> <p>If no messages are returned within the specified duration, the return value will be an empty table.</p>"},{"location":"reference/kumo.kafka/","title":"Module <code>kumo.kafka</code>","text":"<p>This module provides Apache Kafka client functionality.</p>"},{"location":"reference/kumo.kafka/build_producer/","title":"kumo.kafka.build_producer","text":"<pre><code>kumo.kafka.build_producer(URI)\n</code></pre> <p>Constructs a Kafka client object.</p> <p><code>URI</code> is the URI that references the Kafka cluster to which you want to connect. Bootstrap server addresses should be separated by comma.</p> <pre><code>local producer = kumo.kafka.build_producer {\n  ['bootstrap.servers'] = 'localhost:9092',\n}\n</code></pre>"},{"location":"reference/kumo.kafka/build_producer/#client-methods","title":"Client Methods","text":"<p>The returned client object has the following methods:</p>"},{"location":"reference/kumo.kafka/build_producer/#clientsendparams","title":"client:send({PARAMS})","text":"<p>Sends a message. <code>PARAMS</code> is an object style table with the following keys:</p> <ul> <li><code>topic</code> - required string; the name of the topic to which to send the message</li> <li><code>payload</code> - required string; the message to send</li> <li><code>timeout</code> - how long to wait for a response.</li> </ul> <p>The result from send is a tuple local partition, offset = producer:send {...}.</p> <pre><code>local producer = kumo.kafka.build_producer {\n  ['bootstrap.servers'] = 'localhost:9092',\n}\n\nproducer:send {\n  topic = 'my.topic',\n  payload = message:get_data(),\n  -- how long to keep trying to submit to kafka\n  -- before a lua error will be raised.\n  -- This is the default.\n  timeout = '1 minute',\n}\n</code></pre>"},{"location":"reference/kumo.kafka/build_producer/#clientsend_batchparams","title":"client:send_batch({PARAMS})","text":"Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>Sends a batch of messages. <code>PARAMS</code> is a table of object style table with the following keys:</p> <ul> <li><code>topic</code> - required string; the name of the topic to which to send the message</li> <li><code>payload</code> - required string; the message to send</li> <li><code>timeout</code> - how long to wait for a response.</li> </ul> <p>The result from send_batch is a tuple of tables: local failed_items, errors = producer:send_batch(...).</p> <pre><code>local producer = kumo.kafka.build_producer {\n  ['bootstrap.servers'] = 'localhost:9092',\n}\n\nlocal failed_items, errors = producer:send_batch {\n  {\n    topic = 'my.topic',\n    payload = 'payload 1',\n    timeout = '1 minute',\n  },\n  {\n    topic = 'my.other.topic',\n    payload = 'payload 2',\n    timeout = '1 minute',\n  },\n}\nif #failed_items &gt; 0 then\n  -- some items failed\n  for i, item_idx in ipairs(failed_items) do\n    local error = errors[i]\n    print(string.format('item idx %d failed: %s', item_idx, error))\n  end\nend\n</code></pre>"},{"location":"reference/kumo.kafka/build_producer/#clientclose","title":"client:close()","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Explicitly close the client object and associated connection.</p>"},{"location":"reference/kumo.mimepart/","title":"Module <code>kumo.mimepart</code>","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>This module provides functions for mime parsing.</p>"},{"location":"reference/kumo.mimepart/builder/","title":"builder","text":"<pre><code>kumo.mimepart.builder()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Returns a message builder object that can be used to build an email from an optional text, optional html and optional set of attachments. The builder takes care of phrasing the resulting mime structure in the most commonly accepted arrangement to reflect your combination of text, html and attachments.</p> <p>For example, if you specify both an html and a text part, they will be wrapped up in a <code>multipart/alternative</code> container part.  If you add attachments, then a <code>multipart/mixed</code> container will be created.</p>"},{"location":"reference/kumo.mimepart/builder/#available-methods","title":"Available Methods","text":"<ul> <li><code>builder:text_plain(TEXT)</code> - call this to set the plain text part of the message. The part is constructed as though you called kumo.mimepart.new_text_plain with the same parameters.</li> <li><code>builder:text_html(HTML)</code> - call this to set the HTML part of the message. The part is constructed as though you called kumo.mimepart.new_html with the same parameters.</li> <li><code>builder:attach(CONTENT_TYPE, DATA, ATTACHMENT_OPTIONS)</code> - call this to add an attachment. The part is constructed as though you called kumo.mimepart.new_binary with the same parameters.</li> <li><code>builder:attach_part(PART)</code> - call this to add an attachment part that you have constructed separately</li> <li><code>builder:set_stable_content(true)</code> - provided for testing purposes, when called and set to <code>true</code>, the generated boundaries and other automatically added headers will used fixed strings to aid in making test assertions.</li> <li><code>builder:build()</code> - finalize the message, consuming its internal state, and return the newly constructed MimePart.</li> <li><code>builder:text_amp_html(AMP_HTML)</code> - call this to set the AMP     HTML     part of the message. The part is constructed as though you created a new     text part with the content type <code>text/x-amp-html</code>. (Since: Dev Builds Only).</li> </ul>"},{"location":"reference/kumo.mimepart/builder/#example","title":"Example","text":"<pre><code>-- Build up an email with a couple of attachments/parts\nlocal builder = kumo.mimepart.builder()\nbuilder:text_plain 'Hello, plain'\nbuilder:text_html '&lt;b&gt;Hello, html&lt;/b&gt;'\nbuilder:attach(\n  'text/plain',\n  'I am a plain text file with no options specified'\n)\nbuilder:attach('application/octet-stream', '\\xaa\\xbb', {\n  file_name = 'binary.dat',\n})\nlocal root = builder:build()\nprint(root)\n</code></pre> <p>Will produce a message looking something like this; the <code>boundary</code> strings will vary:</p> <pre><code>Content-Type: multipart/mixed;\n   boundary=\"mm-boundary\"\nMime-Version: 1.0\nDate: Tue, 1 Jul 2003 10:52:37 +0200\n\n--mm-boundary\nContent-Type: multipart/alternative;\n   boundary=\"ma-boundary\"\n\n--ma-boundary\nContent-Type: text/plain;\n   charset=\"us-ascii\"\n\nHello, plain\n--ma-boundary\nContent-Type: text/html;\n   charset=\"us-ascii\"\n\n&lt;b&gt;Hello, html&lt;/b&gt;\n--ma-boundary--\n--mm-boundary\nContent-Type: text/plain\nContent-Transfer-Encoding: base64\n\nSSBhbSBhIHBsYWluIHRleHQgZmlsZSB3aXRoIG5vIG9wdGlvbnMgc3BlY2lmaWVk\n--mm-boundary\nContent-Type: application/octet-stream\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment;\n   filename=\"binary.dat\"\n\nqrs=\n--mm-boundary--\n</code></pre>"},{"location":"reference/kumo.mimepart/new_binary/","title":"new_binary","text":"<pre><code>kumo.mimepart.new_binary(CONTENT_TYPE, CONTENT, OPTIONAL_ATTACHMENT_OPTIONS)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new MimePart for binary content.</p> <p>You must provide the content type and the content itself; the content can be any binary lua string (including strings that are actually UTF-8 text).</p> <p>The MimePart will use appropriate transfer encoding for the binary data.</p> <p>You may optionally specify parameters that will affect how the part will appear when used as an attachment; if you don't care about these, you can omit the third parameter, or pass <code>nil</code>.  If you do want to specify them, then you can pass a lua table that allows for the following fields, which influence the <code>Content-Disposition</code> header in the resulting mime part:</p> <ul> <li><code>file_name</code> - an optional string to use to define the attachment file name.</li> <li><code>inline</code> - an optional boolean that indicates whether the attachment will be marked as being an inline attachment. The default is <code>false</code>.</li> <li><code>content_id</code> - an optional string that can be used to define the     <code>Content-Id</code> header for the mime part, which is useful when generating HTML     content that references an attachment.</li> </ul>"},{"location":"reference/kumo.mimepart/new_binary/#example","title":"Example","text":"<pre><code>local kumo = require 'kumo'\nlocal part =\n  kumo.mimepart.new_binary('application/octet-stream', '\\xbb\\xaa', {\n    file_name = 'binary.dat',\n  })\n</code></pre>"},{"location":"reference/kumo.mimepart/new_html/","title":"new_html","text":"<pre><code>kumo.mimepart.new_html(CONTENT)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new MimePart with <code>Content-Type: text/html</code>.</p> <p>The <code>CONTENT</code> parameter must be a UTF-8 string.</p>"},{"location":"reference/kumo.mimepart/new_html/#example","title":"Example","text":"<pre><code>local kumo = require 'kumo'\nlocal part = kumo.mimepart.new_html '&lt;b&gt;Hello&lt;/b&gt;!'\n</code></pre>"},{"location":"reference/kumo.mimepart/new_multipart/","title":"new_multipart","text":"<pre><code>kumo.mimepart.new_multipart(CONTENT_TYPE, PARTS, OPTIONAL_BOUNDARY)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new multi-part MimePart with the <code>Content-Type</code> header set to <code>CONTENT_TYPE</code>, which is expected to have a <code>multipart/</code> prefix, although any content type for which multipart semantics are expected by consumers is permitted.</p> <p>The <code>PARTS</code> parameter is an array style table containing the set of MimePart objects that will form the children of the newly created part.</p> <p>The <code>OPTIONAL_BOUNDARY</code> parameter is an optional string that can be used to define the MIME boundary for the various parts; you don't normally need to specify this as the default behavior is to generate a UUID to form the boundary string.  You might wish to set the boundary if you are producing tests and need to make assertions on the resulting message content.</p>"},{"location":"reference/kumo.mimepart/new_multipart/#example","title":"Example","text":"<p>This example shows how to produce a simple message with an attachment:</p> <pre><code>local kumo = require 'kumo'\n\nlocal main =\n  kumo.mimepart.new_text_plain 'Hello, I am the main message content'\nlocal attachment =\n  kumo.mimepart.new_binary('application/octet-stream', '\\xbb\\xaa', {\n    file_name = 'binary.dat',\n  })\n\nlocal message =\n  kumo.mimepart.new_multipart('multipart/mixed', { main, attachment })\n\nprint(message)\n</code></pre> <p>That will output a message looking something like this; the boundary will vary each time:</p> <pre><code>Content-Type: multipart/mixed;\n boundary=\"S53NSUR9QJam33WHBKAceA\"\n\n--S53NSUR9QJam33WHBKAceA\nContent-Type: text/plain;\n charset=\"us-ascii\"\n\nHello, I am the main message content\n--S53NSUR9QJam33WHBKAceA\nContent-Type: application/octet-stream\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment;\n filename=\"binary.dat\"\n\nu6o=\n--S53NSUR9QJam33WHBKAceA--\n</code></pre>"},{"location":"reference/kumo.mimepart/new_text/","title":"new_text","text":"<pre><code>kumo.mimepart.new_text(CONTENT_TYPE, CONTENT)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new MimePart with the <code>Content-Type</code> header set to <code>CONTENT_TYPE</code>.</p> <p>The <code>CONTENT</code> parameter must be a UTF-8 string.</p>"},{"location":"reference/kumo.mimepart/new_text/#example","title":"Example","text":"<pre><code>local kumo = require 'kumo'\nlocal part = kumo.mimepart.new_text('text/markdown', 'Some markdown text')\n</code></pre>"},{"location":"reference/kumo.mimepart/new_text_plain/","title":"new_text_plain","text":"<pre><code>kumo.mimepart.new_text_plain(CONTENT)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Constructs a new MimePart with <code>Content-Type: text/plain</code>.</p> <p>The <code>CONTENT</code> parameter must be a UTF-8 string.</p>"},{"location":"reference/kumo.mimepart/new_text_plain/#example","title":"Example","text":"<pre><code>local kumo = require 'kumo'\nlocal part = kumo.mimepart.new_text_plain 'Hello!'\n</code></pre>"},{"location":"reference/kumo.mimepart/parse/","title":"parse","text":"<pre><code>kumo.mimepart.parse 'Subject: hello\\r\\n\\r\\nbody\\r\\n'\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Accepts a single string argument and parses it into MimePart object. The input string is expected to be an RFC 5322 formatted message.</p>"},{"location":"reference/kumo.mpsc/","title":"Module <code>kumo.mpsc</code>","text":"<p>This module provides a Multi-Producer-Single-Consumer queue facility.</p>"},{"location":"reference/kumo.mpsc/define/","title":"define","text":"<pre><code>kumo.mpsc.define(NAME, OPTIONAL_LIMIT)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Defines a new Multi-Producer-Single-Consumer (MPSC) queue, returning a queue object.  An MPSC queue allows multiple producers to submit values to the queue without contention, while allowing only a single consumer to efficiently wait for and pull values back out of the queue.</p> <p>The <code>NAME</code> parameter is a string specifying the name of the queue.</p> <p>The <code>OPTIONAL_LIMIT</code> parameter is an optional non-zero integer value that specifies the optional buffer size associated with the queue.</p> <p>If <code>OPTIONAL_LIMIT</code> is omitted (or is <code>nil</code>), then the queue will be created as an unbounded queue, which will accept new items until memory is exhausted.</p> <p>If a buffer limit is provided, then the queue will be created as a bounded queue which can only hold up to the specified number of items.  Attempting to add items when the queue is full will either cause the submitting code to block, raise an error or return a status code to reflect that the submission cannot proceed, depending on the method used to submit the new value.</p> <p>It is safe to call <code>kumo.mpsc.define</code> multiple times with the same name and varying values of <code>OPTIONAL_LIMIT</code>; the first call to <code>kumo.mpsc.define</code> will actually define the queue and its parameters, while subsequent calls with that name will return that original queue.</p> <p>Note</p> <p>If you need to change the <code>OPTIONAL_LIMIT</code> parameter, the service must be restarted for that change to take effect.</p> <p>Warning</p> <p>MPSC queues are neither durable nor persistent; anything buffered up in the queue will be lost when the service is restarted or terminated.</p> <p>Caution</p> <p>Take care when using unbounded queues as they have no inherent defense against consuming all available memory on the system if the rate of sending exceeds the rate at which the items are being processed.</p> <p>A queue can hold any memoizable value, which is most lua values (excluding coroutines, functions) and a number of bindings to rust data types exposed by kumo's runtime.  Attempting to send incompatible values will result in a runtime error.  It is technically possible to send the <code>nil</code> value to a queue, but the various receiving methods cannot disambiguate <code>nil</code> from the queue being closed, so you should avoid doing that.</p> <pre><code>local function get_queue()\n  return kumo.mpsc.define 'my-example-queue'\nend\n\nkumo.on('init', function()\n  -- Spawn a task that will process items that were sent to the queue.\n  -- It will try to pull items in batches of up to 128 at a time\n  kumo.spawn_task {\n    event_name = 'my.queue.task',\n    args = {},\n  }\nend)\n\nkumo.on('my.queue.task', function(args)\n  -- Get a reference to the unbounded queue we created during `init`\n  local q = get_queue()\n  while true do\n    local batch = q:recv_many(128)\n    print(string.format('got a batch of %d items', #batch))\n    for idx, item in ipairs(batch) do\n      print(string.format('item idx %d: %s', idx, item))\n    end\n  end\nend)\n\n-- Calling this function will submit an item to the queue\nlocal function submit_item(item)\n  local q = get_queue()\n  q:send(item)\nend\n</code></pre>"},{"location":"reference/kumo.mpsc/define/#the-queue-object","title":"The Queue Object","text":"<p>The Queue Object has the following methods</p>"},{"location":"reference/kumo.mpsc/define/#queueclose","title":"queue:close","text":"<pre><code>queue:close()\n</code></pre> <p>Closes a queue, preventing future sends from succeeding.</p>"},{"location":"reference/kumo.mpsc/define/#queueis_closed","title":"queue:is_closed","text":"<pre><code>CLOSED = queue:is_closed()\n</code></pre> <p>Returns <code>true</code> if the queue has been closed, or <code>false</code> otherwise.</p>"},{"location":"reference/kumo.mpsc/define/#queueis_empty","title":"queue:is_empty","text":"<pre><code>EMPTY = queue:is_empty()\n</code></pre> <p>Returns <code>true</code> if the queue is empty, or <code>false</code> otherwise.</p> <p>Caution</p> <p>This method can only be called by the task that is processing the queue. It cannot successfully be called concurrently with an outstanding <code>recv</code>, <code>try_recv</code> or <code>recv_many</code> call because only a single consumer is allowed to operate on an MPSC queue.  This method will raise an error if it is unable to acquire exclusive access to the consumer side of the queue.</p>"},{"location":"reference/kumo.mpsc/define/#queuelen","title":"queue:len","text":"<pre><code>LENGTH = queue:len()\n</code></pre> <p>Returns the number of items in the queue.</p> <p>Caution</p> <p>This method can only be called by the task that is processing the queue. It cannot successfully be called concurrently with an outstanding <code>recv</code>, <code>try_recv</code> or <code>recv_many</code> call because only a single consumer is allowed to operate on an MPSC queue.  This method will raise an error if it is unable to acquire exclusive access to the consumer side of the queue.</p>"},{"location":"reference/kumo.mpsc/define/#queuesend","title":"queue:send","text":"<pre><code>queue:send(VALUE)\n</code></pre> <p>Sends <code>VALUE</code> into the queue. <code>VALUE</code> can be any memoizable value, as described above.</p> <p>For bounded queues, <code>queue:send</code> will wait for there to be room in the queue before returning.  No waiting occurs for unbounded queues, because there is no limit on the capacity of the queue, so there is conceptually always room available.</p> <p>A runtime error will be generated if <code>VALUE</code> is not memoizable, if the queue has been closed, or if some other kind of runtime resource error is encountered.</p> <pre><code>queue:send 'hello'\nqueue:send { 1, 2, 3 }\nqueue:send(true)\n</code></pre>"},{"location":"reference/kumo.mpsc/define/#queuesend_timeout","title":"queue:send_timeout","text":"<pre><code>queue:send_timeout(VALUE, TIMEOUT_SECONDS)\n</code></pre> <p>Sends <code>VALUE</code> into the queue, waiting up to <code>TIMEOUT_SECONDS</code> for there to be room for the item.</p> <p><code>VALUE</code> can be any memoizable value, as described above.</p> <p>For bounded queues, <code>queue:send_timeout</code> will wait up to the specified number of <code>TIMEOUT_SECONDS</code> (which can be fractional) for there to be room in the queue before returning.  If <code>TIMEOUT_SECONDS</code> passes and no room is available, a runtime error is generated.</p> <p>For unbounded queues, <code>TIMEOUT_SECONDS</code> is ignored and this method behaves identically to <code>queue:send</code>.</p> <p>A runtime error will be generated if <code>VALUE</code> is not memoizable, if the queue has been closed, or if some other kind of runtime resource error is encountered.</p> <pre><code>-- Will raise an error if no room is available within 0.5 seconds\nqueue:send_timeout('hello', 0.5)\n</code></pre>"},{"location":"reference/kumo.mpsc/define/#queuetry_send","title":"queue:try_send","text":"<pre><code>SUCCESS = queue:try_send(VALUE)\n</code></pre> <p>Sends <code>VALUE</code> into the queue, if there is room. <code>VALUE</code> can be any memoizable value, as described above.</p> <p>Returns <code>true</code> if the item was submitted to the queue, <code>false</code> otherwise.</p> <p>For bounded queues this method will only succeed if there is room in the queue at the moment <code>queue:try_send</code> is called.</p> <p>A runtime error will be generated if <code>VALUE</code> is not memoizable.</p> <p>This method can return false if the queue has been closed, or if some other kind of runtime resource error is encountered.</p> <pre><code>local ok = queue:try_send(VALUE)\nif not ok then\n  -- queue is full\nend\n</code></pre>"},{"location":"reference/kumo.mpsc/define/#queuerecv","title":"queue:recv","text":"<pre><code>ITEM = queue:recv()\n</code></pre> <p>Receives a value from the queue.  If the queue is empty, this method will sleep indefinitely, until a value is submitted.</p> <p>Returns <code>nil</code> if the queue has been closed.</p> <p>It is recommended that you spawn a task to process values in a loop:</p> <pre><code>local function get_queue()\n  return kumo.mpsc.define 'my-example-queue'\nend\n\nkumo.on('init', function()\n  -- Spawn a task that will process items that were sent to the queue.\n  -- It will try to pull items in batches of up to 128 at a time\n  kumo.spawn_task {\n    event_name = 'my.queue.task',\n    args = {},\n  }\nend)\n\nkumo.on('my.queue.task', function(args)\n  -- Get a reference to the unbounded queue we created during `init`\n  local q = get_queue()\n  while true do\n    local item = q:recv()\n    if item then\n      print('got', item)\n    else\n      break\n    end\n  end\nend)\n</code></pre> <p>Caution</p> <p>This method can only be called by the task that is processing the queue. It cannot successfully be called concurrently with any other outstanding <code>try_recv</code> or <code>recv_many</code> call because only a single consumer is allowed to operate on an MPSC queue.  This method will raise an error if it is unable to acquire exclusive access to the consumer side of the queue.</p>"},{"location":"reference/kumo.mpsc/define/#queuetry_recv","title":"queue:try_recv","text":"<pre><code>ITEM = queue:try_recv()\n</code></pre> <p>Attempts to receive a value from the queue.  If the queue is empty, or has been closed, this method will immediately return <code>nil</code>.</p> <p>Note</p> <p>It is NOT recommended to <code>queue:try_recv</code> in a loop, as that will result in a busy loop that will consume a lot of CPU.</p> <pre><code>local item = q:try_recv()\nif item then\n  print('got', item)\nend\n</code></pre> <p>Caution</p> <p>This method can only be called by the task that is processing the queue. It cannot successfully be called concurrently with any other outstanding <code>recv</code> or <code>recv_many</code> call because only a single consumer is allowed to operate on an MPSC queue.  This method will raise an error if it is unable to acquire exclusive access to the consumer side of the queue.</p>"},{"location":"reference/kumo.mpsc/define/#queuerecv_many","title":"queue:recv_many","text":"<pre><code>BATCH = queue:recv_many(LIMIT)\n</code></pre> <p>Attempts to receive an array of values from the queue.  If the queue is empty, will wait indefinitely for an item to be submitted.  A maximum of <code>LIMIT</code> values will be returned at once; if the queue holds more than <code>LIMIT</code> items, the excess will remain in the queue.  If the queue holds less than <code>LIMIT</code> items, but more than <code>0</code>, then those items will be immediately returned and no waiting will occur.</p> <p>Returns <code>nil</code> if the queue has been closed.</p> <pre><code>local function get_queue()\n  return kumo.mpsc.define 'my-example-queue'\nend\n\nkumo.on('init', function()\n  -- Spawn a task that will process items that were sent to the queue.\n  -- It will try to pull items in batches of up to 128 at a time\n  kumo.spawn_task {\n    event_name = 'my.queue.task',\n    args = {},\n  }\nend)\n\nkumo.on('my.queue.task', function(args)\n  -- Get a reference to the unbounded queue we created during `init`\n  local q = get_queue()\n  while true do\n    local batch = q:recv_many(128)\n    print(string.format('got a batch of %d items', #batch))\n    for idx, item in ipairs(batch) do\n      print(string.format('item idx %d: %s', idx, item))\n    end\n  end\nend)\n\nkumo.on('shutdown_logging', function()\n  local q = get_queue()\n  q:close()\nend)\n</code></pre> <p>Caution</p> <p>This method can only be called by the task that is processing the queue. It cannot successfully be called concurrently with any other outstanding <code>recv</code> or <code>try_recv</code> call because only a single consumer is allowed to operate on an MPSC queue.  This method will raise an error if it is unable to acquire exclusive access to the consumer side of the queue.</p>"},{"location":"reference/kumo.nats/","title":"Module <code>kumo.nats</code>","text":"<p>This module provides NATS client functionality.</p>"},{"location":"reference/kumo.nats/close/","title":"close","text":""},{"location":"reference/kumo.nats/close/#clientclose","title":"client:close()","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Explicitly close the client object and associated connection.</p> <pre><code>client:close()\n</code></pre>"},{"location":"reference/kumo.nats/connect/","title":"kumo.nats.connect","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.nats.connect(CONFIG)\n</code></pre> <p>Connects to a NATS JetStream instance and constructs a client object.</p> <p><code>CONFIG</code> contains at least one address to connect to and the name. Supports password and token authentication. The following Parameters are available:</p> <ul> <li><code>servers</code> - list of addresses</li> <li><code>auth</code> - an optional lua table containing either both <code>username</code> and     <code>password</code>, or a <code>token</code>.  Each of <code>username</code>, <code>password</code> and <code>token</code> are     keysource objects that allow loading the credential from     a supported credential store.</li> <li><code>name</code> - Sets the name for the client.</li> <li><code>no_echo</code> - disables delivering messages that were published from the same connection</li> <li><code>max_reconnects</code> - Specifies the number of consecutive reconnect attempts     the client will make before giving up. This is useful for preventing zombie     services from endlessly reaching the servers, but it can also be a footgun     and surprise for users who do not expect that the client can give up     entirely. Pass 0 for no limit (default).</li> <li><code>connection_timeout</code> - Sets a timeout for the underlying TcpStream     connection to avoid hangs and deadlocks. Default is set to 5 seconds</li> <li><code>tls_required</code> - Sets or disables TLS requirement. If TLS connection is     impossible connection will return error</li> <li><code>tls_first</code> - Changes how tls connection is established. If set, client     will try to establish tls before getting info from the server. That     requires the server to enable <code>handshake_first</code> option in the config</li> <li><code>certificate</code> - Loads root certificates by providing the path to them</li> <li><code>client_cert</code> - Loads client certificate by providing the path to it     (<code>client_key</code> must also be set)</li> <li><code>client_key</code> - Loads client key by providing the path to it (<code>client_cert</code>     must also be set)</li> <li><code>ping_interval</code> - Sets how often Client sends PING message to the server</li> <li><code>sender_capacity</code> - By default, Client dispatches op\u2019s to the Client onto     the channel with capacity of 128. This option enables overriding it</li> <li><code>inbox_prefix</code> - Sets custom prefix instead of default <code>_INBOX</code></li> <li><code>request_timeout</code> - Sets a timeout for requests. Default value is set to 10 seconds</li> <li><code>retry_on_initial_connect</code> - By default, connect will return an error if     the connection to the server cannot be established. Setting     <code>retry_on_initial_connect</code> makes the client establish the connection in the     background</li> <li><code>ignore_discovered_servers</code> - By default, a server may advertise other     servers in the cluster known to it. By setting this option, the client will     ignore the advertised servers. This may be useful if the client may not be     able to reach them</li> <li><code>retain_servers_order</code> - By default, client will pick random server to     which it will try connect to. This option disables that feature, forcing it     to always respect the order in which server addresses were passed</li> </ul>"},{"location":"reference/kumo.nats/connect/#authentication-with-username-and-password","title":"Authentication with username and password","text":"<p>The <code>username</code> and <code>password</code> fields of the <code>auth</code> object are keysource objects.  The example below shows how to hard code a credential, but we recommend taking advantage of the key source's ability to load data from out side of the configuration to avoid checking credentials into your configuration management system:</p> <pre><code>local nats = kumo.nats.connect {\n  servers = { '127.0.0.1:4222' },\n  -- optional arguments for authentication and connection behavior\n  name = 'nats-client',\n  auth = {\n    username = { key_data = 'username' },\n    password = { key_data = 'password' },\n  },\n}\n</code></pre>"},{"location":"reference/kumo.nats/connect/#authentication-with-token","title":"Authentication with token","text":"<p>The <code>token</code> field of the <code>auth</code> object is a keysource object.  The example below shows how to hard code a credential, but we recommend taking advantage of the key source's ability to load data from out side of the configuration to avoid checking credentials into your configuration management system:</p> <pre><code>local nats = kumo.nats.connect {\n  servers = { '127.0.0.1:4222', '127.0.0.1:4422' },\n  -- optional arguments for authentication and connection behavior\n  name = 'nats-client',\n  auth = {\n    token = { key_data = 'token' },\n  },\n}\n</code></pre>"},{"location":"reference/kumo.nats/publish/","title":"publish","text":""},{"location":"reference/kumo.nats/publish/#clientpublishparams","title":"client:publish({PARAMS})","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Sends a message. <code>PARAMS</code> is an object style table with the following keys:</p> <ul> <li><code>subject</code>   - required string; the name of the subject to which to send the message</li> <li><code>payload</code>   - required string; the message to send</li> <li><code>headers</code>   - optional NATS headers</li> <li><code>await_ack</code> - optional wait for server acknowledgement (default: true)</li> </ul> <p>In case <code>await_ack</code> is set to <code>true</code>, <code>publish</code> returns an acknowledgment with the following values:</p> <ul> <li><code>stream</code>: name of stream the message was published to</li> <li><code>sequence</code>: sequence number the message was published in</li> <li><code>domain</code>: domain the message was published to</li> <li><code>deplicate</code>: true if the published message was determined to be a duplicate, false otherwise</li> <li><code>value</code>: used only when published against stream with counters enabled</li> </ul> <pre><code>nats:publish {\n  subject = 'subject',\n  payload = 'payload',\n  headers = {\n    ['Nats-Msg-Id'] = 'unique-id',\n  },\n  await_ack = true,\n}\n</code></pre>"},{"location":"reference/kumo.regex_set_map/","title":"Module <code>kumo.regex_set_map</code>","text":"<p>This module provides functions that help with making regex -&gt; value maps.</p>"},{"location":"reference/kumo.regex_set_map/new/","title":"kumo.regex_set_map.new","text":"<pre><code>kumo.regex_set_map.new([{MAP}])\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Create a new regex set map from a set of key/value pairs.</p> <p>A regex set can efficiently match a haystack string against a list of multiple regular expressions in a single search operation.  The search operation on the regex set knows which regular expression matched, and that is used here to map to a more meaningful value.</p> <p>Since the regex set needs to be compiled, the set is considered to be immutable; it cannot have entries added after it has been created, so you need to build up a lua table with the mapping to pass to <code>new</code>.</p> <pre><code>-- This example categorizes text into either 'hello', 'bye' results\nlocal map = kumo.regex_set_map.new {\n  hello = 'hello',\n  bye = 'bye',\n  later = 'bye',\n  -- more complex patterns need to quote the map key:\n  ['Good day'] = 'hello',\n}\n\nassert(map['hello there'] == 'hello')\nassert(map['goodbye'] == 'bye')\nassert(map['see you later'] == 'bye')\nassert(map['not.set'] == nil)\n</code></pre>"},{"location":"reference/kumo.secrets/","title":"Module <code>kumo.secrets</code>","text":"<p>This module provides functions that are useful when working with secrets and credentials.</p>"},{"location":"reference/kumo.secrets/load/","title":"kumo.secrets.load","text":"<pre><code>kumo.secrets.load(SOURCE)\n</code></pre> <p>Given a keysource, load and return the bytes stored in that source.</p>"},{"location":"reference/kumo.secrets/load/#example-of-loading-a-credential-from-a-vault","title":"Example of Loading a credential from a vault","text":"<pre><code>local request = kumo.http.build_client({}):get 'https://example.com/'\n\nlocal passwd = kumo.secrets.load {\n  vault_mount = 'secret',\n  vault_path = 'example.com-passwd',\n  -- Optional: specify a custom key name (defaults to \"key\")\n  -- vault_key = \"password\"\n}\nrequest:basic_auth('username', passwd)\n\nlocal response = request:send()\n</code></pre>"},{"location":"reference/kumo.serde/","title":"Module <code>kumo.serde</code>","text":"<p>This module provides functions for serializing and deserializing data from various formats, such as json, toml and yaml.</p>"},{"location":"reference/kumo.serde/json_encode/","title":"kumo.serde.json_encode","text":"<pre><code>kumo.serde.json_encode(VALUE)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.json_encode</code>.</p> <p>Attempts to encode VALUE as its JSON equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.serde.json_parse.</p> <p>See also kumo.serde.json_load, kumo.serde.json_parse and kumo.serde.json_encode_pretty</p>"},{"location":"reference/kumo.serde/json_encode_pretty/","title":"kumo.serde.json_encode_pretty","text":"<pre><code>kumo.serde.json_encode_pretty(VALUE)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.json_encode_pretty</code>.</p> <p>Attempts to encode VALUE as its JSON equivalent, and returns that value serialized as a string, using pretty, more human readable representation.</p> <p>This is logically the opposite of kumo.serde.json_parse.</p> <p>See also kumo.serde.json_load, kumo.serde.json_parse and kumo.serde.json_encode</p>"},{"location":"reference/kumo.serde/json_load/","title":"kumo.serde.json_load","text":"<pre><code>kumo.serde.json_load(FILENAME)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.json_load</code>.</p> <p>Reads the content of the file name <code>FILENAME</code> and parses it as JSON, returning a lua representation of the parsed JSON.</p> <p>This json loading implementation will accept C style block comments, C++ style single line comments and shell style single line comments.  Comments will be treated as though they were spaces prior to being parsed by the underlying json parser.</p> <p>See also kumo.serde.json_parse, kumo.serde.json_encode and kumo.serde.json_encode_pretty</p>"},{"location":"reference/kumo.serde/json_parse/","title":"kumo.serde.json_parse","text":"<pre><code>kumo.serde.json_parse(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.json_parse</code>.</p> <p>Parses STRING as JSON, returning a lua representation of the parsed JSON.</p> <p>This json parsing implementation will accept C style block comments, C++ style single line comments and shell style single line comments.  Comments will be treated as though they were spaces prior to being parsed by the underlying json parser.</p> <p>This is logically the opposite of kumo.serde.json_encode.</p> <p>See also kumo.serde.json_load, kumo.serde.json_encode and kumo.serde.json_encode_pretty</p>"},{"location":"reference/kumo.serde/toml_encode/","title":"kumo.serde.toml_encode","text":"<pre><code>kumo.serde.toml_encode(VALUE)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.toml_encode</code>.</p> <p>Attempts to encode VALUE as its TOML equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.serde.toml_parse.</p> <p>See also kumo.serde.toml_load, kumo.serde.toml_parse and kumo.serde.toml_encode_pretty</p>"},{"location":"reference/kumo.serde/toml_encode_pretty/","title":"kumo.serde.toml_encode_pretty","text":"<pre><code>kumo.serde.toml_encode_pretty(VALUE)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.toml_encode_pretty</code>.</p> <p>Attempts to encode VALUE as its TOML equivalent, and returns that value serialized as a string, using pretty, more human readable representation.</p> <p>This is logically the opposite of kumo.serde.toml_parse.</p> <p>See also kumo.serde.toml_load, kumo.serde.toml_parse and kumo.serde.toml_encode</p>"},{"location":"reference/kumo.serde/toml_load/","title":"kumo.serde.toml_load","text":"<pre><code>kumo.serde.toml_load(FILENAME)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.toml_load</code>.</p> <p>Reads the content of the file name <code>FILENAME</code> and parses it as TOML, returning a lua representation of the parsed TOML.</p> <p>See also kumo.serde.toml_parse, kumo.serde.toml_encode and kumo.serde.toml_encode_pretty</p>"},{"location":"reference/kumo.serde/toml_parse/","title":"kumo.serde.toml_parse","text":"<pre><code>kumo.serde.toml_parse(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Note</p> <p>In earlier versions of kumomta, this function was available as <code>kumo.toml_parse</code>.</p> <p>Parses STRING as TOML, returning a lua representation of the parsed TOML.</p> <p>This is logically the opposite of kumo.serde.toml_encode.</p> <p>See also kumo.serde.toml_load, kumo.serde.toml_encode and kumo.serde.toml_encode_pretty</p>"},{"location":"reference/kumo.serde/yaml_encode/","title":"kumo.serde.yaml_encode","text":"<pre><code>kumo.serde.yaml_encode(VALUE)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Attempts to encode VALUE as its YAML equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.serde.yaml_parse.</p> <p>See also kumo.serde.yaml_load and kumo.serde.yaml_parse.</p>"},{"location":"reference/kumo.serde/yaml_load/","title":"kumo.serde.yaml_load","text":"<pre><code>kumo.serde.yaml_load(FILENAME)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Reads the content of the file name <code>FILENAME</code> and parses it as YAML, returning a lua representation of the parsed YAML.</p> <p>See also kumo.serde.yaml_parse and kumo.serde.yaml_encode</p>"},{"location":"reference/kumo.serde/yaml_parse/","title":"kumo.serde.yaml_parse","text":"<pre><code>kumo.serde.yaml_parse(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Parses STRING as YAML, returning a lua representation of the parsed YAML.</p> <p>This is logically the opposite of kumo.serde.yaml_encode.</p> <p>See also kumo.serde.yaml_load and kumo.serde.yaml_encode</p>"},{"location":"reference/kumo.shaping/","title":"Module <code>kumo.shaping</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This module provides functions to configure the KumoMTA Traffic Shaping Automation daemon.</p> <p>This module is only present in the <code>tsa-daemon</code> process; attempting to reference it elsewhere will fail.</p>"},{"location":"reference/kumo.shaping/load/","title":"kumo.shaping.load","text":"<pre><code>kumo.shaping.load({ PATHS }, { OPTIONS })\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This function will load traffic shaping data from the list of filenames or HTTP/HTTPS URLs that is passed to it.</p> <p>For example, in the <code>tsa-daemon</code> configuration, you might use it like this:</p> <pre><code>kumo.on('tsa_load_shaping_data', function()\n  local shaping = cached_load_shaping_data {\n    -- This is the default file used by the shaping helper\n    -- in KumoMTA, which references the community shaping rules\n    '/opt/kumomta/share/policy-extras/shaping.toml',\n\n    -- and maybe you have your own rules\n    '/opt/kumomta/policy/shaping.toml',\n  }\n  return shaping\nend)\n</code></pre>"},{"location":"reference/kumo.shaping/load/#options-parameter","title":"Options Parameter","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>The options parameter allows for the following fields:</p> <ul> <li> <p><code>aliased_site</code> - specifies the severity of aliases between domain blocks.   Domains that resolve to the same site name are likely undesirable as they   can lead to logical conflicts in the resulting configuration.   The default value for this is <code>\"Ignore\"</code>, but you can specify <code>\"Warn\"</code> or   <code>\"Error\"</code>.</p> </li> <li> <p><code>dns_fail</code> - specifies the severity of DNS resolution failures for a domain   block.   The default value for this is <code>\"Ignore\"</code>, but you can specify <code>\"Warn\"</code> or   <code>\"Error\"</code>.</p> </li> <li> <p><code>local_load</code> - specifies the severity of a failure to load a local shaping   file.   The default value for this is <code>\"Error\"</code>, but you can specify <code>\"Warn\"</code> or   <code>\"Ignore\"</code>.</p> </li> <li> <p><code>null_mx</code> - how to treat a domain block when the DNS indicates that it   is a NULL MX that doesn't receive mail.   The default value for this is <code>\"Ignore\"</code>, but you can specify <code>\"Warn\"</code> or   <code>\"Error\"</code>.</p> </li> <li> <p><code>provider_overlap</code> - how to treat overlap between domain blocks and provider   blocks. These are likely undesirable as they can lead to logical conflicts   in the resulting configuration.   The default value for this is <code>\"Ignore\"</code>, but you can specify <code>\"Warn\"</code> or   <code>\"Error\"</code>.</p> </li> <li> <p><code>remote_load</code> - specifies the severity of a failure to load a remote   shaping file.   The default value for this is <code>\"Ignore\"</code>, but you can specify <code>\"Warn\"</code> or   <code>\"Error\"</code>.</p> </li> <li> <p><code>skip_remote</code> - a boolean to indicate whether to skip loading remote shaping   files.  The default is <code>false</code>, and the shaper will load remote shaping files.</p> </li> <li> <p><code>http_timeout</code> - an optional duration string specifying the timeout to   use for http requests made to fetch shaping data.  The default value if   unspecified is <code>5s</code>. (Since: Version 2025.03.19-1d3f1f67)</p> </li> </ul>"},{"location":"reference/kumo.shaping/load/#shaping-data-format","title":"Shaping Data Format","text":"<p>If a given path ends with <code>.toml</code>, it will be interpreted as TOML. Otherwise, it will be interpreted as JSON.</p> <p>This documentation uses TOML as it is a bit more friendly for humans to read and write.</p> <p>Shaping data is considered as an ordered series of shaping configuration files, where successive files layer and merge over earlier files.</p>"},{"location":"reference/kumo.shaping/load/#domains-and-merging","title":"Domains and Merging","text":"<p>Each file contains information keyed by the destination domain name.</p> <p>The values in a domain section must be valid values for kumo.make_egress_path, with a couple of special additional values indicated below.</p> <p>The special domain name <code>\"default\"</code> is used to define common, shared values, used as the basis for every domain.</p> <p>In this example, <code>connection_limit</code> and <code>enable_tls</code> are set for every domain. However, when sending to <code>gmail.com</code>, its <code>connection_limit</code> of <code>100</code> will override the <code>10</code> from the <code>default</code> section, and it will also use the <code>enable_tls</code> value from the default section; the values are merged together:</p> TOMLJSON <pre><code>[\"default\"]\nconnection_limit = 10\nenable_tls = \"Opportunistic\"\n\n[\"gmail.com\"]\nconnection_limit = 100\n</code></pre> <pre><code>{\n  \"default\": {\n    \"connection_limit\": 10,\n    \"enable_tls\": \"Opportunistic\"\n  },\n  \"gmail.com\": {\n    \"connection_limit\": 100\n  }\n}\n</code></pre> <p>Specifying the same domain in separate files will also merge the configuration, which allows us to share community-provided base rules that you can then choose to override without replacing everything for that domain.</p> <p>However, if you want to completely replace the information for a domain, you can indicate that by using <code>replace_base = true</code>:</p> TOMLJSON <pre><code>[\"gmail.com\"]\n# Discard any other `gmail.com` rules provided by earlier files\nreplace_base = true\nconnection_limit = 10\n</code></pre> <pre><code>{\n  \"gmail.com\": {\n    // Discard any other `gmail.com` rules provided by earlier files\n    \"replace_base\": true,\n    \"connection_limit\": 10\n  }\n}\n</code></pre> <p><code>replace_base</code> is only meaningful in the context of the current domain section in the current file; subsequent sections for that same domain will continue to merge in as normal, unless they also use <code>replace_base</code>.</p>"},{"location":"reference/kumo.shaping/load/#mx-rollup","title":"MX Rollup","text":"<p>By default, the shaping rules associated with a domain are applied to the site_name that is constructed from the list of MX hosts in DNS for that domain.  That allows the rules to apply to every domain that uses a shared set of MXs, for example, every G-Suite hosted domain will share <code>gmail.com</code> rules.</p> <p>For some domains this may not be desirable; in this situations you can prevent the rule from using the site_name by setting <code>mx_rollup = false</code>:</p> TOMLJSON <pre><code>[\"example.com\"]\nmx_rollup = false\n</code></pre> <pre><code>{\n  \"example.com\": {\n    \"mx_rollup\": false\n  }\n}\n</code></pre>"},{"location":"reference/kumo.shaping/load/#per-source-rules","title":"Per-Source Rules","text":"<p>You can provide a list of source-specific rules like this:</p> TOMLJSON <pre><code>[\"example.com\".sources.\"my source name\"]\nconnection_limit = 5\n</code></pre> <pre><code>{\n  \"example.com\": {\n    \"sources\": {\n      \"my source name\": {\n        \"connection_limit\": 5\n      }\n    }\n  }\n}\n</code></pre> <p>The section is named in the format <code>DOMAIN.sources.SOURCE</code>.  Both the <code>DOMAIN</code> and the <code>SOURCE</code> must be quoted using double-quotes in order for the structure to be correct.</p>"},{"location":"reference/kumo.shaping/load/#traffic-shaping-automation-rules","title":"Traffic Shaping Automation Rules","text":"<p>The shaping data can include automation rules that will be evaluated by the optional <code>tsa-daemon</code> process.</p> <p>Here's an example that defines policy for <code>yahoo.com</code>:</p> TOMLJSON <pre><code>[\"yahoo.com\"]\nmax_deliveries_per_connection = 20\n\n[[\"yahoo.com\".automation]]\nregex = \"\\\\[TS04\\\\]\"\naction = \"Suspend\"\nduration = \"2 hours\"\n</code></pre> <pre><code>{\n  \"yahoo.com\": {\n    \"max_deliveries_per_connection\": 20,\n    \"automation\": [\n      {\n        \"regex\": \"\\\\[TS04\\\\]\",\n        \"action\": \"Suspend\",\n        \"duration\": \"2 hours\"\n      }\n    ]\n  }\n}\n</code></pre> <p>In TOML, the <code>[[DOMAIN.automation]]</code> syntax appends an additional entry to the list of <code>automation</code> rules in <code>DOMAIN</code>.</p> <p>This particular rule uses a regex to look for <code>[TS04]</code> in the delivery status responses from yahoo, and when it matches, the action taken is to suspend delivery to yahoo.com from the triggering source.  Other sources will be handled independently.</p> <p>The following fields are possible in an automation rule:</p> <ul> <li><code>regex</code> - required string, the regular expression used to match the rule.    Supported Regex Syntax is documented here</li> <li><code>action</code> - required action to take.  Can be one of:<ul> <li><code>\"Suspend\"</code> - Suspend delivery</li> <li><code>{SetConfig{name=\"NAME\", value=\"VALUE\"}}</code> - define a configuration override that sets <code>NAME=VALUE</code>.</li> <li><code>{SetDomainConfig{name=\"NAME\", value=\"VALUE\"}}</code> - define a configuration   override that sets <code>NAME=VALUE</code>, but with <code>mx_rollup=false</code>, even if the   rule was defined inside a domain where <code>mx_rollup=true</code>. (Since: Version 2024.11.08-d383b033)</li> </ul> </li> <li><code>trigger</code> - optional. Can be one of:<ul> <li><code>\"Immediate\"</code> - this is the default. The action is taken each time a <code>regex</code> matches.</li> <li><code>{Threshold=\"10/hr\"}</code> - defines a threshold; the action won't trigger in this case until 10 events have occurred in the preceding hour.</li> </ul> </li> <li><code>duration</code> - required string specifying the duration of the effects of the action.</li> <li><code>match_internal</code> - optional boolean indicating whether internally generated    response, that is, those that begin with the text <code>KumoMTA internal:</code>,    should be allowed to match the rule. The default is <code>false</code>. Prior to the    introduction of this option the behavior was equivalent to it being set to    <code>true</code>. Unintentionally matching internal responses with a suspension rule    could trigger surprising cyclical behavior where a suspension is triggered    from a remote response and then subsequently the transient failures logged    when messages hit that suspension would also match the rule and continue    to apply and extend the lifetime of the suspension. (Since: Version 2024.11.08-d383b033)</li> </ul> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>The following new actions are now supported:</p> <ul> <li><code>\"SuspendTenant\"</code> - Generate a suspension for all scheduled queues that have    both the tenant and the destination domain of the triggering record. If no    tenant was assigned, this action has no effect.</li> <li><code>\"SuspendCampaign\"</code> - Generate a suspension for all scheduled queues that    have both the tenant, campaign and the destination domain of the    triggering record.  If no tenant was assigned, this action has no effect.    If no campaign was assigned, behave as though <code>\"SuspendTenant\"</code> was the    action.</li> </ul> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>The following new actions are now supported:</p> <ul> <li><code>\"Bounce\"</code> - Generate a bounce for all scheduled queues that have the    same destination domain as the triggered record.</li> <li><code>\"BounceTenant\"</code> - Generate a bounce for all scheduled queues that have    both the same destination domain and tenant as the triggering record.    If no tenant was assigned, this action has no effect.</li> <li><code>\"BounceCampaign\"</code> - Generate a bounce for all scheduled queues that have    both the same destination domain, tenant AND campaign as the triggering    record.  If no campaign was assigned, behave as though <code>\"BounceTenant\"</code> was    the action.</li> </ul>"},{"location":"reference/kumo.spf/","title":"Module <code>kumo.spf</code>","text":"<p>This module provides functions that are useful when working with the Sender Policy Framework.</p>"},{"location":"reference/kumo.spf/check_host/","title":"kumo.spf.check_host","text":"<pre><code>kumo.spf.check_host { PARAMS }\n</code></pre> Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>This function will check SPF records from DNS for the given domain and IP address.</p> <p>It takes three arguments:</p> <ul> <li><code>domain</code> (<code>string</code>), the domain to check (for example, from the <code>smtp_server_ehlo</code> event)</li> <li><code>conn_meta</code> (<code>connectionmeta</code>), used to get the client's IP address</li> <li><code>sender</code> (optional <code>string</code>), the sender address to check</li> </ul> <p>It will return an object containing the SPF <code>disposition</code> string and a <code>result</code> of type <code>authenticationresult</code> for use with <code>msg:add_authentication_results()</code>.</p> <p>The <code>OPT_RESOLVER_NAME</code> parameter (Since: Version 2025.12.02-67ee9e96) is an optional string parameter that specifies the name of a alternate resolver defined via kumo.dns.define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/kumo.spf/check_host/#example-checking-the-spf-policy","title":"Example: checking the SPF policy","text":"<pre><code>kumo.on('smtp_server_ehlo', function(domain, conn_meta)\n  -- Check the SPF policy for the domain and return the results.\n  local result = kumo.spf.check_host(domain, conn_meta)\n  print('spf', kumo.json_encode_pretty(result))\n  if result.disposition ~= 'pass' then\n    kumo.reject(420, 'go away')\n  end\nend)\n</code></pre> <p>might print something like this to the diagnostic log:</p> <pre><code>spf    [\n  \"disposition\": \"pass\",\n  {\n    \"result\": \"pass\",\n    \"method\": \"spf\",\n    \"reason\": \"matched 'all' directive\",\n    \"method_version\": null,\n    \"props\": {}\n  }\n]\n</code></pre>"},{"location":"reference/kumo.spf/check_host/#see-also","title":"See Also:","text":"<ul> <li>msg:add_authentication_results()</li> </ul>"},{"location":"reference/kumo.spf/check_msg/","title":"kumo.spf.check_msg","text":"<pre><code>kumo.spf.check_msg(MESSAGE, OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This function will check SPF records from DNS for the provided message. It will extract the appropriate domain and sender information from the metadata and message.</p> <p>It will return an object containing the SPF <code>disposition</code> string and a <code>result</code> of type <code>authenticationresult</code> for use with <code>msg:add_authentication_results()</code>.</p> <p>The <code>OPT_RESOLVER_NAME</code> parameter is an optional string parameter that specifies the name of a alternate resolver defined via kumo.dns.define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/kumo.spf/check_msg/#example-checking-the-spf-policy","title":"Example: checking the SPF policy","text":"<pre><code>kumo.on('smtp_server_message_received', function(msg, conn_meta)\n  -- Check the SPF policy for the domain and return the results.\n  local result = kumo.spf.check_msg(msg)\n  print('spf', kumo.json_encode_pretty(result))\n  if result.disposition ~= 'pass' then\n    kumo.reject(420, 'go away')\n  end\nend)\n</code></pre> <p>might print something like this to the diagnostic log:</p> <pre><code>spf    [\n  \"disposition\": \"pass\",\n  {\n    \"result\": \"pass\",\n    \"method\": \"spf\",\n    \"reason\": \"matched 'all' directive\",\n    \"method_version\": null,\n    \"props\": {\n        \"smtp.mailfrom\": \"sender@example.com\"\n    }\n  }\n]\n</code></pre>"},{"location":"reference/kumo.spf/check_msg/#see-also","title":"See Also:","text":"<ul> <li>msg:add_authentication_results()</li> </ul>"},{"location":"reference/kumo.time/","title":"<code>require 'kumo.time'</code>","text":"<p>The time  module provides access to a number of functions for working with time or timer functionality.</p>"},{"location":"reference/kumo.time/Time/","title":"Time Object Type","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The <code>Time</code> object type represents a date and time. It internally stores the time as UTC, even if it was produced by parsing time from some other time zone.</p> <p>You do not create a <code>Time</code> object directly, but instead using one of the constructing functions:</p> <ul> <li>kumo.time.from_unix_timestamp</li> <li>kumo.time.now</li> <li>kumo.time.parse_rfc2822</li> <li>kumo.time.parse_rfc3339</li> <li>kumo.time.with_ymd_hms</li> </ul> <p>or though metamethods of <code>Time</code> (see below).</p>"},{"location":"reference/kumo.time/Time/#metamethods","title":"Metamethods","text":"<p>The following metamethods are implemented on <code>Time</code> objects:</p> <ul> <li><code>tostring(some_time)</code> - returns a human readable representation of the time like <code>1970-01-01 00:00:01 UTC</code>.</li> <li><code>time1 == time2</code> - compares two <code>Time</code> objects for equality</li> <li><code>some_time + time_delta</code> - addition. You may add a TimeDelta to a <code>Time</code> to produce a new    <code>Time</code> offset by the added delta.</li> <li><code>-</code> - subtraction:<ul> <li><code>time1 - time_delta</code> - You may subtract a TimeDelta from   a <code>Time</code> to produce a new <code>Time</code> offset by the added delta.</li> <li><code>time1 - time2</code> - You may subtract a <code>Time</code> from a <code>Time</code> to produce a   TimeDelta representing the difference between the two   times</li> </ul> </li> </ul>"},{"location":"reference/kumo.time/Time/#fields","title":"Fields","text":"<p>The following fields expose various properties of the underlying <code>Time</code> object. Fields are accessed using dot notation, like <code>time.rfc2822</code>.</p> <ul> <li><code>year</code> - the year number portion of the ISO 8601 calendar date.</li> <li><code>month</code> - the month number of the calendar date, starting with <code>1</code> for January.</li> <li><code>day</code> - the day of the month of the calendar date, starting from <code>1</code>.</li> <li><code>hour</code> - the hour number, from <code>0</code> to <code>23</code>.</li> <li><code>minute</code> - the minute number, from <code>0</code> to <code>59</code>.</li> <li><code>second</code> - the second number, from <code>0</code> to <code>59</code>.</li> <li><code>unix_timestamp</code> - the number of non-leap seconds since January 1, 1970    0:00:00 UTC (aka \"UNIX timestamp\").</li> <li><code>unix_timestamp_millis</code> - the number of non-leap milliseconds since January    1, 1970 0:00:00 UTC.</li> <li><code>rfc2822</code> - the time formatted according to RFC 2822</li> <li><code>rfc3339</code> - the time formatted according to RFC 3339</li> <li><code>elapsed</code> - the TimeDelta corresponding to the difference    between this <code>Time</code> object and the time at which the <code>elapsed</code> field is    evaluated.</li> </ul> <pre><code>local now = kumo.time.now()\nprint(now.year)\nprint(now.unix_timestamp)\n</code></pre>"},{"location":"reference/kumo.time/Time/#methods","title":"Methods","text":"<p>The following methods are implemented on <code>Time</code> objects. Methods are accessed using colon notation, like <code>time:format()</code>.</p>"},{"location":"reference/kumo.time/Time/#timeformat","title":"Time:format","text":"<pre><code>local now = kumo.time.now()\nlocal string = now:format '%H:%M:%S'\n</code></pre> <p>Formats the time object using the strftime syntax supported by the Rust chrono crate.</p> <p>Parsing of the format string is lenient, but it is still possible that for invalid format strings to raise errors.</p>"},{"location":"reference/kumo.time/TimeDelta/","title":"TimeDelta Object Type","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The <code>TimeDelta</code> object type represents a time interval.</p> <p>You do not create a <code>TimeDelta</code> object directly, but instead using one of the constructing functions:</p> <ul> <li>kumo.time.parse_duration</li> </ul> <p>or though metamethods of <code>TimeDelta</code> (see below) or Time.</p>"},{"location":"reference/kumo.time/TimeDelta/#metamethods","title":"Metamethods","text":"<p>The following metamethod are implemented on <code>TimeDelta</code> objects:</p> <ul> <li><code>tostring(time_delta)</code> - returns a human readable duration string, the same as the <code>human</code> field described below</li> <li><code>delta1 == delta2</code> - compares two <code>TimeDelta</code> objects for equality</li> <li><code>delta1 + delta2</code> - you may add a <code>TimeDelta</code> to a <code>TimeDelta</code> to produce a new <code>TimeDelta</code></li> <li><code>delta1 - delta2</code> - you may subtract a <code>TimeDelta</code> from a <code>TimeDelta</code> to produce a new <code>TimeDelta</code></li> </ul>"},{"location":"reference/kumo.time/TimeDelta/#fields","title":"Fields","text":"<p>The following fields epose information about the underlying <code>TimeDelta</code>. Fields are accessed using dot notation, like <code>delta.seconds</code>.</p> <ul> <li><code>seconds</code> - returns the TimeDelta expressed as a signed number of seconds (including fractional seconds)</li> <li><code>nanoseconds</code> - returns the TimeDelta expressed as a signed integer number of nanoseconds.</li> <li><code>milliseconds</code> - returns the TimeDelta expressed as a signed integer number of milliseconds.</li> <li><code>microseconds</code> - returns the TimeDelta expressed as a signed integer number of microseconds.</li> <li><code>human</code> - returns the TimeDelta expressed as a human readable string, such    as <code>5m</code> for a five minute duration.</li> </ul> <pre><code>local delta1 = kumo.time.parse_duration(20)\nlocal delta2 = kumo.time.parse_duration '10 seconds'\n\nassert((delta2 - delta1).seconds == 10)\n</code></pre>"},{"location":"reference/kumo.time/from_unix_timestamp/","title":"kumo.time.from_unix_timestamp","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local time = kumo.time.from_unix_timestamp(UNIX_TIMESTAMP)\n</code></pre> <p>Constructs a new Time object representing the specified unix timestamp.</p> <p>The timestamp can be either an integer number of seconds, or a fractional number of seconds since the unix epoch.</p>"},{"location":"reference/kumo.time/now/","title":"kumo.time.now","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local time = kumo.time.now()\n</code></pre> <p>Constructs a new Time object representing the current time.</p>"},{"location":"reference/kumo.time/parse_duration/","title":"kumo.time.parse_duration","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local time = kumo.time.parse_duration(DURATION)\n</code></pre> <p>Parses a duration to create a TimeDelta object.</p> <p><code>DURATION</code> can be:</p> <ul> <li>A signed integer number of seconds</li> <li>A signed floating point number of seconds</li> <li>A duration string like <code>5 minutes</code></li> </ul>"},{"location":"reference/kumo.time/parse_duration/#example","title":"Example","text":"<pre><code>local delta = kumo.time.parse_duration '5m'\n</code></pre>"},{"location":"reference/kumo.time/parse_rfc2822/","title":"kumo.time.parse_rfc2822","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local time = kumo.time.parse_rfc2822(TIMESTAMP)\n</code></pre> <p>Parses a timestamp in RFC 2822 format, and returns a Time object.</p>"},{"location":"reference/kumo.time/parse_rfc2822/#example","title":"Example","text":"<pre><code>local t = kumo.time.parse_rfc2822 'Sun, 2 Jan 2000 03:04:05 +0000'\n</code></pre>"},{"location":"reference/kumo.time/parse_rfc3339/","title":"kumo.time.parse_rfc3339","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local time = kumo.time.parse_rfc3339(TIMESTAMP)\n</code></pre> <p>Parses a timestamp in RFC 3339 format, and returns a Time object.</p>"},{"location":"reference/kumo.time/parse_rfc3339/#example","title":"Example","text":"<pre><code>local t = kumo.time.parse_rfc3339 '2000-01-02T03:04:05+00:00'\n</code></pre>"},{"location":"reference/kumo.time/sleep/","title":"kumo.time.sleep","text":"<pre><code>kumo.time.sleep(SECONDS)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>Sleeps the current task for the specified number of seconds. The value can be either an integer or a floating point value, the latter can be used to specify fractional duration values.</p>"},{"location":"reference/kumo.time/start_timer/","title":"kumo.time.start_timer","text":"<pre><code>kumo.time.start_timer(LABEL)\n</code></pre> Since: Version 2025.01.23-7273d2bc <p>The functionality described in this section requires version 2025.01.23-7273d2bc of KumoMTA, or a more recent version.</p> <p>Starts a timer with a specific label and returns a timer object.</p> <p>The timer object can be used to update a latency histogram that is reported in the prometheus metrics for the server to track how long it takes for a certain operation to complete.</p> <p>See user_lua_latency for information about the exported histogram.</p> <p>The most basic usage looks like this:</p> <pre><code>local timer = kumo.time.start_timer 'my-operation'\n\n-- do something here\nkumo.time.sleep(1.5)\n\n-- And record the latency\ntimer:done()\n</code></pre> <p>After this runs, you will see the following metrics:</p> <pre><code>$ curl -s 'http://127.0.0.1:8000/metrics' | grep user_lua\n# HELP user_lua_latency how long something user-defined took to run in your lua policy\n# TYPE user_lua_latency histogram\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.005\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.01\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.025\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.05\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.1\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.25\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"0.5\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"1\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"2.5\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"5\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"10\"} 1\nuser_lua_latency_bucket{label=\"my-operation\",le=\"+Inf\"} 1\nuser_lua_latency_sum{label=\"my-operation\"} 1.5\nuser_lua_latency_count{label=\"my-operation\"} 1\n</code></pre> <p>You can use the <code>&lt;close&gt;</code> feature of lua to automatically trigger the <code>:done()</code> call when the timer object falls out of scope.  This is useful for example to track how long it takes to run a function:</p> <pre><code>local function mything()\n  -- This `timer` will automatically report the duration of the `mything`\n  -- function when it returns, so you don't need to litter the function\n  -- with timer:done() calls for each return case below\n  local timer &lt;close&gt; = kumo.time.start_timer(\"mything\")\n\n  if something then\n    return\n  end\n\n  if something_else then\n    return\n  end\n\nend\n</code></pre> <p>The <code>timer:done()</code> method returns the number of seconds that have elapsed since the timer was started.</p>"},{"location":"reference/kumo.time/with_ymd_hms/","title":"kumo.time.with_ymd_hms","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local time = kumo.time.with_ymd_hms(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)\n</code></pre> <p>Constructs a new Time object representing the UTC date and time specified.</p>"},{"location":"reference/kumo.time/with_ymd_hms/#example","title":"Example","text":"<pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\nlocal t = kumo.time.with_ymd_hms(2000, 01, 02, 03, 04, 05)\nutils.assert_eq(tostring(t), '2000-01-02 03:04:05 UTC')\nutils.assert_eq(t.year, 2000)\nutils.assert_eq(t.month, 1)\nutils.assert_eq(t.day, 2)\nutils.assert_eq(t.hour, 3)\nutils.assert_eq(t.minute, 4)\nutils.assert_eq(t.second, 5)\nutils.assert_eq(t.unix_timestamp, 946782245)\nutils.assert_eq(t.rfc2822, 'Sun, 2 Jan 2000 03:04:05 +0000')\nutils.assert_eq(t.rfc3339, '2000-01-02T03:04:05+00:00')\n</code></pre>"},{"location":"reference/kumo.uuid/","title":"Module <code>kumo.uuid</code>","text":"<p>This module provides functions for parsing and generating UUIDs.</p>"},{"location":"reference/kumo.uuid/#the-uuid-object","title":"The UUID Object","text":"<p>The functions in this module return a <code>Uuid</code> object.</p> <p>Printing or otherwise explicitly converting a <code>Uuid</code> object as a string will produce the the hyphenated form of the uuid.</p> <p>The following fields are available to return the bytes encoded in various ways.</p> <ul> <li><code>bytes</code> - returns the data as a binary byte string. This is the most compact representation, but is difficult to pass into other systems without encoding in some way. Case sensitive. See also kumo.encode.</li> <li><code>hyphenated</code> - returns the data encoded as lowercase hexadecimal with the elements of the UUID separated by hyphens. Case insensitive. Example: <code>69994630-3e27-11ef-91fc-cc28aa0a5c5a</code></li> <li><code>simple</code> - returns the data encoded as lowercase hexadecimal with no separating hyphens. Case insensitive. Example: <code>699946303e2711ef91fccc28aa0a5c5a</code>.</li> <li><code>braced</code> - returns the data encoded as lowercase hexadecimal with the elements of the UUID separated by hyphens, all enclosed in curly braces. Case insensitive. Example: <code>{69994630-3e27-11ef-91fc-cc28aa0a5c5a}</code></li> <li><code>urn</code> - returns the data formatted as an URN. Example: <code>urn:uuid:69994630-3e27-11ef-91fc-cc28aa0a5c5a</code>.</li> </ul> <pre><code>local u = kumo.uuid.parse '69994630-3e27-11ef-91fc-cc28aa0a5c5a'\nassert(tostring(u) == '69994630-3e27-11ef-91fc-cc28aa0a5c5a')\nassert(u.hyphenated == '69994630-3e27-11ef-91fc-cc28aa0a5c5a')\nassert(u.simple == '699946303e2711ef91fccc28aa0a5c5a')\nassert(u.braced == '{69994630-3e27-11ef-91fc-cc28aa0a5c5a}')\nassert(u.urn == 'urn:uuid:69994630-3e27-11ef-91fc-cc28aa0a5c5a')\nassert(\n  u.bytes\n    == '\\x69\\x99\\x46\\x30\\x3e\\x27\\x11\\xef\\x91\\xfc\\xcc\\x28\\xaa\\x0a\\x5c\\x5a'\n)\n\n-- You may also combine the bytes representation with the encodings\n-- provided in the kumo.encode module for an even more compact non-binary\n-- representation of the uuid\nassert(\n  kumo.encode.base64url_nopad_encode(u.bytes) == 'aZlGMD4nEe-R_MwoqgpcWg'\n)\n</code></pre>"},{"location":"reference/kumo.uuid/new_v1/","title":"kumo.uuid.new_v1","text":"<pre><code>kumo.uuid.new_v1()\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Create a new version 1 UUID with the current timestamp and the current node ID.</p> <p>The node ID is taken from the MAC address of the first non-loopback interface on the system. If there are no candidate interfaces, fall back to the <code>gethostid()</code> function, which, on most Linux systems, will attempt to load a host id from a file on the filesystem, or if that fails, resolve the hostname of the node to its IPv4 address using a reverse DNS lookup, and then derive some 32-bit number from that address through unspecified means.</p> <p>See The UUID Object for more information about the returned UUID object.</p>"},{"location":"reference/kumo.uuid/new_v4/","title":"kumo.uuid.new_v4","text":"<pre><code>kumo.uuid.new_v4()\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Create a new version 4 UUID from random bits.</p> <p>See The UUID Object for more information about the returned UUID object.</p>"},{"location":"reference/kumo.uuid/new_v6/","title":"kumo.uuid.new_v6()","text":"<pre><code>kumo.uuid.new_v6()\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Create a new version 6 UUID with the current timestamp and the current node ID.</p> <p>This is similar to version 1 UUIDs, except that it is lexicographically sortable by timestamp.</p> <p>The node ID is taken from the MAC address of the first non-loopback interface on the system. If there are no candidate interfaces, fall back to the <code>gethostid()</code> function, which, on most Linux systems, will attempt to load a host id from a file on the filesystem, or if that fails, resolve the hostname of the node to its IPv4 address using a reverse DNS lookup, and then derive some 32-bit number from that address through unspecified means.</p> <p>See The UUID Object for more information about the returned UUID object.</p>"},{"location":"reference/kumo.uuid/new_v7/","title":"kumo.uuid.new_v7","text":"<pre><code>kumo.uuid.new_v7()\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Create a new version 7 UUID using the current time and random bytes.</p> <p>See The UUID Object for more information about the returned UUID object.</p>"},{"location":"reference/kumo.uuid/parse/","title":"kumo.uuid.parse","text":"<pre><code>kumo.uuid.parse(UUID)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Parses a UUID from a string and into a UUID object.</p> <pre><code>local u = kumo.uuid.parse '{69994630-3e27-11ef-91fc-cc28aa0a5c5a}'\nassert(u.hyphenated == '69994630-3e27-11ef-91fc-cc28aa0a5c5a')\n</code></pre> <p>See The UUID Object for more information about the returned UUID object.</p>"},{"location":"reference/kumo.xfer/","title":"kumo.xfer","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>The <code>kumo.xfer</code> module provides functions relating to inter-node message transfer.</p>","tags":["xfer"]},{"location":"reference/kumo.xfer/cancel_xfer/","title":"kumo.xfer.cancel_xfer","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.xfer.cancel_xfer(msg, opt_reason)\n</code></pre> <p>Cancels any xfer routing that might be applied to <code>msg</code> (which must be a Message object).</p> <p>If the message is not configured to xfer then this function will not make any changes to the message.</p> <p>If <code>opt_reason</code> is specified, it will be used as the reason string in an <code>AdminRebind</code> log record to capture any queue change that might occur due to calling this function.</p> <p>If <code>opt_reason</code> is not specified (omitted, or is explicitly set to <code>nil</code>), then no <code>AdminRebind</code> log entry will be produced.</p>","tags":["xfer"]},{"location":"reference/kumo.xfer/get_xfer_target/","title":"kumo.xfer.get_xfer_target","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>local proto = kumo.xfer.get_xfer_target(msg)\n</code></pre> <p>Returns the XferProtocol destination URL for the message, if any.</p> <p>The <code>msg</code> parameter is a Message object. If the message is not destined for another kumomta node via the xfer protocol, then this function will return <code>nil</code>.</p>","tags":["xfer"]},{"location":"reference/kumo.xfer/xfer/","title":"kumo.xfer.xfer","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.xfer.xfer(msg, target_url, opt_reason)\n</code></pre> <p>Adjusts the queue parameters on <code>msg</code> (which must be a Message object) such that it will be transferred to the kumomta node identified by the <code>target_url</code> parameter.</p> <p>The <code>target_url</code> is the URL prefix of the HTTP Listener for the destination kumomta node, including any port number, but excluding any path or query components.  For example <code>http://10.0.0.2:8000</code> is how a valid prefix might appear, but it need not be using an IP address, any valid URL prefix of that form is acceptable, provided that it is running a compatible version of KumoMTA.</p> <p>If <code>opt_reason</code> is specified, it will be used as the reason string in an <code>AdminRebind</code> log record to capture any queue change that might occur due to calling this function.</p> <p>If <code>opt_reason</code> is not specified (omitted, or is explicitly set to <code>nil</code>), then no <code>AdminRebind</code> log entry will be produced.</p> <p>If the message is already configured to xfer to <code>target_url</code> then no changes will be made to the message, and no log record will be logged by this particular call.</p> <p>If the message is configured to xfer to a different target, then that xfer will be cancelled and then the message will be configured to xfer to <code>target_url</code>.</p> <p>Note</p> <p>This function does not alter any of the scheduling parameters on the message.  It is NOT intended to be used as part of retry processing.  You should look at kumo.xfer.xfer_in_requeue for a function that does handle that situation.</p>","tags":["xfer"]},{"location":"reference/kumo.xfer/xfer_in_requeue/","title":"kumo.xfer.xfer_in_requeue","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>kumo.xfer.xfer_in_requeue(\n  msg,\n  target_url,\n  insert_context,\n  increment_attempts,\n  delay,\n  opt_reason\n)\n</code></pre> <p>Caution</p> <p>This function is intended to be called from within the requeue_message event only.  Calling it from other contexts may result in non-deterministic and unreliable behavior.</p> <p>Adjusts the queue parameters on <code>msg</code> (which must be a Message object) such that it will be transferred to the kumomta node identified by the <code>target_url</code> parameter.</p> <p>The <code>target_url</code> is the URL prefix of the HTTP Listener for the destination kumomta node, including any port number, but excluding any path or query components.  For example <code>http://10.0.0.2:8000</code> is how a valid prefix might appear, but it need not be using an IP address, any valid URL prefix of that form is acceptable, provided that it is running a compatible version of KumoMTA.</p> <p>The <code>increment_attempts</code>, <code>insert_context</code> and <code>delay</code> parameters MUST all be passed through from the parameters with the same names in the requeue_message event handler.  They will be used to decide how to update the scheduling on the message prior to encapsulating that state into the XFER message framing used to communicate with the target node.</p> <p>If <code>opt_reason</code> is specified, it will be used as the reason string in an <code>AdminRebind</code> log record to capture any queue change that might occur due to calling this function.</p> <p>If <code>opt_reason</code> is not specified (omitted, or is explicitly set to <code>nil</code>), then no <code>AdminRebind</code> log entry will be produced.</p> <p>If the message is already configured to xfer to <code>target_url</code> then no changes will be made to the message, and no log record will be logged by this particular call.</p> <p>If the message is configured to xfer to a different target, then that xfer will be cancelled and then the message will be configured to xfer to <code>target_url</code>.  However, if the message was pending xfer to the alternate target for a significant amount of time, then the revised schedule computed for the message may be inaccurate.</p>","tags":["xfer"]},{"location":"reference/kumo.xfer/xfer_in_requeue/#example-move-message-to-backup-tier-if-underliverable-after-two-attempts","title":"Example: move message to backup tier if underliverable after two attempts","text":"<pre><code>local BACKUP_HOST = 'http://backup-kumomta:8000'\n\nkumo.on(\n  'requeue_message',\n  function(msg, smtp_response, insert_context, increment_attempts, delay)\n    if msg:num_attempts() &gt;= 2 then\n      -- Re-route to alternative infra to manage the rest of the send\n      kumo.xfer.xfer_in_requeue(\n        msg,\n        BACKUP_HOST,\n        insert_context,\n        increment_attempts,\n        delay,\n        'reroute to backup infra'\n      )\n    end\n  end\n)\n</code></pre>","tags":["xfer"]},{"location":"reference/message/","title":"Message","text":"<p>A message object represents a message that is either in the process of being received, is queued, is in the process of being delivered, or has just been delivered.</p> <p>Messages are created by the system and are then passed to your policy script via various events when the system needs your input into acting on the message.</p> <p>See Also:</p> <ul> <li>kumo.make_message</li> <li>kumo.inject_message</li> </ul>","tags":["message"]},{"location":"reference/message/add_authentication_results/","title":"add_authentication_results","text":"<pre><code>message:add_authentication_results(server_id, results)\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This method will prepend an <code>Authentication-Results</code> header to the message, as specified by RFC 8601.</p> <p>The parameters are:</p> <ul> <li><code>server_id</code> - the authserv-id.  It is suggested to use     <code>msg:get_meta('hostname')</code> to obtain the hostname that was configured in     the corresponding SMTP listener.</li> <li><code>results</code> - an array of authenticationresult     objects holding the results of various authentication methods.</li> </ul>"},{"location":"reference/message/add_authentication_results/#example-obtaining-dkim-authentication-results","title":"Example: obtaining DKIM authentication results","text":"<pre><code>kumo.on('smtp_server_message_received', function(msg, conn_meta)\n  -- Verify the dkim signature and return the results.\n  -- Note that this example isn't making any policy decisions;\n  -- it is only annotating the message with the results and\n  -- allowing it to be relayed\n  local auth_results = msg:dkim_verify()\n\n  local spf_result = kumo.spf.check_host(\n    msg:sender().domain,\n    conn_meta,\n    tostring(msg:sender())\n  )\n\n  -- add the spf authentication result to our collection of results\n  table.insert(auth_results, spf_result.result)\n\n  -- Add the results to the message\n  msg:add_authentication_results(msg:get_meta 'hostname', auth_results)\nend)\n</code></pre> <p>might produce an <code>Authentication-Results</code> header like this:</p> <pre><code>Authentication-Results: hostname.example.com;\n        dkim=pass\n        header.a=rsa-sha256\n        header.b=jo0EO4dX\n        header.d=github.com\n        header.i=@github.com\n        header.s=pf2023\n        spf=pass\n</code></pre>"},{"location":"reference/message/add_authentication_results/#see-also","title":"See Also:","text":"<ul> <li>msg:dkim_verify()</li> </ul>"},{"location":"reference/message/append_header/","title":"append_header","text":"<pre><code>message:append_header(NAME, VALUE)\n</code></pre> <p>Constructs a header from <code>NAME: VALUE</code> and appends it to the header portion of the message.</p> <p>The <code>VALUE</code> is taken as-is and used as the header value.</p> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This method now accepts an additional optional <code>ENCODE</code> parameter, which should be a boolean value:</p> <pre><code>message:append_header(NAME, VALUE, ENCODE)\n</code></pre> <p>When <code>ENCODE</code> is set to true then the <code>VALUE</code> will be encoded:</p> <ul> <li>If the header value is ascii then it will be soft wrapped at whitespace   around 75 columns, and hard-wrapped regardless of whitespace at 900 columns.</li> <li>If the header value is non-ascii then it will be quoted printable encoded   using RFC 2047 header encoding.</li> </ul>"},{"location":"reference/message/append_text_html/","title":"append_text_html","text":"<pre><code>message:append_text_html(content)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Identifies the primary <code>text/html</code> part of the message, decodes its transfer encoding, and locates the closing <code>\"&lt;/body&gt;\"</code> or <code>\"&lt;/BODY&gt;\"</code> tag. If the tag is found, <code>content</code> is inserted ahead of it. If no body tag is found, appends the <code>content</code> string to the part. The part is then re-transfer-encoded and the message data is updated.</p> <p>This is useful for example to add a tracking pixel into the message:</p> <pre><code>umo.on('smtp_server_message_received', function(msg)\n  local my_tracking_link =\n    '&lt;img src=\"http://10.0.0.1/img_tracker.jpg\" alt=\"open tracking pixel\"&gt;'\n  msg:append_text_html(my_tracking_link)\nend)\n</code></pre> <ul> <li>See also:</li> <li>msg:set_data()</li> <li>msg:append_text_plain()</li> </ul>"},{"location":"reference/message/append_text_plain/","title":"append_text_plain","text":"<pre><code>message:append_text_plain(content)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Identifies the primary <code>text/plain</code> part of the message, decodes its transfer encoding, and appends the <code>content</code> string to it. The part is then re-transfer-encoded and the message data is updated.</p> <ul> <li>See also:</li> <li>msg:set_data()</li> <li>msg:append_text_html()</li> </ul>"},{"location":"reference/message/arc_seal/","title":"arc_seal","text":"<pre><code>message:arc_seal(signer, server_id, authentication_results, opt_resolver_name)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This method will sign and seal an ARC set to record the current hop as part of the Authenticated Received Chain.</p> <p>The parameters are:</p> <ul> <li><code>signer</code> - a signer object created through either    kumo.dkim.rsa_sha256_signer or    kumo.dkim.ed25519_signer.</li> <li><code>server_id</code> - the hostname to use in the <code>ARC-Authentication-Results</code> header    that is generated as part of the sealing process.</li> <li><code>authentication_results</code> - an array style table holding the set of authentication    results that should be signed as part of the ARC seal.</li> <li><code>opt_resolver_name</code> parameter is an optional string parameter that specifies    the name of a alternate resolver defined via    kumo.dns.define_resolver.  You can omit    this parameter and the default resolver will be used.</li> </ul> <p>Sealing will implicity verify the ARC chain in the message; if that verification indicates that the chain of custody has been broken, then the seal operation will return without modifying the message.</p> <p>Note</p> <p>Sealing the message MUST occur after all header and body modification, otherwise those operations risk invalidating the signatures.</p>"},{"location":"reference/message/arc_seal/#example","title":"Example","text":"<pre><code>kumo.on('smtp_server_message_received', function(msg, conn_meta)\n  -- Collect together various authentication results.\n  -- dkim verification returns a possibly empty list\n  local results = msg:dkim_verify()\n  local arc = msg:arc_verify()\n  -- add the arc result to the list we got from dkim\n  table.insert(results, arc)\n  local spf = kumo.spf.check_msg(msg)\n  -- add the spf result to the list we got from dkim\n  table.insert(results, spf.result)\n\n  local server_id = msg:get_meta 'hostname'\n\n  -- Add a regular Authentication-Results header for the\n  -- sake of consistency with ARC\n  msg:add_authentication_results(server_id, results)\n\n  -- Set up a signer; this is just an example that loads\n  -- a key from a file on disk.\n  local signer = kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.pem',\n  }\n\n  -- Emits an ARC-Authentication-Results header,\n  -- computes an ARC-Message-Signature header based on the settings\n  -- in the signer, and then computes a final ARC-Seal header\n  -- to seal the ARC chain of custody. Those 3 headers are\n  -- added to the message.\n  msg:arc_seal(signer, server_id, results)\nend)\n</code></pre>"},{"location":"reference/message/arc_verify/","title":"arc_verify","text":"<pre><code>local result = message:arc_verify(OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This method will verify the Authenticated Received Chain in the message, returning an AuthenticationResult object indicating the status of the verification.</p> <p>The <code>result</code> field in the returned authentication result can have one of the following values, as specified by RFC8617:</p> <ul> <li><code>none</code> - no ARC sets were present in the message</li> <li><code>pass</code> - all ARC sets validated, the chain of custody is intact</li> <li><code>fail</code> - something prevented validating the chain of custody. The <code>reason</code>    field will offer a (potentially partial) explanation.</li> </ul> <p>There are a number of checks associated with validating the ARC chain of custody, some of which will compound and cause subsequent checks to fail. Interally the ARC validator tracks all of these but will only expose the first such failure in the <code>reason</code> field of the <code>AuthenticationResult</code> object for the sake of brevity.</p> <p>The <code>OPT_RESOLVER_NAME</code> parameter is an optional string parameter that specifies the name of a alternate resolver defined via kumo.dns.define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/message/arc_verify/#example-obtaining-the-status","title":"Example: obtaining the status","text":"<pre><code>kumo.on('smtp_server_data', function(msg, conn_meta)\n  local arc = msg:arc_verify()\n  kumo.log_info('ARC result', kumo.serde.json_encode_pretty(arc))\n  if arc.result == 'fail' then\n    -- Please note that this is technically a \"BAD\" example, as\n    -- RFC8617 says: a message with an Authenticated Received Chain\n    -- with a Chain Validation Status of \"fail\" MUST be treated the\n    -- same as a message with no Authenticated Received Chain\n    kumo.reject(\n      550,\n      '5.7.29 ARC Validation failure: ' .. tostring(arc.reason)\n    )\n  end\nend)\n</code></pre>"},{"location":"reference/message/check_fix_conformance/","title":"check_fix_conformance","text":"<pre><code>message:check_fix_conformance(CHECKS, FIXES, OPT_SETTINGS)\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Warning</p> <p>Fixing messages with this method is inherently imperfect: it is based on a deliberately relaxed interpretation of the message content and it is possible, or even likely, that non-conforming input is parsed in a way that results in omitting certain details from the original input.</p> <p>The purpose of this method is as a best-effort convenience for correcting minor and obviously recognizable issues that cannot easily be resolved at the message generation stage.</p> <p>It is recommended that you carefully evaluate the effects of this method before deploying it in production.</p> <p>This method serves two related functions:</p> <ul> <li>To check RFC conformance issues for which you wish to reject the message.</li> <li>To correct RFC conformance issues in case you wish to accept the message.</li> </ul> <p>It accepts two parameters that encode the set of conformance issues that are applicable. The conformance set is represented as a string listing the issues separated by a <code>|</code> character:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  local failed = msg:check_fix_conformance(\n    -- check for and reject messages with these issues:\n    'MISSING_COLON_VALUE',\n    -- fix messages with these issues:\n    'LINE_TOO_LONG|NAME_ENDS_WITH_SPACE|NEEDS_TRANSFER_ENCODING|NON_CANONICAL_LINE_ENDINGS|MISSING_DATE_HEADER|MISSING_MESSAGE_ID_HEADER|MISSING_MIME_VERSION'\n  )\n  if failed then\n    kumo.reject(552, string.format('5.6.0 %s', failed))\n  end\nend)\n</code></pre> <p>The set of supported conformance issues is:</p> Label Meaning MISSING_COLON_VALUE A header was listed with only its name, and without any value. eg: <code>\"Subject\"</code> instead of <code>\"Subject: the subject\"</code> NON_CANONICAL_LINE_ENDINGS The message contained line endings that were not in the canonical <code>CRLF</code> form required by SMTP NAME_ENDS_WITH_SPACE A header name ended with space instead of a colon. eg: <code>\"Subject :\"</code> instead of <code>\"Subject: \"</code>. While that is valid for HTTP, it is invalid for email. LINE_TOO_LONG The line length for the body portion exceeds the MIME message wrapping width that is intended to keep message text wrapping within 80 columns. NEEDS_TRANSFER_ENCODING The parsed content includes 8-bit content and thus needs to have transfer encoding applied in order to safely transit the 7-bit SMTP network MISSING_DATE_HEADER The <code>\"Date:\"</code> header is not present MISSING_MESSAGE_ID_HEADER The <code>\"Message-ID:\"</code> header is not present MISSING_MIME_VERSION The <code>\"Mime-Version:\"</code> header is either not present or is set to some other value than <code>\"1.0\"</code> <p>The way this method works is that it will attempt to parse the data associated with the message into a MIME tree. The parsing stage will accumulate the set of conformance issues it uncovers as it parses the tree.</p> <p>Then the <code>CHECKS</code> parameter is decoded into the set of issues for which an error needs to be generated. If there is an intersection between <code>CHECKS</code> and the discovered conformance issues, then an error message is generated, listing the problematic issues. Here's an example:</p> <pre><code>Message has conformance issues: LINE_TOO_LONG\n</code></pre> <p>That message is returned from the method as a string so that you can then choose to issue an appropriate error response. For example:</p> <pre><code>local failed = msg:check_fix_conformance(checks, fixes)\nif failed then\n  -- Rejects with an error like:\n  -- `552 5.6.0 Message has conformance issues: LINE_TOO_LONG`\n  kumo.reject(552, string.format('5.6.0 %s', failed))\nend\n</code></pre> <p>If after processing the <code>CHECKS</code> parameter an error was not returned, the <code>FIXES</code> parameter is consulted; if there is an intersection between <code>FIXES</code> and the discovered conformance issues, then the message will be \"fixed\".</p> <p>The strategy for fixing is simple:</p> <ul> <li>If any of the problems are not due to missing headers:<ul> <li>The message will be rebuilt from the parsed tree. This will cause headers and   parts to be re-encoded to follow the best practices coded into the built-in   mime message builder.</li> </ul> </li> <li>Missing headers will be synthesized and added to the rebuilt message</li> <li>The resulting message will then be re-encoded as a byte stream and assigned   as the data that will be saved when the message is ready to be spooled.</li> </ul> <p>Note</p> <p>Since fixing issues other than missing headers essentially rewrites the message, the chances are very high that any digital signature in the original message will be invalidated.</p>"},{"location":"reference/message/check_fix_conformance/#fixing-8-bit-content","title":"Fixing 8-bit content","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The default behavior when fixing <code>NEEDS_TRANSFER_ENCODING</code> is to perform a lossy conversion to UTF-8, replacing any non-UTF-8 bytes with unicode replacement characters.</p> <p>\"Fixing\" 8-bit content in this context is difficult, because there are many 8-bit encodings and it is not always possible to decide what encoding is associated with a piece of data--that is why MIME defines explicit transfer encoding and header encoding indicators in its various RFCs.</p> <p>KumoMTA includes a character set encoding detector function that can be used to make a guess at the encoding.  You can enable it by passing in an optional settings parameter.</p> <p>Here's an example:</p> <pre><code>msg:check_fix_conformance('', 'NEEDS_TRANSFER_ENCODING', {\n  -- Enable the encoding detector\n  detect_encoding = true,\n  -- Constrain the set of allowed encodings to just latin-1.\n  -- You can omit the include_encodings option and the full\n  -- set of encodings will be considered\n  include_encodings = {\n    'iso-8859-1',\n  },\n  -- You can optionally exclude encodings\n  exclude_encodings = {},\n})\n</code></pre> <p>Since there is some ambiguity in charset detection, it is recommended that you employ some heuristics to select the include/exclude list.  For example, if you know that the sender is from a chinese locale, then you might select <code>big5</code> and not include any latin charsets.</p> <p>It is not recommended to attempt fixing up the charset of 8-bit content if you are unsure of the sender.</p> <p>The set of encodings supported by the detector are:</p> <ul> <li>iso-8859-2</li> <li>iso-8859-3</li> <li>iso-8859-4</li> <li>iso-8859-5</li> <li>iso-8859-6</li> <li>iso-8859-7</li> <li>iso-8859-8</li> <li>iso-8859-10</li> <li>iso-8859-13</li> <li>iso-8859-14</li> <li>iso-8859-15</li> <li>iso-8859-16</li> <li>koi8-r</li> <li>koi8-u</li> <li>macintosh</li> <li>windows-874</li> <li>windows-1250</li> <li>windows-1251</li> <li>windows-1252 (which is a superset of iso-8859-1)</li> <li>windows-1253</li> <li>windows-1254</li> <li>windows-1255</li> <li>windows-1256</li> <li>windows-1257</li> <li>windows-1258</li> <li>x-mac-cyrillic</li> <li>gbk</li> <li>gb18030</li> <li>big5</li> <li>euc-jp</li> <li>euc-kr</li> <li>iso-2022-jp</li> <li>shift_jis</li> <li>utf-16be</li> <li>utf-16le</li> <li>utf-8</li> </ul>"},{"location":"reference/message/dkim_sign/","title":"dkim_sign","text":"<pre><code>message:dkim_sign(SIGNER)\n</code></pre> <p>Computes the DKIM signature for the message using the provided SIGNER and prepends it to the message.</p> <p>See also kumo.dkim.rsa_sha256_signer</p>"},{"location":"reference/message/dkim_verify/","title":"dkim_verify","text":"<pre><code>message:dkim_verify(OPT_RESOLVER_NAME)\n</code></pre> Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This method will verify each DKIM signature that is present at the top level of the message, up to a limit of 10 signatures.  The limit is in place to limit the scope of a DoS attack being carried out through maliciously constructed messages.</p> <p>For each signature, an authenticationresult object will be constructed and an array of those results will be returned to the caller.</p> <p>The <code>OPT_RESOLVER_NAME</code> parameter (Since: Version 2025.12.02-67ee9e96) is an optional string parameter that specifies the name of a alternate resolver defined via kumo.dns.define_resolver.  You can omit this parameter and the default resolver will be used.</p>"},{"location":"reference/message/dkim_verify/#example-obtaining-dkim-authentication-results","title":"Example: obtaining DKIM authentication results","text":"<pre><code>kumo.on('smtp_server_message_received', function(msg)\n  -- Verify the dkim signature and return the results.\n  -- Note that this example isn't making any policy decisions;\n  -- it is only annotating the message with the results and\n  -- allowing it to be relayed\n  local verify = msg:dkim_verify()\n  print('dkim', kumo.json_encode_pretty(verify))\n  -- Add the results to the message\n  msg:add_authentication_results(msg:get_meta 'hostname', verify)\nend)\n</code></pre> <p>might print something like this to the diagnostic log:</p> <pre><code>dkim    [\n  {\n    \"props\": {\n      \"header.d\": \"github.com\",\n      \"header.i\": \"@github.com\",\n      \"header.s\": \"pf2023\",\n      \"header.a\": \"rsa-sha256\",\n      \"header.b\": \"jo0EO4dX\"\n    },\n    \"result\": \"pass\",\n    \"method\": \"dkim\",\n    \"reason\": null,\n    \"method_version\": null\n  }\n]\n</code></pre> <p>and produce an <code>Authentication-Results</code> header:</p> <pre><code>Authentication-Results: hostname.example.com;\n        dkim=pass\n        header.a=rsa-sha256\n        header.b=jo0EO4dX\n        header.d=github.com\n        header.i=@github.com\n        header.s=pf2023\n</code></pre>"},{"location":"reference/message/dkim_verify/#see-also","title":"See Also:","text":"<ul> <li>msg:add_authentication_results()</li> </ul>"},{"location":"reference/message/from_header/","title":"from_header","text":"<pre><code>message:from_header()\n</code></pre> <p>Gets the <code>\"From\"</code> header, parses it as a list of mailboxes and groups, and returns an addressheader object.</p> <p>Returns <code>nil</code> if no matching header could be found.</p> <p>See also message:get_address_header and message:to_header.</p>"},{"location":"reference/message/get_address_header/","title":"get_address_header","text":"<pre><code>message:get_address_header(NAME)\n</code></pre> <p>Gets the first header whose name matches <code>NAME</code>, parses it as a list of mailboxes and groups, and returns an addressheader object.</p> <p>Returns <code>nil</code> if no matching header could be found.</p> <p>See also message:from_header and message:to_header.</p>"},{"location":"reference/message/get_all_headers/","title":"get_all_headers","text":"<pre><code>message:get_all_headers()\n</code></pre> <p>Gets the all the headers, decode the values to UTF-8 and return them in a lua array style table of tables:</p> <pre><code>local headers = message:get_all_headers()\nassert(headers == {\n  { 'Subject', 'The Subject' },\n  { 'Date', 'Sun Feb 26 02:45:02 PM MST 2023' },\n})\n</code></pre>"},{"location":"reference/message/get_all_named_header_values/","title":"get_all_named_header_values","text":"<pre><code>message:get_all_named_header_values(NAME)\n</code></pre> <p>Gets the all the headers whose name matches <code>NAME</code>, decode them to UTF-8 and return them in a lua array style table.</p> <p>Returns an empty table if no matching headers were found.</p>"},{"location":"reference/message/get_data/","title":"get_data","text":"<pre><code>message:get_data()\n</code></pre> <p>Returns the message body/data as a string.  This is typically the full email message and headers, but for log messages this will typically be the json-encoded representaiton of the log record.</p> <p>See also: * msg:set_data()</p>"},{"location":"reference/message/get_first_named_header_value/","title":"get_first_named_header_value","text":"<pre><code>message:get_first_named_header_value(NAME)\n</code></pre> <p>Gets the first header whose name matches <code>NAME</code>, decode it to UTF-8 and return it.</p> <p>Returns <code>nil</code> if no matching header could be found.</p>"},{"location":"reference/message/get_meta/","title":"get_meta","text":"<pre><code>message:get_meta(KEY)\n</code></pre> <p>Messages are associated with some metadata. You can think of this metadata as being equivalent to a JSON object.</p> <p>The <code>get_meta</code> method allows you to retrieve a field of that object.</p> <pre><code>msg:set_meta('foo', 'bar')\nprint(msg:get_meta 'foo') -- prints 'bar'\n</code></pre> <p>See also msg:set_meta.</p>","tags":["meta"]},{"location":"reference/message/get_meta/#pre-defined-meta-values","title":"Pre-defined meta values","text":"<p>The following meta values are unique to the message scope:</p> Scope Name Purpose Since Message <code>queue</code> specify the name of the queue to which the message will be queued. Must be a string value. Message <code>tenant</code> specify the name/identifier of the tenant, if any. Must be a string value. Message <code>campaign</code> specify the name/identifier of the campaign. Must be a string value. Message <code>routing_domain</code> Overrides the domain of the recipient domain for routing purposes. (Since: Version 2023.08.22-4d895015) <p>Note</p> <p>Additional metadata is available in the message scope that is copied in from the connection scope, for a full list of all available metadata, see the Predefined Metadata page.</p>","tags":["meta"]},{"location":"reference/message/id/","title":"id","text":"<pre><code>message:id()\n</code></pre> <p>Each message is uniquely identified by the system using an id.</p> <p>At the time of writing, the id is a version 1 UUID, which is based upon the time at which the message was created by the system. In the future, the system may change to adopt the newer v7 UUID.</p> <p><code>message:id()</code> returns the UUID encoded as a hexadecimal string, without any dashes or braces.</p>"},{"location":"reference/message/import_scheduling_header/","title":"import_scheduling_header","text":"<pre><code>message:import_scheduling_header(HEADER_NAME, REMOVE)\n</code></pre> <p>Reads the header specified and attempts to parse it as JSON-encoded version of the message:set_scheduling() parameters. If successful, it will call message:set_scheduling() with that value, and if REMOVE is set to true, will remove the header from the message.</p> <p>The return value of <code>message:import_scheduling_header</code> is:</p> <ul> <li>A lua table representation of the scheduling parameters, or nil if the specified header was not present. (Since: Version 2025.03.19-1d3f1f67)</li> <li><code>nil</code> in prior versions of KumoMTA.</li> </ul> <p>If the header is present, but has invalid contents the behavior will be:</p> <ul> <li>An error will be raised explaining the issue. (Since: Version 2025.03.19-1d3f1f67)</li> <li>No error indication will be given and no errors will be logged in prior versions of KumoMTA.</li> </ul> <p>For example, given this message:</p> <pre><code>X-Schedule: {\"dow\":\"Mon,Wed\",\"tz\":\"America/Phoenix\",\"start\":\"09:00:00\",\"end\":\"17:00:00\"}\nSubject: hello\n\nThis message should only be delivered during working hours\nin Phoenix on Mondays or Wednesdays.\n</code></pre> <p>this policy script will parse and remove that header, and apply the scheduling constraints:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  msg:import_scheduling_header('X-Schedule', true)\nend)\n</code></pre>"},{"location":"reference/message/import_x_headers/","title":"import_x_headers","text":"<pre><code>message:import_x_headers([NAMES])\n</code></pre> <p>When called with no parameters, iterates the headers of the message, and for each header with an <code>\"X-\"</code> prefix, imports the header into the message metadata.</p> <p>When called with a list of header names, only those headers, if present in the message, will be imported to the message metadata.  Header names passed in this way do not need to have an <code>X-</code> prefix, making it convenient to use this method as a way to import an arbitrary list of headers for logging purposes.</p> <p>When importing an <code>X-</code> header, the header name is normalized to lowercase and any <code>-</code> are transformed to underscores <code>_</code>.</p> <p>For example, with a message content of:</p> <pre><code>X-Campaign-ID: 12345\nX-Mailer: foobar\nSubject: the subject\n\nThe body\n</code></pre> <p>calling:</p> <pre><code>message:import_x_headers()\nprint(message:get_meta 'x_campaign_id') -- prints 12345\nprint(message:get_meta 'x_mailer') -- prints foobar\n</code></pre> <p>but calling:</p> <pre><code>message:import_x_headers { 'x-campaign-id' }\nprint(message:get_meta 'x_campaign_id') -- prints 12345\nprint(message:get_meta 'x_mailer') -- prints nothing\n</code></pre>","tags":["meta"]},{"location":"reference/message/increment_num_attempts/","title":"increment_num_attempts","text":"<pre><code>message:increment_num_attempts()\n</code></pre> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>This method increments the number of attempts recorded in the message.</p> <p>You will not ordinarily need to call this method, as each time a delivery attempt is made for a message, an internal attempt counter is incremented by one.</p> <p>You might consider calling this if you are performing custom automated queue rebinding together with message transfers.</p> <p>Note</p> <p>The number of attempts is not persistently spooled with the message, in order to reduce the IOPS impact of a large number of transient delivery attempts. The counter is stored in memory instead. If you restart kumod then an approximation of the number of attempts will be inferred when the message is spooled in, based on its age and the delivery parameters of the corresponding scheduled queue.</p>"},{"location":"reference/message/num_attempts/","title":"num_attempts","text":"<pre><code>message:num_attempts()\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>This method returns the number of delivery attempts that have been made for this message.</p> <p>Each time a delivery attempt is made for a message, an internal attempt counter is incremented by one.</p> <p>Note</p> <p>The number of attempts is not persistently spooled with the message, in order to reduce the IOPS impact of a large number of transient delivery attempts. The counter is stored in memory instead. If you restart kumod then an approximation of the number of attempts will be inferred when the message is spooled in, based on its age and the delivery parameters of the corresponding scheduled queue.</p>"},{"location":"reference/message/parse_mime/","title":"parse_mime","text":"<pre><code>local mime_part = message:parse_mime()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Returns a MimePart representation of the message content.</p> <p>Note</p> <p>While you can modify the returned mime structure, any such changes are not automatically reflected in the message content.  You must explicitly re-assign the content via <code>msg:set_data(tostring(mime_part))</code> to apply them.</p>"},{"location":"reference/message/parse_mime/#example-attachment-extraction","title":"Example: attachment extraction","text":"<p>This demonstrates how to obtain a list of all attachments found (recursively) in the incoming message and print out the file name, content type and the decoded content.</p> <p>This is not a useful production-ready example (you definitely don't want to log all of the attachment content like this!) but can serve as a starting point for policies that need to operate on attachments for scanning, compliance or automation purposes.</p> <pre><code>kumo.on('smtp_server_message_received', function(message, conn_meta)\n  local mime_part = message:parse_mime()\n  local structure = mime_part:get_simple_structure()\n\n  for _, attachment in ipairs(structure.attachments) do\n    print(attachment.file_name, attachment.content_type, attachment.part.body)\n  end\nend)\n</code></pre>"},{"location":"reference/message/parse_rfc3464/","title":"parse_rfc3464","text":"<pre><code>message:parse_rfc3464()\n</code></pre> <p>Parses the message data as an RFC 3464 delivery status report.</p> <p>If the message is not an RFC 3464 report, returns <code>nil</code>. If the message is malformed, raises a lua error.</p> <p>Otherwise, returns a lua table that looks like:</p> <pre><code>report = {\n  per_message = {\n    reporting_mta = {\n      mta_type = 'dns',\n      name = 'cs.utk.edu',\n    },\n  },\n  -- This is an array style table, with one entry per\n  -- recipient in the report\n  per_recipient = {\n    {\n      original_recipient = {\n        recipient_type = 'rfc822',\n        recipient = 'louisl@larry.slip.umd.edu',\n      },\n      final_recipient = {\n        recipient_type = 'rfc822',\n        recipient = 'louisl@larry.slip.umd.edu',\n      },\n      action = 'failed',\n      status = {\n        class = 4,\n        subject = 0,\n        detail = 0,\n      },\n      diagnostic_code = {\n        diagnostic_type = 'smtp',\n        diagnostic = '426 connection timed out',\n      },\n      last_attempt_date = '1994-07-07T21:15:49Z',\n    },\n  },\n}\n</code></pre>"},{"location":"reference/message/prepend_header/","title":"prepend_header","text":"<pre><code>message:prepend_header(NAME, VALUE)\n</code></pre> <p>Constructs a header from <code>NAME: VALUE</code> and prepends it to the message content.</p> <p>The <code>VALUE</code> is taken as-is and used as the header value.</p> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>This method now accepts an additional optional <code>ENCODE</code> parameter, which should be a boolean value:</p> <pre><code>message:prepend_header(NAME, VALUE, ENCODE)\n</code></pre> <p>When <code>ENCODE</code> is set to true then the <code>VALUE</code> will be encoded:</p> <ul> <li>If the header value is ascii then it will be soft wrapped at whitespace   around 75 columns, and hard-wrapped regardless of whitespace at 900 columns.</li> <li>If the header value is non-ascii then it will be quoted printable encoded   using RFC 2047 header encoding.</li> </ul>"},{"location":"reference/message/queue_name/","title":"queue_name","text":"<pre><code>message:queue_name()\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>This method returns the name of the scheduled queue into which the message would be inserted. The name is constructed according to the rules detailed in Queues.</p>"},{"location":"reference/message/recipient/","title":"recipient","text":"<pre><code>message:recipient()\n</code></pre> <p>Returns the envelope recipient of the message.  The return value is an EnvelopeAddress</p> <p>See also message:sender.</p>"},{"location":"reference/message/recipient/#recipient-list","title":"Recipient List","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>If the message is part of an SMTP batch with more than a single recipient then this method can return an array style table holding one EnvelopeAddress for each recipient.</p> <p>If you'd rather always deal with a list of recipients, even if there is just a single recipient, then you can use message:recipient_list.</p>"},{"location":"reference/message/recipient_list/","title":"recipient_list","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>message:recipient_list()\n</code></pre> <p>Returns an array style table holding each envelope recipient of the message. Each element of the array is  an EnvelopeAddress</p> <p>See also message:sender, message:recipient</p>"},{"location":"reference/message/remove_all_named_headers/","title":"remove_all_named_headers","text":"<pre><code>message:remove_all_named_headers(NAME)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Removes all header fields with name <code>NAME</code> from the message header.</p>"},{"location":"reference/message/remove_x_headers/","title":"remove_x_headers","text":"<pre><code>message:remove_x_headers([NAMES])\n</code></pre> <p>When called with no parameters, removes all headers with an <code>\"X-\"</code> prefix from the message.</p> <p>When called with a list of header names, only those headers, if present in the message, will be removed from the message.</p> <p>For example, with a message content of:</p> <pre><code>X-Campaign-ID: 12345\nX-Mailer: foobar\nSubject: the subject\n\nThe body\n</code></pre> <p>calling:</p> <pre><code>message:remove_x_headers()\n</code></pre> <p>will result in the body changing to:</p> <pre><code>Subject: the subject\n\nThe body\n</code></pre> <p>but calling:</p> <pre><code>message:remove_x_headers { 'x-campaign-id' }\n</code></pre> <p>will result in the body changing to:</p> <pre><code>X-Mailer: foobar\nSubject: the subject\n\nThe body\n</code></pre>"},{"location":"reference/message/save/","title":"save","text":"<pre><code>message:save()\n</code></pre> <p>Save the message data and metadata to the spool.</p> <p>You do not typically need to call this method.</p>"},{"location":"reference/message/sender/","title":"sender","text":"<pre><code>message:sender()\n</code></pre> <p>Returns the envelope sender of the message.  The return value is an EnvelopeAddress</p> <p>See also message:recipient.</p>"},{"location":"reference/message/set_data/","title":"set_data","text":"<pre><code>message:set_data(payload)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>Replaces the message body/data completely. It is your responsibility to ensure that the content is well-formed, has canonical CRLF line endings, and uses appropriate transfer-encoding, otherwise the system will misbehave when delivering the message.</p> <p>See also:</p> <ul> <li>msg:get_data()</li> </ul>"},{"location":"reference/message/set_due/","title":"set_due","text":"<pre><code>message:set_due(due)\n</code></pre> Since: Version 2024.06.10-84e84b89 <p>The functionality described in this section requires version 2024.06.10-84e84b89 of KumoMTA, or a more recent version.</p> <p>This method overrides the next delivery time for the message.  The due parameter may be:</p> <ul> <li><code>nil</code> - to indicate that delivery should be attempted as soon as possible.</li> <li>an ISO 8601 date and timestamp to specify the time of the next delivery attempt.   <code>msg:set_due(\"2024-03-08T17:51:42.481711Z\")</code></li> </ul> <p>Setting the due time is only valid in certain limited circumstances:</p> <ul> <li>Immediately at reception in either the   smtp_server_message_received or   http_message_generated events, although   it is much simpler to use the message:set_scheduling method   in almost all cases.</li> <li>During spooling in the   spool_message_enumerated event, where   it is anticipated that re-binding a message for immediate delivery would be   the most likely use-case.</li> </ul> <p>Warning</p> <p>Using this method in any other way can result in non-deterministic, undefined and unsupported behavior.</p>"},{"location":"reference/message/set_force_sync/","title":"set_force_sync","text":"<pre><code>message:set_force_sync(force)\n</code></pre> <p>When <code>force</code> is <code>true</code>, each future attempt to save the message metadata or data will use a high durability write, delaying further processing until the message data has been written to the spool.</p> <p>When <code>force</code> is <code>false</code>, which is the default setting, whether high durability writes are used is a function of the configuration of the spool(s) that you have enabled in your configuration.</p> <p>Note</p> <p>Using this together with RocksDB spool can be incredibly harmful to overall    performance, as forcing a flush is a database-wide operation.</p>"},{"location":"reference/message/set_meta/","title":"set_meta","text":"<pre><code>message:set_meta(KEY, VALUE)\n</code></pre> <p>Messages are associated with some metadata. You can think of this metadata as being equivalent to a JSON object.</p> <p>The <code>set_meta</code> method allows you to set a field of that object to a value that you specify.</p> <p>You can assign any value that is serializable as a JSON:</p> <pre><code>-- set foo='bar', a string value\nmsg:set_meta('foo', 'bar')\n\n-- set foo=123, a numeric value\nmsg:set_meta('foo', 123)\n\n-- set foo=true, a boolean value\nmsg:set_meta('foo', true)\n\n-- set foo={key=\"value\"}, an object value\nmsg:set_meta('foo', { key = 'value' })\n</code></pre> <p>You can retrieve a metadata value via message:get_meta.</p>","tags":["meta"]},{"location":"reference/message/set_meta/#pre-defined-meta-values","title":"Pre-defined meta values","text":"<p>The following meta values are unique to the message scope:</p> Scope Name Purpose Since Message <code>queue</code> specify the name of the queue to which the message will be queued. Must be a string value. Message <code>tenant</code> specify the name/identifier of the tenant, if any. Must be a string value. Message <code>campaign</code> specify the name/identifier of the campaign. Must be a string value. Message <code>routing_domain</code> Overrides the domain of the recipient domain for routing purposes. (Since: Version 2023.08.22-4d895015) <p>Note</p> <p>Additional metadata is available in the message scope that is copied in from the connection scope, for a full list of all available metadata, see the Predefined Metadata page.</p>","tags":["meta"]},{"location":"reference/message/set_recipient/","title":"set_recipient","text":"<pre><code>message:set_recipient(ENVELOPE)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Sets the envelope recipient of the message.  The value can be an EnvelopeAddress or a string that can be parsed into an <code>EnvelopeAddress</code>.</p> <pre><code>message:set_recipient 'someone.else@example.com'\n</code></pre> <p>See also message:set_sender.</p>"},{"location":"reference/message/set_recipient/#recipient-list","title":"Recipient List","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The value can be an array style table holding one <code>EnvelopeAddress</code> for each recipient that you wish to assign to the message.</p> <p>Note</p> <p>At the time of writing, only the SMTP and maildir delivery protocols have support for multi-recipient messages.</p>"},{"location":"reference/message/set_scheduling/","title":"set_scheduling","text":"<pre><code>message:set_scheduling { SCHED }\n</code></pre> <pre><code>message:set_scheduling(nil)\n</code></pre> <p>Allows setting schedule constraints on the message.</p> <p>When called with <code>nil</code> as a parameter, will clear any scheduling constraints that are set on the message.</p> <p>Otherwise, <code>SCHED</code> is a lua object that accepts a number of fields as listed below. There are two separate groups of scheduling constraint:</p> <ul> <li>Deferred initial delivery, using the <code>first_attempt</code> field</li> <li>Constrained time/day of week delivery using the <code>dow</code>, <code>tz</code>, <code>start</code> and <code>end</code> fields.</li> <li>Custom expiration time, using the <code>expires</code> field. (Since: Version 2025.03.19-1d3f1f67).</li> </ul> <p>When using constrained time of delivery, all four of the associated fields must be specified.  If not using constrained time of delivery, all four of the associated fields must be omitted.</p> <p>Constrained delivery modifies the normal exponential backoff retry schedule in a simple way: the target time is computed as normal, and if that time does not fall within the constrained delivery window, the scheduled time will be moved to the next following date/time at which delivery will be acceptable. In practice, that will be the <code>start</code> time on the follow appropriate <code>dow</code>.</p> <p>The return value of <code>message:set_scheduling</code> is:</p> <ul> <li>A lua table representation of the scheduling parameters. (Since: Version 2025.03.19-1d3f1f67)</li> <li><code>nil</code> in prior versions of KumoMTA.</li> </ul> <p>Just setting the <code>first_attempt</code>:</p> <pre><code>msg:set_scheduling { first_attempt = '2023-03-01T17:00:00:00-08:00' }\n</code></pre> <p>setting constraints to deliver only on Mondays and Wednesdays during business hours, Phoenix time.  Note that <code>end</code> has to be quoted to be used as a table key in lua, because it is a language keyword:</p> <pre><code>msg:set_scheduling {\n  dow = 'Mon,Wed',\n  tz = 'America/Phoenix',\n  start = '09:00:00',\n  ['end'] = '17:00:00',\n}\n</code></pre> <p>and both together:</p> <pre><code>msg:set_scheduling {\n  first_attempt = '2023-03-01T17:00:00:00-08:00',\n  dow = 'Mon,Wed',\n  tz = 'America/Phoenix',\n  start = '09:00:00',\n  ['end'] = '17:00:00',\n}\n</code></pre>"},{"location":"reference/message/set_scheduling/#first_attempt","title":"first_attempt","text":"<p>Optional String.</p> <p>If present, must be an RFC 3339 date/time string which specifies the earliest time at which the message will be scheduled for delivery.</p>"},{"location":"reference/message/set_scheduling/#expires","title":"expires","text":"Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Optional String.</p> <p>If present, must be an RFC 3339 date/time string which specifies the time at which the message will be expired from the spool. When the message is (re)inserted into the scheduled queue, if the next due time that is computed would be equal or later than the <code>expires</code> time, the message will be expired, removed from spool, and an <code>Expiration</code> record logged.</p> <p>If you do not specify an <code>expires</code> field, the max_age for the containing queue will be used as normal.</p>"},{"location":"reference/message/set_scheduling/#dow","title":"dow","text":"<p>String.</p> <p>Specifies the comma separated list of days of the week on which delivery will be permitted.  Days can be three-letter prefixes or the full English day names. For example both <code>\"Mon,Tue,Wed,Thu,Fri\"</code> and <code>\"Monday,Tuesday,Wednesday,Thursday,Friday\"</code> are acceptable ways to indicate working week days.</p>"},{"location":"reference/message/set_scheduling/#tz","title":"tz","text":"<p>String.</p> <p>Specifies the name of the timezone in which to interpret the scheduling constraints.  The timezone name must be a name from the IANA Time Zone Data such as <code>\"America/Phoenix\"</code>.  Short forms like <code>\"PST\"</code> have ambiguous interpretations and are NOT accepted.</p>"},{"location":"reference/message/set_scheduling/#start","title":"start","text":"<p>String.</p> <p>Specifies the time of day in <code>\"HH:MM:SS\"</code> form of the start of an acceptable delivery window.  The time is interpreted in the timezone specified by the <code>tz</code> field.</p>"},{"location":"reference/message/set_scheduling/#end","title":"end","text":"<p>String.</p> <p>Specifies the time of day in <code>\"HH:MM:SS\"</code> form of the end of an acceptable delivery window.  The time is interpreted in the timezone specified by the <code>tz</code> field.</p>"},{"location":"reference/message/set_sender/","title":"set_sender","text":"<pre><code>message:set_sender(ENVELOPE)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Sets the envelope sender of the message.  The value can be an EnvelopeAddress or a string that can be parsed into an <code>EnvelopeAddress</code>.</p> <pre><code>message:set_sender(string.format('bounce-%s@%s', HASH, DOMAIN))\n</code></pre> <p>See also message:set_recipient.</p>"},{"location":"reference/message/shrink/","title":"shrink","text":"<pre><code>message:shrink()\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>This method will ensure that the message contents are journalled to the spool, and then release any in-memory body and metadata information.</p> <p>See also: * msg:shrink_data()</p>"},{"location":"reference/message/shrink_data/","title":"shrink_data","text":"<pre><code>message:shrink_data()\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>This method will ensure that the message contents are journalled to the spool, and then release any in-memory body data, keeping the metadata in-memory.</p> <p>See also: * msg:shrink()</p>"},{"location":"reference/message/to_header/","title":"to_header","text":"<pre><code>message:to_header()\n</code></pre> <p>Gets the <code>\"To\"</code> header, parses it as a list of mailboxes and groups, and returns an addressheader object.</p> <p>Returns <code>nil</code> if no matching header could be found.</p> <p>See also message:get_address_header and message:from_header.</p>"},{"location":"reference/metrics/kumod/","title":"kumod Metrics","text":"<ul> <li>bind_failures</li> <li>bounce_classify_latency</li> <li>connection_count</li> <li>connection_count_by_provider</li> <li>connection_count_by_provider_and_pool</li> <li>delayed_due_to_message_rate_throttle</li> <li>delayed_due_to_ready_queue_full</li> <li>delayed_due_to_throttle_insert_ready</li> <li>deliver_message_latency_rollup</li> <li>disk_free_bytes</li> <li>disk_free_inodes</li> <li>disk_free_inodes_percent</li> <li>disk_free_percent</li> <li>dkim_signer_cache_hit</li> <li>dkim_signer_cache_lookup_count</li> <li>dkim_signer_cache_miss</li> <li>dkim_signer_creation</li> <li>dkim_signer_key_cache_hit</li> <li>dkim_signer_key_cache_lookup_count</li> <li>dkim_signer_key_cache_miss</li> <li>dkim_signer_key_fetch</li> <li>dkim_signer_message_parse</li> <li>dkim_signer_sign</li> <li>dns_mx_resolve_cache_hit</li> <li>dns_mx_resolve_cache_miss</li> <li>dns_mx_resolve_in_progress</li> <li>dns_mx_resolve_status_fail</li> <li>dns_mx_resolve_status_ok</li> <li>log_hook_backlog_count</li> <li>log_submit_full</li> <li>log_submit_latency</li> <li>lruttl_cache_size</li> <li>lruttl_error_count</li> <li>lruttl_evict_count</li> <li>lruttl_expire_count</li> <li>lruttl_hit_count</li> <li>lruttl_insert_count</li> <li>lruttl_lookup_count</li> <li>lruttl_miss_count</li> <li>lruttl_populated_count</li> <li>lruttl_stale_count</li> <li>lruttl_waiting_populate</li> <li>lua_count</li> <li>lua_event_latency</li> <li>lua_event_started</li> <li>lua_load_count</li> <li>lua_spare_count</li> <li>memoize_cache_hit_count</li> <li>memoize_cache_lookup_count</li> <li>memoize_cache_miss_count</li> <li>memoize_cache_populated_count</li> <li>memory_limit</li> <li>memory_low_count</li> <li>memory_low_thresh</li> <li>memory_over_limit_count</li> <li>memory_usage</li> <li>memory_usage_rust</li> <li>message_count</li> <li>message_data_load_latency</li> <li>message_data_resident_count</li> <li>message_meta_load_latency</li> <li>message_meta_resident_count</li> <li>message_save_latency</li> <li>process_cpu_usage_normalized</li> <li>process_cpu_usage_sum</li> <li>proxy_connection_failures</li> <li>queue_insert_latency</li> <li>queue_resolve_latency</li> <li>queued_count_by_provider</li> <li>queued_count_by_provider_and_pool</li> <li>ready_count</li> <li>ready_full</li> <li>ready_queue_insert_latency</li> <li>redis_operation_latency</li> <li>rocks_spool_cache_total</li> <li>rocks_spool_mem_table_readers_total</li> <li>rocks_spool_mem_table_total</li> <li>rocks_spool_mem_table_unflushed</li> <li>scheduled_by_domain</li> <li>scheduled_by_tenant</li> <li>scheduled_by_tenant_campaign</li> <li>scheduled_count</li> <li>scheduled_count_total</li> <li>scheduled_queue_count</li> <li>scheduled_queue_maintainer_count</li> <li>smtp_server_rejections</li> <li>smtpsrv_process_data_duration</li> <li>smtpsrv_read_data_duration</li> <li>smtpsrv_transaction_duration</li> <li>system_cpu_usage_normalized</li> <li>system_cpu_usage_sum</li> <li>thread_pool_parked</li> <li>thread_pool_size</li> <li>timeq_pop_interval</li> <li>timeq_pop_latency</li> <li>timeq_pop_tardiness</li> <li>timeq_reinsert_tardiness</li> <li>total_connection_count</li> <li>total_connections_denied</li> <li>total_messages_delivered</li> <li>total_messages_delivered_by_provider</li> <li>total_messages_delivered_by_provider_and_source</li> <li>total_messages_fail</li> <li>total_messages_fail_by_provider</li> <li>total_messages_fail_by_provider_and_source</li> <li>total_messages_received</li> <li>total_messages_transfail</li> <li>total_messages_transfail_by_provider</li> <li>total_messages_transfail_by_provider_and_source</li> <li>total_qmaint_runs</li> <li>total_readyq_runs</li> <li>user_lua_latency</li> </ul>"},{"location":"reference/metrics/kumod/bind_failures/","title":"bind_failures","text":"<p><pre><code>Type: Counter\n</code></pre> How many times that directly binding a source address has failed.</p> <p>This generally indicates a configuration error where a source is trying to assign an IP address that is not plumbing on the system on which kumod is running.</p>"},{"location":"reference/metrics/kumod/bounce_classify_latency/","title":"bounce_classify_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> latency of bounce classification.</p>"},{"location":"reference/metrics/kumod/bounce_classify_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>bounce_classify_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>bounce_classify_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>bounce_classify_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>bounce_classify_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>bounce_classify_latency</code> by computing <code>bounce_classify_latency_sum / bounce_classify_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/connection_count/","title":"connection_count","text":"<p><pre><code>Type: Gauge\nLabels: service\n</code></pre> The number of active outgoing connections in the system,  keyed by the service name.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/connection_count_by_provider/","title":"connection_count_by_provider","text":"<p><pre><code>Type: Gauge\nLabels: provider\n</code></pre> number of active connections.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/connection_count_by_provider_and_pool/","title":"connection_count_by_provider_and_pool","text":"<p><pre><code>Type: Gauge\nLabels: provider, pool\n</code></pre> number of active connections.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/delayed_due_to_message_rate_throttle/","title":"delayed_due_to_message_rate_throttle","text":"<p><pre><code>Type: Counter\nLabels: queue\n</code></pre> Number of times a message was delayed due to max_message_rate.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Delayed in this context means that we moved the message back to its corresponding scheduled queue with a short retry time, as well as logging a <code>Delayed</code> log record.</p> <p>Sustained increases in this value may indicate that the configured throttles are too severe for your workload, but it is difficult to make a definitive and generalized statement in these docs without understanding your workload, policy and the purpose of those throttles.</p> <p>The metric is tracked per <code>queue</code> label.  The <code>queue</code> is the scheduled queue name as described in Queues.</p>"},{"location":"reference/metrics/kumod/delayed_due_to_ready_queue_full/","title":"delayed_due_to_ready_queue_full","text":"<p><pre><code>Type: Counter\nLabels: queue\n</code></pre> Number of times a message was delayed due to the corresponding ready queue being full.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Delayed in this context means that we moved the message back to its corresponding scheduled queue with a short retry time, as well as logging a <code>Delayed</code> log record.</p> <p>Transient spikes in this value indicate normal operation and that the system is keeping things within your memory budget.</p> <p>However, sustained increases in this value may indicate that the max_ready configuration for the associated egress path is under-sized for your workload, and that you should carefully consider the information in Budgeting/Tuning Memory to decide whether increasing <code>max_ready</code> is appropriate, otherwise you risk potentially over-provisioning the system.</p> <p>The metric is tracked per <code>queue</code> label.  The <code>queue</code> is the scheduled queue name as described in Queues.</p> <p>See ready_full for the equivalent metric tracked by the ready queue name, which can be helpful to understand which egress path configuration you might want to examine.</p>"},{"location":"reference/metrics/kumod/delayed_due_to_throttle_insert_ready/","title":"delayed_due_to_throttle_insert_ready","text":"<p><pre><code>Type: Counter\nLabels: queue\n</code></pre> number of times a message was delayed due to the throttle_insert_ready_queue event.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Delayed in this context means that we moved the message back to its corresponding scheduled queue with a short retry time, as well as logging a <code>Delayed</code> log record.</p> <p>The throttle_insert_ready_queue event is implemented either directly in your policy, or indirectly via policy helpers, such as the queues helper when configured to throttle campaigns or tenants.</p> <p>Sustained increases in this value may indicate that the configured throttles are too severe for your workload, but it is difficult to make a definitive and generalized statement in these docs without understanding your workload, policy and the purpose of those throttles.</p> <p>The metric is tracked per <code>queue</code> label.  The <code>queue</code> is the scheduled queue name as described in Queues.</p>"},{"location":"reference/metrics/kumod/deliver_message_latency_rollup/","title":"deliver_message_latency_rollup","text":"<p><pre><code>Type: Histogram\nLabels: service\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> how many seconds a deliver_message call takes for a given protocol.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/deliver_message_latency_rollup/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>deliver_message_latency_rollup_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>deliver_message_latency_rollup_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>deliver_message_latency_rollup_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>deliver_message_latency_rollup_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>deliver_message_latency_rollup</code> by computing <code>deliver_message_latency_rollup_sum / deliver_message_latency_rollup_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/disk_free_bytes/","title":"disk_free_bytes","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> number of available bytes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/disk_free_inodes/","title":"disk_free_inodes","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> number of available inodes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/disk_free_inodes_percent/","title":"disk_free_inodes_percent","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> percentage of available inodes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/disk_free_percent/","title":"disk_free_percent","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> percentage of available bytes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/dkim_signer_cache_hit/","title":"dkim_signer_cache_hit","text":"<p><pre><code>Type: Counter\n</code></pre> How many dkim signer requests hit cache.</p> <p>This is redundant with the newer lruttl_hit_count{cache_name=\"dkim_signer_cache\"} counter.</p>"},{"location":"reference/metrics/kumod/dkim_signer_cache_lookup_count/","title":"dkim_signer_cache_lookup_count","text":"<p><pre><code>Type: Counter\n</code></pre> How many cache dkim signer requests occurred.</p> <p>This is redundant with the newer lruttl_lookup_count{cache_name=\"dkim_signer_cache\"} counter.</p>"},{"location":"reference/metrics/kumod/dkim_signer_cache_miss/","title":"dkim_signer_cache_miss","text":"<p><pre><code>Type: Counter\n</code></pre> How many dkim signer requests miss cache.</p> <p>This is redundant with the newer lruttl_miss_count{cache_name=\"dkim_signer_cache\"} counter.</p>"},{"location":"reference/metrics/kumod/dkim_signer_creation/","title":"dkim_signer_creation","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds it takes to create a signer on a cache miss.</p>"},{"location":"reference/metrics/kumod/dkim_signer_creation/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>dkim_signer_creation_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>dkim_signer_creation_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>dkim_signer_creation_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>dkim_signer_creation_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>dkim_signer_creation</code> by computing <code>dkim_signer_creation_sum / dkim_signer_creation_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/dkim_signer_key_cache_hit/","title":"dkim_signer_key_cache_hit","text":"<p><pre><code>Type: Counter\n</code></pre> How many cache dkim signer requests hit key cache.</p> <p>This is redundant with the newer lruttl_hit_count{cache_name=\"dkim_key_cache\"} counter.</p>"},{"location":"reference/metrics/kumod/dkim_signer_key_cache_lookup_count/","title":"dkim_signer_key_cache_lookup_count","text":"<p><pre><code>Type: Counter\n</code></pre> How many cache dkim key requests occurred.</p> <p>This is redundant with the newer lruttl_lookup_count{cache_name=\"dkim_key_cache\"} counter.</p>"},{"location":"reference/metrics/kumod/dkim_signer_key_cache_miss/","title":"dkim_signer_key_cache_miss","text":"<p><pre><code>Type: Counter\n</code></pre> How many cache dkim signer requests miss key cache.</p> <p>This is redundant with the newer lruttl_miss_count{cache_name=\"dkim_key_cache\"} counter.</p>"},{"location":"reference/metrics/kumod/dkim_signer_key_fetch/","title":"dkim_signer_key_fetch","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How long it takes to obtain a dkim key.</p> <p>This measures that time that it takes to load dkim private keys from whatever storage medium is configured.</p>"},{"location":"reference/metrics/kumod/dkim_signer_key_fetch/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>dkim_signer_key_fetch_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>dkim_signer_key_fetch_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>dkim_signer_key_fetch_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>dkim_signer_key_fetch_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>dkim_signer_key_fetch</code> by computing <code>dkim_signer_key_fetch_sum / dkim_signer_key_fetch_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/dkim_signer_message_parse/","title":"dkim_signer_message_parse","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds it takes to parse messages as prep for signing.</p> <p>Long durations may simply indicate that you have very large messages passing through the system.</p>"},{"location":"reference/metrics/kumod/dkim_signer_message_parse/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>dkim_signer_message_parse_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>dkim_signer_message_parse_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>dkim_signer_message_parse_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>dkim_signer_message_parse_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>dkim_signer_message_parse</code> by computing <code>dkim_signer_message_parse_sum / dkim_signer_message_parse_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/dkim_signer_sign/","title":"dkim_signer_sign","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds it takes to dkim sign parsed messages.</p> <p>Long durations may indicate that the system is over-provisioned and has insufficient CPU.  You should check whether and how you might have configured kumo.dkim.set_signing_threads.</p>"},{"location":"reference/metrics/kumod/dkim_signer_sign/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>dkim_signer_sign_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>dkim_signer_sign_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>dkim_signer_sign_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>dkim_signer_sign_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>dkim_signer_sign</code> by computing <code>dkim_signer_sign_sum / dkim_signer_sign_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/dns_mx_resolve_cache_hit/","title":"dns_mx_resolve_cache_hit","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of MailExchanger::resolve calls satisfied by level 1 cache.</p> <p>Redundant with the newer lruttl_hit_count{cache_name=\"dns_resolver_mx\"} metric.</p>"},{"location":"reference/metrics/kumod/dns_mx_resolve_cache_miss/","title":"dns_mx_resolve_cache_miss","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of MailExchanger::resolve calls that resulted in an MX DNS request to the next level of cache.</p> <p>Redundant with the newer lruttl_miss_count{cache_name=\"dns_resolver_mx\"} metric.</p>"},{"location":"reference/metrics/kumod/dns_mx_resolve_in_progress/","title":"dns_mx_resolve_in_progress","text":"<p><pre><code>Type: Gauge\n</code></pre> number of <code>MailExchanger::resolve</code> calls currently in progress.</p>"},{"location":"reference/metrics/kumod/dns_mx_resolve_status_fail/","title":"dns_mx_resolve_status_fail","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of failed <code>MailExchanger::resolve</code> calls.</p> <p>Spikes may indicate an issue with your DNS configuration or infrastructure, or may simply indicate that the traffic is destined for bogus addresses.</p>"},{"location":"reference/metrics/kumod/dns_mx_resolve_status_ok/","title":"dns_mx_resolve_status_ok","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of successful <code>MailExchanger::resolve</code> calls.</p>"},{"location":"reference/metrics/kumod/log_hook_backlog_count/","title":"log_hook_backlog_count","text":"<p><pre><code>Type: Counter\nLabels: logger\n</code></pre> how many times processing of a log event hit the back_pressure in a hook.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/log_submit_full/","title":"log_submit_full","text":"<p><pre><code>Type: Counter\nLabels: logger\n</code></pre> how many times submission of a log event hit the back_pressure.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/log_submit_latency/","title":"log_submit_latency","text":"<p><pre><code>Type: Histogram\nLabels: logger\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> latency of log event submission operations.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/log_submit_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>log_submit_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>log_submit_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>log_submit_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>log_submit_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>log_submit_latency</code> by computing <code>log_submit_latency_sum / log_submit_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/lruttl_cache_size/","title":"lruttl_cache_size","text":"<p><pre><code>Type: Gauge\nLabels: cache_name\n</code></pre> The number of items currently contained in an lruttl cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_error_count/","title":"lruttl_error_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache population resulted in an error.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_evict_count/","title":"lruttl_evict_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache evicted an item due to capacity constraints.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_expire_count/","title":"lruttl_expire_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache removed an item due to ttl expiration.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_hit_count/","title":"lruttl_hit_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache lookup was a hit for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_insert_count/","title":"lruttl_insert_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache was populated via unconditional insert.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_lookup_count/","title":"lruttl_lookup_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a lruttl cache lookup was initiated for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_miss_count/","title":"lruttl_miss_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache lookup was a miss for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_populated_count/","title":"lruttl_populated_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache lookup resulted in performing the work to populate the entry.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_stale_count/","title":"lruttl_stale_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache population was satisfied by a stale value.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lruttl_waiting_populate/","title":"lruttl_waiting_populate","text":"<p><pre><code>Type: Gauge\nLabels: cache_name\n</code></pre> how many tasks are currently waiting for a cache entry to populate.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/kumod/lua_count/","title":"lua_count","text":"<p><pre><code>Type: Gauge\n</code></pre> the number of lua contexts currently alive.</p>"},{"location":"reference/metrics/kumod/lua_event_latency/","title":"lua_event_latency","text":"<p><pre><code>Type: Histogram\nLabels: event\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> how long a given lua event callback took.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/lua_event_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>lua_event_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>lua_event_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>lua_event_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>lua_event_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>lua_event_latency</code> by computing <code>lua_event_latency_sum / lua_event_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/lua_event_started/","title":"lua_event_started","text":"<p><pre><code>Type: Counter\nLabels: event\n</code></pre> Incremented each time we start to call a lua event callback. Use lua_event_latency_count to track completed events.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/lua_load_count/","title":"lua_load_count","text":"<p><pre><code>Type: Counter\n</code></pre> how many times the policy lua script has been loaded into a new context.</p>"},{"location":"reference/metrics/kumod/lua_spare_count/","title":"lua_spare_count","text":"<p><pre><code>Type: Gauge\n</code></pre> the number of lua contexts available for reuse in the pool.</p>"},{"location":"reference/metrics/kumod/memoize_cache_hit_count/","title":"memoize_cache_hit_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup was a hit for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_hit_count metric.</p>"},{"location":"reference/metrics/kumod/memoize_cache_lookup_count/","title":"memoize_cache_lookup_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup was initiated for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_lookup_count metric.</p>"},{"location":"reference/metrics/kumod/memoize_cache_miss_count/","title":"memoize_cache_miss_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup was a miss for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_miss_count metric.</p>"},{"location":"reference/metrics/kumod/memoize_cache_populated_count/","title":"memoize_cache_populated_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup resulted in performing the work to populate the entry.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_populated_count metric.</p>"},{"location":"reference/metrics/kumod/memory_limit/","title":"memory_limit","text":"<p><pre><code>Type: Gauge\n</code></pre> soft memory limit measured in bytes.</p>"},{"location":"reference/metrics/kumod/memory_low_count/","title":"memory_low_count","text":"<p><pre><code>Type: Counter\n</code></pre> How many times the low memory threshold was exceeded.</p>"},{"location":"reference/metrics/kumod/memory_low_thresh/","title":"memory_low_thresh","text":"<p><pre><code>Type: Gauge\n</code></pre> low memory threshold measured in bytes.</p>"},{"location":"reference/metrics/kumod/memory_over_limit_count/","title":"memory_over_limit_count","text":"<p><pre><code>Type: Counter\n</code></pre> how many times the soft memory limit was exceeded.</p>"},{"location":"reference/metrics/kumod/memory_usage/","title":"memory_usage","text":"<p><pre><code>Type: Gauge\n</code></pre> number of bytes of used memory (Resident Set Size).</p>"},{"location":"reference/metrics/kumod/memory_usage_rust/","title":"memory_usage_rust","text":"<p><pre><code>Type: Gauge\n</code></pre> number of bytes of used memory (allocated by Rust).</p>"},{"location":"reference/metrics/kumod/message_count/","title":"message_count","text":"<p><pre><code>Type: Gauge\n</code></pre> Total number of Message objects.</p> <p>This encompasses all Message objects in various states, whether they are in a queue, moving between queues, being built as part of an injection, pending logging, message metadata and/or data may be either resident or offloaded to spool.</p>"},{"location":"reference/metrics/kumod/message_data_load_latency/","title":"message_data_load_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds it takes to load message data from spool.</p> <p>High values indicate IO pressure which may be caused by policy that operates on the message body post-reception. We recommend avoiding logging header values as that is the most common cause of this metric spiking and has the biggest impact in resolving it.</p> <p>IO pressure may also be alleviated by tuning other constraints and/or RocksDB Parameters</p>"},{"location":"reference/metrics/kumod/message_data_load_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>message_data_load_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>message_data_load_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>message_data_load_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>message_data_load_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>message_data_load_latency</code> by computing <code>message_data_load_latency_sum / message_data_load_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/message_data_resident_count/","title":"message_data_resident_count","text":"<p><pre><code>Type: Gauge\n</code></pre> Total number of Message objects with body data loaded.</p> <p>Tracks how many messages have their <code>data</code> resident in memory.  This may be because they have not yet saved it, or because the message is being processed and the data is either required to be in memory in order to deliver the message, or because logging or other post-injection policy is configured to operate on the message.</p>"},{"location":"reference/metrics/kumod/message_meta_load_latency/","title":"message_meta_load_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How long it takes to load message metadata from spool.</p> <p>High values indicate IO pressure which may be alleviated by tuning other constraints and/or RocksDB Parameters</p>"},{"location":"reference/metrics/kumod/message_meta_load_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>message_meta_load_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>message_meta_load_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>message_meta_load_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>message_meta_load_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>message_meta_load_latency</code> by computing <code>message_meta_load_latency_sum / message_meta_load_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/message_meta_resident_count/","title":"message_meta_resident_count","text":"<p><pre><code>Type: Gauge\n</code></pre> Total number of Message objects with metadata loaded.</p> <p>Tracks how many messages have their <code>meta</code> data resident in memory.  This may be because they have not yet saved it, or because the message is being processed and the metadata is required for that processing.</p>"},{"location":"reference/metrics/kumod/message_save_latency/","title":"message_save_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds it takes to save a message to spool.</p> <p>This metric encompasses the elapsed time to saved either or both the <code>meta</code> and <code>data</code> portions of a message to spool.</p> <p>High values indicate IO pressure which may be alleviated by tuning other constraints and/or RocksDB Parameters</p>"},{"location":"reference/metrics/kumod/message_save_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>message_save_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>message_save_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>message_save_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>message_save_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>message_save_latency</code> by computing <code>message_save_latency_sum / message_save_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/process_cpu_usage_normalized/","title":"process_cpu_usage_normalized","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the process CPU usage for each CPU in the system, divided by the number of CPUs.</p> <p>100% in this metric indicates that all CPU cores are 100% busy.</p> <p>This metric is scoped to the service process, reflecting the CPU used only by the process and not the system as a whole.</p>"},{"location":"reference/metrics/kumod/process_cpu_usage_sum/","title":"process_cpu_usage_sum","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the process CPU usage for each CPU in the system, can add up to more than 100%.</p> <p>Each CPU has a value from 0-100% busy; a value of 100% in this metric indicates that the load is equivalent to one fully utilized CPU.</p> <p>A multi-CPU system can report more than 100% in this metric; a dual-CPU system reporting 200% indicates that both CPUs are fully utilized.</p> <p>See process_cpu_usage_normalized for a version of this metric that scales from 0% (totally idle) to 100% (totally saturated).</p> <p>This metric is scoped to the service process, reflecting the CPU used only by the process and not the system as a whole.</p>"},{"location":"reference/metrics/kumod/proxy_connection_failures/","title":"proxy_connection_failures","text":"<p><pre><code>Type: Counter\n</code></pre> How many times a connection attempt to a proxy server has failed.</p> <p>This might indicate either a configuration error (eg: an incorrect proxy server has been configured) or a service interruption with that proxy server.</p>"},{"location":"reference/metrics/kumod/queue_insert_latency/","title":"queue_insert_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> latency of QueueManager::insert operations.</p>"},{"location":"reference/metrics/kumod/queue_insert_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>queue_insert_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>queue_insert_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>queue_insert_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>queue_insert_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>queue_insert_latency</code> by computing <code>queue_insert_latency_sum / queue_insert_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/queue_resolve_latency/","title":"queue_resolve_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> latency of QueueManager::resolve operations.</p>"},{"location":"reference/metrics/kumod/queue_resolve_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>queue_resolve_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>queue_resolve_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>queue_resolve_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>queue_resolve_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>queue_resolve_latency</code> by computing <code>queue_resolve_latency_sum / queue_resolve_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/queued_count_by_provider/","title":"queued_count_by_provider","text":"<p><pre><code>Type: Gauge\nLabels: provider\n</code></pre> number of messages in the scheduled and ready queue.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/queued_count_by_provider_and_pool/","title":"queued_count_by_provider_and_pool","text":"<p><pre><code>Type: Gauge\nLabels: provider, pool\n</code></pre> number of messages in the scheduled and ready queue.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/ready_count/","title":"ready_count","text":"<p><pre><code>Type: Gauge\nLabels: service\n</code></pre> number of messages in the ready queue.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/ready_full/","title":"ready_full","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> number of times a message could not fit in the ready queue.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>See delayed_due_to_ready_queue_full for the equivalent metric tracked by scheduled queue name, as well as a discussion on what this event means.</p>"},{"location":"reference/metrics/kumod/ready_queue_insert_latency/","title":"ready_queue_insert_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> latency of ReadyQueue::insert operations.</p>"},{"location":"reference/metrics/kumod/ready_queue_insert_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>ready_queue_insert_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>ready_queue_insert_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>ready_queue_insert_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>ready_queue_insert_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>ready_queue_insert_latency</code> by computing <code>ready_queue_insert_latency_sum / ready_queue_insert_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/redis_operation_latency/","title":"redis_operation_latency","text":"<p><pre><code>Type: Histogram\nLabels: service, operation, status\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> The latency of an operation talking to Redis.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>The <code>service</code> key represents the redis server/service. It is not a direct match to a server name as it is really a hash of the overall redis configuration information used in the client. It might look something like: <code>redis://127.0.0.1:24419,redis://127.0.0.1:7779,redis://127.0.0.1:29469-2ce79dd1</code> for a cluster configuration, or <code>redis://127.0.0.1:16267-f4da6e64</code> for a single node cluster configuration. You should anticipate that the <code>-HEX</code> suffix can and will change in an unspecified way as you vary the redis connection parameters.</p> <p>The <code>operation</code> key indicates the operation, which can be a <code>ping</code>, a <code>query</code> or a <code>script</code>.</p> <p><code>status</code> will be either <code>ok</code> or <code>error</code> to indicate whether this is tracking a successful or failed operation.</p> <p>Since histograms track a count of operations, you can track the rate of <code>redis_operation_latency_count</code> where <code>status=error</code> to have an indication of the failure rate of redis operations.</p>"},{"location":"reference/metrics/kumod/redis_operation_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>redis_operation_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>redis_operation_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>redis_operation_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>redis_operation_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>redis_operation_latency</code> by computing <code>redis_operation_latency_sum / redis_operation_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/rocks_spool_cache_total/","title":"rocks_spool_cache_total","text":"<p><pre><code>Type: Gauge\nLabels: path\n</code></pre> Approximate memory (bytes) usage by cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This may be useful when understanding the memory usage of the system.</p>"},{"location":"reference/metrics/kumod/rocks_spool_mem_table_readers_total/","title":"rocks_spool_mem_table_readers_total","text":"<p><pre><code>Type: Gauge\nLabels: path\n</code></pre> Approximate memory usage (bytes) of all the table readers.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This may be useful when understanding the memory usage of the system.</p>"},{"location":"reference/metrics/kumod/rocks_spool_mem_table_total/","title":"rocks_spool_mem_table_total","text":"<p><pre><code>Type: Gauge\nLabels: path\n</code></pre> Approximate memory usage (bytes) of all the mem-tables.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This may be useful when understanding the memory usage of the system.</p>"},{"location":"reference/metrics/kumod/rocks_spool_mem_table_unflushed/","title":"rocks_spool_mem_table_unflushed","text":"<p><pre><code>Type: Gauge\nLabels: path\n</code></pre> Approximate memory usage (bytes) of un-flushed mem-tables.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This may be useful when understanding the memory usage of the system.</p>"},{"location":"reference/metrics/kumod/scheduled_by_domain/","title":"scheduled_by_domain","text":"<p><pre><code>Type: Gauge\nLabels: domain\n</code></pre> number of messages in the scheduled queue for a specific domain.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/scheduled_by_tenant/","title":"scheduled_by_tenant","text":"<p><pre><code>Type: Gauge\nLabels: tenant\n</code></pre> number of messages in the scheduled queue for a specific tenant.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/scheduled_by_tenant_campaign/","title":"scheduled_by_tenant_campaign","text":"<p><pre><code>Type: Gauge\nLabels: tenant, campaign\n</code></pre> number of messages in the scheduled queue for a specific tenant and campaign combination.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/scheduled_count/","title":"scheduled_count","text":"<p><pre><code>Type: Gauge\nLabels: queue\n</code></pre> number of messages in the scheduled queue.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The metric is tracked per <code>queue</code> label.  The <code>queue</code> is the scheduled queue name as described in Queues.</p>"},{"location":"reference/metrics/kumod/scheduled_count_total/","title":"scheduled_count_total","text":"<p><pre><code>Type: Gauge\n</code></pre> total number of messages across all scheduled queues.</p> <p>This counter sums up the number of messages currently sitting in all scheduled queues.</p>"},{"location":"reference/metrics/kumod/scheduled_queue_count/","title":"scheduled_queue_count","text":"<p><pre><code>Type: Gauge\n</code></pre> how many scheduled queues are tracked by the QueueManager.</p>"},{"location":"reference/metrics/kumod/scheduled_queue_maintainer_count/","title":"scheduled_queue_maintainer_count","text":"<p><pre><code>Type: Gauge\n</code></pre> How many scheduled queues have active maintainer tasks.</p>"},{"location":"reference/metrics/kumod/smtp_server_rejections/","title":"smtp_server_rejections","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> number of Rejection records logged by the smtp server.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/smtpsrv_process_data_duration/","title":"smtpsrv_process_data_duration","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> how long it takes to process the DATA portion and enqueue.</p>"},{"location":"reference/metrics/kumod/smtpsrv_process_data_duration/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>smtpsrv_process_data_duration_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>smtpsrv_process_data_duration_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>smtpsrv_process_data_duration_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>smtpsrv_process_data_duration_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>smtpsrv_process_data_duration</code> by computing <code>smtpsrv_process_data_duration_sum / smtpsrv_process_data_duration_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/smtpsrv_read_data_duration/","title":"smtpsrv_read_data_duration","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> how long it takes to receive the DATA portion.</p>"},{"location":"reference/metrics/kumod/smtpsrv_read_data_duration/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>smtpsrv_read_data_duration_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>smtpsrv_read_data_duration_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>smtpsrv_read_data_duration_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>smtpsrv_read_data_duration_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>smtpsrv_read_data_duration</code> by computing <code>smtpsrv_read_data_duration_sum / smtpsrv_read_data_duration_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/smtpsrv_transaction_duration/","title":"smtpsrv_transaction_duration","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> how long an incoming SMTP transaction takes.</p>"},{"location":"reference/metrics/kumod/smtpsrv_transaction_duration/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>smtpsrv_transaction_duration_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>smtpsrv_transaction_duration_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>smtpsrv_transaction_duration_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>smtpsrv_transaction_duration_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>smtpsrv_transaction_duration</code> by computing <code>smtpsrv_transaction_duration_sum / smtpsrv_transaction_duration_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/system_cpu_usage_normalized/","title":"system_cpu_usage_normalized","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the system-wide CPU usage for each CPU in the system, divided by the number of CPUs.</p> <p>100% in this metric indicates that all CPU cores are 100% busy.</p> <p>This metric is scoped to the system, reflecting the total load on the system, not just from the kumo related process(es).</p>"},{"location":"reference/metrics/kumod/system_cpu_usage_sum/","title":"system_cpu_usage_sum","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the system-wide CPU usage for each CPU in the system, can add up to more than 100%.</p> <p>Each CPU has a value from 0-100% busy; a value of 100% in this metric indicates that the load is equivalent to one fully utilized CPU.</p> <p>A multi-CPU system can report more than 100% in this metric; a dual-CPU system reporting 200% indicates that both CPUs are fully utilized.</p> <p>See system_cpu_usage_normalized for a version of this metric that scales from 0% (totally idle) to 100% (totally saturated).</p> <p>This metric is scoped to the system, reflecting the total load on the system, not just from the kumo related process(es).</p>"},{"location":"reference/metrics/kumod/thread_pool_parked/","title":"thread_pool_parked","text":"<p><pre><code>Type: Gauge\nLabels: pool\n</code></pre> number of parked (idle) threads in a thread pool.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/thread_pool_size/","title":"thread_pool_size","text":"<p><pre><code>Type: Gauge\nLabels: pool\n</code></pre> number of threads in a thread pool.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/timeq_pop_interval/","title":"timeq_pop_interval","text":"<p><pre><code>Type: Histogram\nBuckets: 3.0, 4.0, 5.0, 8.0, 10.0, 12.0, 15.0, 20.0, 25.0, 30.0\n</code></pre> The amount of time that passes between calls to <code>TimeQ::pop</code>.</p> <p>This metric is not generally interesting and does not typically need to be charted in a dashboard.</p>"},{"location":"reference/metrics/kumod/timeq_pop_interval/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>timeq_pop_interval_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>timeq_pop_interval_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>timeq_pop_interval_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"3.0\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>timeq_pop_interval_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>timeq_pop_interval</code> by computing <code>timeq_pop_interval_sum / timeq_pop_interval_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/timeq_pop_latency/","title":"timeq_pop_latency","text":"<p><pre><code>Type: Histogram\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> The number of seconds that passes between calls to a singleon timerwheel pop.</p> <p>This gives an indication of how heavily loaded the timerwheel buckets might be, but is not generally useful to chart.</p>"},{"location":"reference/metrics/kumod/timeq_pop_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>timeq_pop_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>timeq_pop_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>timeq_pop_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>timeq_pop_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>timeq_pop_latency</code> by computing <code>timeq_pop_latency_sum / timeq_pop_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/timeq_pop_tardiness/","title":"timeq_pop_tardiness","text":"<p><pre><code>Type: Histogram\nBuckets: 0.25, 0.5, 1.0, 2.5, 3.0, 5.0, 10.0, 15.0\n</code></pre> The time difference between the due and current time for a singleon timerwheel pop.</p> <p>This gives an indication of whether the scheduled queue maintainer is keeping up with the load.  It is generally acceptable for this value to be a few seconds \"late\" due to a combination of time wheel bucket granularity and overall scheduling priority.</p>"},{"location":"reference/metrics/kumod/timeq_pop_tardiness/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>timeq_pop_tardiness_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>timeq_pop_tardiness_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>timeq_pop_tardiness_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.25\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>timeq_pop_tardiness_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>timeq_pop_tardiness</code> by computing <code>timeq_pop_tardiness_sum / timeq_pop_tardiness_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/timeq_reinsert_tardiness/","title":"timeq_reinsert_tardiness","text":"<p><pre><code>Type: Histogram\nBuckets: 0.25, 0.5, 1.0, 2.5, 3.0, 5.0, 10.0, 15.0, 30.0, 45.0, 60.0, 90.0, 180.0, 360.0, 720.0\n</code></pre> The time difference between the due and current time for a singleon timerwheel reinsertion.</p> <p>This gives an indication of whether the scheduled queue maintainer is keeping up with the load.  It is generally acceptable for this value to be a few seconds \"late\" due to a combination of time wheel bucket granularity and overall scheduling priority.</p>"},{"location":"reference/metrics/kumod/timeq_reinsert_tardiness/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>timeq_reinsert_tardiness_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>timeq_reinsert_tardiness_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>timeq_reinsert_tardiness_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.25\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>timeq_reinsert_tardiness_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>timeq_reinsert_tardiness</code> by computing <code>timeq_reinsert_tardiness_sum / timeq_reinsert_tardiness_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/kumod/total_connection_count/","title":"total_connection_count","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> total number of active connections ever made.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_connections_denied/","title":"total_connections_denied","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> total number of connections rejected due to load shedding or concurrency limits.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_delivered/","title":"total_messages_delivered","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> total number of messages ever delivered.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_delivered_by_provider/","title":"total_messages_delivered_by_provider","text":"<p><pre><code>Type: Counter\nLabels: provider\n</code></pre> total number of messages ever delivered.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_delivered_by_provider_and_source/","title":"total_messages_delivered_by_provider_and_source","text":"<p><pre><code>Type: Counter\nLabels: provider, source, pool\n</code></pre> total number of messages ever delivered.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_fail/","title":"total_messages_fail","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> total number of message delivery attempts that permanently failed.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_fail_by_provider/","title":"total_messages_fail_by_provider","text":"<p><pre><code>Type: Counter\nLabels: provider\n</code></pre> total number of message delivery attempts that permanently failed.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_fail_by_provider_and_source/","title":"total_messages_fail_by_provider_and_source","text":"<p><pre><code>Type: Counter\nLabels: provider, source, pool\n</code></pre> total number of message delivery attempts that permanently failed.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_received/","title":"total_messages_received","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> total number of messages ever received.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_transfail/","title":"total_messages_transfail","text":"<p><pre><code>Type: Counter\nLabels: service\n</code></pre> total number of message delivery attempts that transiently failed.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_transfail_by_provider/","title":"total_messages_transfail_by_provider","text":"<p><pre><code>Type: Counter\nLabels: provider\n</code></pre> total number of message delivery attempts that transiently failed.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_messages_transfail_by_provider_and_source/","title":"total_messages_transfail_by_provider_and_source","text":"<p><pre><code>Type: Counter\nLabels: provider, source, pool\n</code></pre> total number of message delivery attempts that transiently failed.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/kumod/total_qmaint_runs/","title":"total_qmaint_runs","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of times a scheduled queue maintainer was run.</p> <p>This metric is not generally useful to chart. It gives an indication that schedule queue maintainers are ticking over, but it is difficult to reason much beyond that that is happening.</p>"},{"location":"reference/metrics/kumod/total_readyq_runs/","title":"total_readyq_runs","text":"<p><pre><code>Type: Counter\n</code></pre> total number of times a readyq maintainer was run.</p>"},{"location":"reference/metrics/kumod/user_lua_latency/","title":"user_lua_latency","text":"<p><pre><code>Type: Histogram\nLabels: label\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds something user-defined took to run in your lua policy.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This histogram is updated by policy scripts that employ the kumo.time.start_timer function to record a duration in the policy.</p> <p>The <code>label</code> is whatever you specified as the label(s) to the various <code>kumo.time.start_timer</code> calls in the policy.</p>"},{"location":"reference/metrics/kumod/user_lua_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>user_lua_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>user_lua_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>user_lua_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>user_lua_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>user_lua_latency</code> by computing <code>user_lua_latency_sum / user_lua_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/proxy-server/","title":"proxy-server Metrics","text":"<ul> <li>disk_free_bytes</li> <li>disk_free_inodes</li> <li>disk_free_inodes_percent</li> <li>disk_free_percent</li> <li>dns_mx_resolve_cache_hit</li> <li>dns_mx_resolve_cache_miss</li> <li>dns_mx_resolve_in_progress</li> <li>dns_mx_resolve_status_fail</li> <li>dns_mx_resolve_status_ok</li> <li>lruttl_cache_size</li> <li>lruttl_error_count</li> <li>lruttl_evict_count</li> <li>lruttl_expire_count</li> <li>lruttl_hit_count</li> <li>lruttl_insert_count</li> <li>lruttl_lookup_count</li> <li>lruttl_miss_count</li> <li>lruttl_populated_count</li> <li>lruttl_stale_count</li> <li>lruttl_waiting_populate</li> <li>lua_count</li> <li>lua_event_latency</li> <li>lua_event_started</li> <li>lua_load_count</li> <li>lua_spare_count</li> <li>memoize_cache_hit_count</li> <li>memoize_cache_lookup_count</li> <li>memoize_cache_miss_count</li> <li>memoize_cache_populated_count</li> <li>memory_limit</li> <li>memory_low_count</li> <li>memory_low_thresh</li> <li>memory_over_limit_count</li> <li>memory_usage</li> <li>memory_usage_rust</li> <li>process_cpu_usage_normalized</li> <li>process_cpu_usage_sum</li> <li>proxy_active_connections</li> <li>proxy_bytes_client_to_dest_total</li> <li>proxy_bytes_dest_to_client_total</li> <li>proxy_connections_accepted_total</li> <li>proxy_connections_completed_total</li> <li>proxy_connections_failed_total</li> <li>proxy_outbound_connections_total</li> <li>proxy_tls_handshake_failures_total</li> <li>redis_operation_latency</li> <li>system_cpu_usage_normalized</li> <li>system_cpu_usage_sum</li> <li>thread_pool_parked</li> <li>thread_pool_size</li> <li>user_lua_latency</li> </ul>"},{"location":"reference/metrics/proxy-server/disk_free_bytes/","title":"disk_free_bytes","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> number of available bytes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/disk_free_inodes/","title":"disk_free_inodes","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> number of available inodes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/disk_free_inodes_percent/","title":"disk_free_inodes_percent","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> percentage of available inodes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/disk_free_percent/","title":"disk_free_percent","text":"<p><pre><code>Type: Gauge\nLabels: name\n</code></pre> percentage of available bytes in a monitored location.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/dns_mx_resolve_cache_hit/","title":"dns_mx_resolve_cache_hit","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of MailExchanger::resolve calls satisfied by level 1 cache.</p> <p>Redundant with the newer lruttl_hit_count{cache_name=\"dns_resolver_mx\"} metric.</p>"},{"location":"reference/metrics/proxy-server/dns_mx_resolve_cache_miss/","title":"dns_mx_resolve_cache_miss","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of MailExchanger::resolve calls that resulted in an MX DNS request to the next level of cache.</p> <p>Redundant with the newer lruttl_miss_count{cache_name=\"dns_resolver_mx\"} metric.</p>"},{"location":"reference/metrics/proxy-server/dns_mx_resolve_in_progress/","title":"dns_mx_resolve_in_progress","text":"<p><pre><code>Type: Gauge\n</code></pre> number of <code>MailExchanger::resolve</code> calls currently in progress.</p>"},{"location":"reference/metrics/proxy-server/dns_mx_resolve_status_fail/","title":"dns_mx_resolve_status_fail","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of failed <code>MailExchanger::resolve</code> calls.</p> <p>Spikes may indicate an issue with your DNS configuration or infrastructure, or may simply indicate that the traffic is destined for bogus addresses.</p>"},{"location":"reference/metrics/proxy-server/dns_mx_resolve_status_ok/","title":"dns_mx_resolve_status_ok","text":"<p><pre><code>Type: Counter\n</code></pre> Total number of successful <code>MailExchanger::resolve</code> calls.</p>"},{"location":"reference/metrics/proxy-server/lruttl_cache_size/","title":"lruttl_cache_size","text":"<p><pre><code>Type: Gauge\nLabels: cache_name\n</code></pre> The number of items currently contained in an lruttl cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_error_count/","title":"lruttl_error_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache population resulted in an error.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_evict_count/","title":"lruttl_evict_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache evicted an item due to capacity constraints.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_expire_count/","title":"lruttl_expire_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache removed an item due to ttl expiration.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_hit_count/","title":"lruttl_hit_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache lookup was a hit for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_insert_count/","title":"lruttl_insert_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache was populated via unconditional insert.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_lookup_count/","title":"lruttl_lookup_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a lruttl cache lookup was initiated for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_miss_count/","title":"lruttl_miss_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache lookup was a miss for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_populated_count/","title":"lruttl_populated_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache lookup resulted in performing the work to populate the entry.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_stale_count/","title":"lruttl_stale_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> how many times a lruttl cache population was satisfied by a stale value.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lruttl_waiting_populate/","title":"lruttl_waiting_populate","text":"<p><pre><code>Type: Gauge\nLabels: cache_name\n</code></pre> how many tasks are currently waiting for a cache entry to populate.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>The <code>cache_name</code> label identifies which cache.  See kumo.set_lruttl_cache_capacity for a list of caches.</p>"},{"location":"reference/metrics/proxy-server/lua_count/","title":"lua_count","text":"<p><pre><code>Type: Gauge\n</code></pre> the number of lua contexts currently alive.</p>"},{"location":"reference/metrics/proxy-server/lua_event_latency/","title":"lua_event_latency","text":"<p><pre><code>Type: Histogram\nLabels: event\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> how long a given lua event callback took.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/lua_event_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>lua_event_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>lua_event_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>lua_event_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>lua_event_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>lua_event_latency</code> by computing <code>lua_event_latency_sum / lua_event_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/proxy-server/lua_event_started/","title":"lua_event_started","text":"<p><pre><code>Type: Counter\nLabels: event\n</code></pre> Incremented each time we start to call a lua event callback. Use lua_event_latency_count to track completed events.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/lua_load_count/","title":"lua_load_count","text":"<p><pre><code>Type: Counter\n</code></pre> how many times the policy lua script has been loaded into a new context.</p>"},{"location":"reference/metrics/proxy-server/lua_spare_count/","title":"lua_spare_count","text":"<p><pre><code>Type: Gauge\n</code></pre> the number of lua contexts available for reuse in the pool.</p>"},{"location":"reference/metrics/proxy-server/memoize_cache_hit_count/","title":"memoize_cache_hit_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup was a hit for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_hit_count metric.</p>"},{"location":"reference/metrics/proxy-server/memoize_cache_lookup_count/","title":"memoize_cache_lookup_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup was initiated for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_lookup_count metric.</p>"},{"location":"reference/metrics/proxy-server/memoize_cache_miss_count/","title":"memoize_cache_miss_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup was a miss for a given cache.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_miss_count metric.</p>"},{"location":"reference/metrics/proxy-server/memoize_cache_populated_count/","title":"memoize_cache_populated_count","text":"<p><pre><code>Type: Counter\nLabels: cache_name\n</code></pre> How many times a memoize cache lookup resulted in performing the work to populate the entry.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>Redundant with the newer lruttl_populated_count metric.</p>"},{"location":"reference/metrics/proxy-server/memory_limit/","title":"memory_limit","text":"<p><pre><code>Type: Gauge\n</code></pre> soft memory limit measured in bytes.</p>"},{"location":"reference/metrics/proxy-server/memory_low_count/","title":"memory_low_count","text":"<p><pre><code>Type: Counter\n</code></pre> How many times the low memory threshold was exceeded.</p>"},{"location":"reference/metrics/proxy-server/memory_low_thresh/","title":"memory_low_thresh","text":"<p><pre><code>Type: Gauge\n</code></pre> low memory threshold measured in bytes.</p>"},{"location":"reference/metrics/proxy-server/memory_over_limit_count/","title":"memory_over_limit_count","text":"<p><pre><code>Type: Counter\n</code></pre> how many times the soft memory limit was exceeded.</p>"},{"location":"reference/metrics/proxy-server/memory_usage/","title":"memory_usage","text":"<p><pre><code>Type: Gauge\n</code></pre> number of bytes of used memory (Resident Set Size).</p>"},{"location":"reference/metrics/proxy-server/memory_usage_rust/","title":"memory_usage_rust","text":"<p><pre><code>Type: Gauge\n</code></pre> number of bytes of used memory (allocated by Rust).</p>"},{"location":"reference/metrics/proxy-server/process_cpu_usage_normalized/","title":"process_cpu_usage_normalized","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the process CPU usage for each CPU in the system, divided by the number of CPUs.</p> <p>100% in this metric indicates that all CPU cores are 100% busy.</p> <p>This metric is scoped to the service process, reflecting the CPU used only by the process and not the system as a whole.</p>"},{"location":"reference/metrics/proxy-server/process_cpu_usage_sum/","title":"process_cpu_usage_sum","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the process CPU usage for each CPU in the system, can add up to more than 100%.</p> <p>Each CPU has a value from 0-100% busy; a value of 100% in this metric indicates that the load is equivalent to one fully utilized CPU.</p> <p>A multi-CPU system can report more than 100% in this metric; a dual-CPU system reporting 200% indicates that both CPUs are fully utilized.</p> <p>See process_cpu_usage_normalized for a version of this metric that scales from 0% (totally idle) to 100% (totally saturated).</p> <p>This metric is scoped to the service process, reflecting the CPU used only by the process and not the system as a whole.</p>"},{"location":"reference/metrics/proxy-server/proxy_active_connections/","title":"proxy_active_connections","text":"<p><pre><code>Type: Gauge\nLabels: listener\n</code></pre> Current number of active proxy connections.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This gauge shows the number of connections currently being proxied. It increments when a connection is accepted and decrements when the connection closes (successfully or with error).</p>"},{"location":"reference/metrics/proxy-server/proxy_bytes_client_to_dest_total/","title":"proxy_bytes_client_to_dest_total","text":"<p><pre><code>Type: Counter\nLabels: listener\n</code></pre> Total bytes transferred from client to destination.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter tracks the total number of bytes flowing from proxy clients to their intended destinations (upstream direction).</p>"},{"location":"reference/metrics/proxy-server/proxy_bytes_dest_to_client_total/","title":"proxy_bytes_dest_to_client_total","text":"<p><pre><code>Type: Counter\nLabels: listener\n</code></pre> Total bytes transferred from destination to client.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter tracks the total number of bytes flowing from destinations back to proxy clients (downstream direction).</p>"},{"location":"reference/metrics/proxy-server/proxy_connections_accepted_total/","title":"proxy_connections_accepted_total","text":"<p><pre><code>Type: Counter\nLabels: listener\n</code></pre> Total number of incoming connections accepted by the proxy.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter increments each time a new client connection is accepted by a proxy listener, before any SOCKS5 handshake begins.</p>"},{"location":"reference/metrics/proxy-server/proxy_connections_completed_total/","title":"proxy_connections_completed_total","text":"<p><pre><code>Type: Counter\nLabels: listener\n</code></pre> Total number of proxy sessions that completed successfully.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter increments when a proxy session completes without error, meaning the client connected, was proxied to the destination, and both sides closed cleanly.</p>"},{"location":"reference/metrics/proxy-server/proxy_connections_failed_total/","title":"proxy_connections_failed_total","text":"<p><pre><code>Type: Counter\nLabels: listener\n</code></pre> Total number of connections that failed during handshake or proxying.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter increments when a connection fails due to handshake errors, authentication failures, timeouts, or I/O errors during proxying.</p>"},{"location":"reference/metrics/proxy-server/proxy_outbound_connections_total/","title":"proxy_outbound_connections_total","text":"<p><pre><code>Type: Counter\nLabels: listener, destination\n</code></pre> Total number of outbound connections made to destinations.</p> <p>Note</p> <p>This metric is subject to pruning, which means that it may age out and reset to zero when the corresponding internal resources idle- or age-out of the system.  This is a memory management measure to prevent otherwise unbounded growth of memory over time.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter tracks connections by destination IP address. Note: This can create high cardinality if your proxy connects to many unique destinations. The metric uses a pruning counter registry to mitigate memory impact.</p>"},{"location":"reference/metrics/proxy-server/proxy_tls_handshake_failures_total/","title":"proxy_tls_handshake_failures_total","text":"<p><pre><code>Type: Counter\nLabels: listener\n</code></pre> Total number of TLS handshake failures.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This counter increments when TLS is enabled on a listener and the TLS handshake with a client fails.</p>"},{"location":"reference/metrics/proxy-server/redis_operation_latency/","title":"redis_operation_latency","text":"<p><pre><code>Type: Histogram\nLabels: service, operation, status\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> The latency of an operation talking to Redis.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>The <code>service</code> key represents the redis server/service. It is not a direct match to a server name as it is really a hash of the overall redis configuration information used in the client. It might look something like: <code>redis://127.0.0.1:24419,redis://127.0.0.1:7779,redis://127.0.0.1:29469-2ce79dd1</code> for a cluster configuration, or <code>redis://127.0.0.1:16267-f4da6e64</code> for a single node cluster configuration. You should anticipate that the <code>-HEX</code> suffix can and will change in an unspecified way as you vary the redis connection parameters.</p> <p>The <code>operation</code> key indicates the operation, which can be a <code>ping</code>, a <code>query</code> or a <code>script</code>.</p> <p><code>status</code> will be either <code>ok</code> or <code>error</code> to indicate whether this is tracking a successful or failed operation.</p> <p>Since histograms track a count of operations, you can track the rate of <code>redis_operation_latency_count</code> where <code>status=error</code> to have an indication of the failure rate of redis operations.</p>"},{"location":"reference/metrics/proxy-server/redis_operation_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>redis_operation_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>redis_operation_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>redis_operation_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>redis_operation_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>redis_operation_latency</code> by computing <code>redis_operation_latency_sum / redis_operation_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/metrics/proxy-server/system_cpu_usage_normalized/","title":"system_cpu_usage_normalized","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the system-wide CPU usage for each CPU in the system, divided by the number of CPUs.</p> <p>100% in this metric indicates that all CPU cores are 100% busy.</p> <p>This metric is scoped to the system, reflecting the total load on the system, not just from the kumo related process(es).</p>"},{"location":"reference/metrics/proxy-server/system_cpu_usage_sum/","title":"system_cpu_usage_sum","text":"<p><pre><code>Type: Gauge\n</code></pre> The sum of the system-wide CPU usage for each CPU in the system, can add up to more than 100%.</p> <p>Each CPU has a value from 0-100% busy; a value of 100% in this metric indicates that the load is equivalent to one fully utilized CPU.</p> <p>A multi-CPU system can report more than 100% in this metric; a dual-CPU system reporting 200% indicates that both CPUs are fully utilized.</p> <p>See system_cpu_usage_normalized for a version of this metric that scales from 0% (totally idle) to 100% (totally saturated).</p> <p>This metric is scoped to the system, reflecting the total load on the system, not just from the kumo related process(es).</p>"},{"location":"reference/metrics/proxy-server/thread_pool_parked/","title":"thread_pool_parked","text":"<p><pre><code>Type: Gauge\nLabels: pool\n</code></pre> number of parked (idle) threads in a thread pool.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/thread_pool_size/","title":"thread_pool_size","text":"<p><pre><code>Type: Gauge\nLabels: pool\n</code></pre> number of threads in a thread pool.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p>"},{"location":"reference/metrics/proxy-server/user_lua_latency/","title":"user_lua_latency","text":"<p><pre><code>Type: Histogram\nLabels: label\nBuckets: 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0\n</code></pre> How many seconds something user-defined took to run in your lua policy.</p> <p>Info</p> <p>This metric has labels which means that the system will track the metric for each combination of the possible labels that are active.  Certain labels, especially those that correlate with source or destination addresses or domains, can have high cardinality.  High cardinality metrics may require some care and attention when provisioning a downstream metrics server.</p> <p>This histogram is updated by policy scripts that employ the kumo.time.start_timer function to record a duration in the policy.</p> <p>The <code>label</code> is whatever you specified as the label(s) to the various <code>kumo.time.start_timer</code> calls in the policy.</p>"},{"location":"reference/metrics/proxy-server/user_lua_latency/#histogram","title":"Histogram","text":"<p>This metric is a histogram which means that it is exported as three underlying metrics:</p> <ul> <li><code>user_lua_latency_count</code> - a counter tracking how many events have been accumulated into the histogram</li> <li><code>user_lua_latency_sum</code> - a counter tracking the total value of all of the events have been accumulated into the histogram</li> <li><code>user_lua_latency_bucket</code> - a counter tracking the number of events that fall within the various buckets shown above.  This counter has an additional <code>le</code> label that indicates the bucket threshold.  For example, the first bucket for this histogram will generate a label <code>le=\"0.005\"</code> which will keep track of the number of events whose value was less-or-equal (le) that value.</li> </ul> <p>The recommended visualization for a histogram is a heatmap based on <code>user_lua_latency_bucket</code>.</p> <p>While it is possible to calculate a mean average for <code>user_lua_latency</code> by computing <code>user_lua_latency_sum / user_lua_latency_count</code>, it can be difficult to reason about what that value means if the traffic patterns are not uniform since the launch of the process.  We strongly recommend using a heatmap visualization instead of computing an average value.</p>"},{"location":"reference/mimepart/","title":"The MimePart Object","text":"<p>A <code>MimePart</code> object represents the parsed MIME structure of an RFC 5322 formatted message.  Complex messages form a tree that is composed of various <code>MimeParts</code> and there are multiple different ways to build a MIME tree to, for example, represent a message with a single attachment.</p> <p><code>MimePart</code> is the name of the underlying Rust type, but it is exposed through to lua via a <code>PartRef</code> that acts as a handle to the <code>MimePart</code> that allows safely modifying the MIME structure.</p> <p>There are few different ways to obtain a <code>MimePart</code>:</p> <ul> <li>By parsing it from a <code>Message</code> object via msg:parse_mime</li> <li>By creating parts using the kumo.mimepart module</li> </ul> <p>Info</p> <p>Printing or otherwise explicitly converting a <code>MimePart</code> object as a string will produce the RFC 5322 representation of that MimePart and its children.</p>"},{"location":"reference/mimepart/append_part/","title":"append_part","text":"<pre><code>mimepart:append_part(PART)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>Appends <code>PART</code>, which must also be a MimePart (perhaps created via kumo.mimpart.new_text or similar) to the set of child parts in <code>mimepart</code>.</p> <p>This is potentially useful when constructing complex multipart messages.  You are responsible for ensuring that the resulting mime tree makes logical sense; <code>mimepart</code> should have a <code>Content-Type</code> that is recognized as being a multipart container of some kind.</p> <p>You might consider instead using kumo.mimepart.builder for a simpler message building experience.</p>"},{"location":"reference/mimepart/body/","title":"body","text":"<pre><code>local content = mimepart.body\nmimepart.body = 'changed content'\n</code></pre> <p>Note</p> <p>This is a field rather than a method, so you must use <code>mimepart.body</code> rather than <code>mimepart:body</code> to reference it.</p> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>The <code>body</code> field allows reading or writing the transfer-decoded content of the <code>mimepart</code>.  For example, if the incoming message has <code>base64</code> encoded the content and applied a <code>Content-Transfer-Encoding</code> header on the part to indicate that it is base64 encoded, <code>mimepart.body</code> will base64-decode the content before returning the bytes to your code.</p> <p>If/when you assign the <code>body</code> field, appropriate transfer encoding will be applied to the raw content that you provide.</p> <p>Note</p> <p>Replacing the content doesn't implicitly change the <code>Content-Type</code> of the part, so you are responsible for ensuring that any modification you make to the part keeps the resulting message logically correct.  See also mimepart:replace_body for a variation of this that allows you to change the <code>Content-Type</code> as part of the assignment.</p>"},{"location":"reference/mimepart/get_simple_structure/","title":"get_simple_structure","text":"<pre><code>local structure = mimepart:get_simple_structure()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>A MIME message is an encoding of a tree of pieces of content which makes things relatively complex to script around in various processing work flows, especially because there can be multiple ways to encode similar information that result in different tree structures.</p> <p>This method will walk the tree structure starting from <code>mimepart</code> and collect together the main points of interest, returning a lua table holding that simplified and flattened view.  The following fields are present in the simplified structure:</p> <ul> <li><code>text_part</code> - The first <code>text/plain</code> MimePart found in the walk, if any.</li> <li><code>html_part</code> - The first <code>text/html</code> MimePart found in the walk, if any.</li> <li><code>header_part</code> - The \"main\" part from the perspective of header analysis</li> <li><code>attachments</code> - An array style table holding a list of all the attachments.</li> <li><code>amp_html_part</code> - The first <code>text/x-amp-html</code> MimePart found in the walk, if any. (Since: Dev Builds Only)</li> </ul> <p>Each attachment table entry has the following fields:</p> <ul> <li><code>file_name</code> - The suggested name to use when saving the attachment. If the     <code>Content-Disposition</code> header defined the file name, then that will be used.     Otherwise, the <code>Content-Type</code> <code>name</code> parameter will be used. If neither is     present, then the <code>file_name</code> field will not be set (effectively <code>nil</code>).</li> <li><code>inline</code> - will be <code>true</code> if the attachment was marked as having an inline     disposition, <code>false</code> otherwise.</li> <li><code>content_id</code> - if the <code>Content-ID</code> header is defined, this field will hold     its value.</li> <li><code>part</code> - the MimePart for the attachment.  You can use this to     access its body (eg: mimepart.body or headers.</li> </ul>"},{"location":"reference/mimepart/get_simple_structure/#example-of-modifying-incoming-message-content","title":"Example of modifying incoming message content","text":"<p>This example prepends text to both the text and html parts of incoming messages:</p> <pre><code>kumo.on('smtp_server_message_received', function(message, conn_meta)\n  local mime_part = message:parse_mime()\n  local structure = mime_part:get_simple_structure()\n\n  if structure.text_part then\n    structure.text_part.body = 'PREPENDED!\\r\\n' .. structure.text_part.body\n  end\n\n  if structure.html_part then\n    structure.html_part.body = '&lt;B&gt;PREPENDED!&lt;/B&gt;\\r\\n'\n      .. structure.html_part.body\n  end\n\n  -- Apply the changed content to the message\n  message:set_data(tostring(mime_part))\nend)\n</code></pre>"},{"location":"reference/mimepart/get_simple_structure/#example-of-dumping-incoming-attachments","title":"Example of dumping incoming attachments","text":"<p>This example logs the attachment information and contents during reception. It is not recommended for production workflows, as the contents can be large and unsuitable for capture in the diagnostic log, but can be helpful in some debugging scenarios.</p> <pre><code>kumo.on('smtp_server_message_received', function(message, conn_meta)\n  local mime_part = message:parse_mime()\n  local structure = mime_part:get_simple_structure()\n\n  for _, attachment in ipairs(structure.attachments) do\n    print(attachment.file_name, attachment.content_type, attachment.part.body)\n  end\nend)\n</code></pre>"},{"location":"reference/mimepart/headers/","title":"headers","text":"<pre><code>local headers = mimepart.headers\n</code></pre> <p>Note</p> <p>This is a field rather than a method, so you must use <code>mimepart.headers</code> rather than <code>mimepart:headers</code> to reference it.</p> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>The <code>headers</code> field returns a reference to the HeaderMap for <code>mimepart</code>.  You can use the headermap to enumerate or modify the set of headers in the mime part.</p> <p>The example below prints the <code>Subject</code> header of the mime part:</p> <pre><code>local subject = mimepart.headers:subject()\nprint(subject)\n</code></pre>"},{"location":"reference/mimepart/id/","title":"id","text":"<pre><code>local id = mimepart.id\n</code></pre> <p>Note</p> <p>This is a field rather than a method, so you must use <code>mimepart.id</code> rather than <code>mimepart:id</code> to reference it.</p> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>The <code>id</code> field represents the position of the part within the mime tree at the time that it was parsed from its containing message.</p> <p>This has very limited use at the current time.</p>"},{"location":"reference/mimepart/rebuild/","title":"rebuild","text":"<pre><code>local rebuilt = mimepart:rebuild()\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p><code>mimepart:rebuild()</code> will return a new, distinct, mimepart by interpreting <code>mimepart</code> and extracting all of the key features and building up the new mime part from that information.</p> <p>This is equivalent to the \"fix\" performed by message:check_fix_conformance except that it does NOT modify the part in-place.</p> <p>Warning</p> <p>Rebuilding messages with this method is inherently imperfect: it is based on a deliberately relaxed interpretation of the message content and it is possible, or even likely, that non-conforming input is parsed in a way that results in omitting certain details from the original input.</p> <p>The purpose of this method is as a best-effort convenience for correcting minor and obviously recognizable issues that cannot easily be resolved at the message generation stage.</p> <p>It is recommended that you carefully evaluate the effects of this method before deploying it in production.</p> <p>The example below is purely demonstrative, and it is NOT recommended to be used in production.  It is equivalent to the fixing portion of the example found in message:check_fix_conformance, but unconditionally rebuilds every message.  It is almost certainly undesirable to run this for any real workload.</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  local mimepart = msg:parse_mime()\n  msg:set_data(tostring(mimepart:rebuild()))\nend)\n</code></pre>"},{"location":"reference/mimepart/replace_body/","title":"replace_body","text":"<pre><code>mimepart:replace_body(CONTENT, OPTIONAL_CONTENT_TYPE)\n</code></pre> Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>This method allows you to change the body portion of the <code>mimepart</code>, optionally changing the <code>Content-Type</code> in the process.</p> <p><code>CONTENT</code> must be a lua string (either UTF-8 or binary) representing the actual content you want to assign; <code>mimepart:replace_body</code> will select and apply appropriate transfer encoding to the mime part.</p> <p><code>OPTIONAL_CONTENT_TYPE</code> is an optional string specifying the content type. If omitted, if the part already has a content type, that content type will be preserved. Otherwise, if there is no content type, a default content type will be selected based on the binary or text nature of <code>CONTENT</code>.</p> <p>The example below unilaterally changes the body of a mime part to plain text:</p> <pre><code>mimepart:replace_body('changed content', 'text/plain')\n</code></pre> <p>See also:</p> <ul> <li>mimepart.body</li> </ul>"},{"location":"reference/policy-extras.mail_auth/","title":"Mail Authentication","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The mail authentication helper module provides functions to assist in performing email message authentication checks.</p> <pre><code>local mail_auth = require 'policy-extras.mail_auth'\n</code></pre>"},{"location":"reference/policy-extras.mail_auth/check/","title":"check","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local mail_auth = require 'policy-extras.mail_auth'\nlocal check_result = mail_auth.check(MSG, OPT_CONFIG)\n</code></pre> <p>The <code>mail_auth.check</code> function performs a bundle of standard authentication checks, collecting together the authentication results.</p> <p>There are no policy decisions encoded within the check; the various checks are carried out with their status reported in the returned object.  It up to you to interpret the results and apply your policy based on those results.</p> <p>The parameters are:</p> <ul> <li><code>MSG</code> - a required Message object to be checked</li> <li><code>OPT_CONFIG</code> - an optional configuration object described below</li> </ul> <p>The optional configuration object is an object style lua table with the following fields; all fields are optional:</p> <ul> <li><code>dkim</code> - a boolean, which defaults to <code>true</code>, indicating whether    msg:dkim_verify should be called and the    results collected.</li> <li><code>spf</code> - a boolean, which defaults to <code>true</code>, indicating whether    kumo.spf.check_msg should be called and the    result collected.</li> <li><code>iprev</code> - a boolean, which defaults to <code>true</code>, indicating whether    policy-extras.mail_auth.iprev_msg should be called and    the result collected.</li> <li><code>smtp_auth</code> - a boolean, which defaults to <code>true</code>, indicating whether    the SMTP    authentication    status should be collected</li> <li><code>dmarc</code> - a boolean, which defaults to <code>true</code>, indicating whether DMARC    result should be collected.</li> <li><code>arc</code> - a boolean, which defaults to <code>true</code>, indicating whether    msg:arc_verify should be called and the result    collected.</li> <li><code>add_authentication_results</code> - a boolean, which defaults to <code>true</code>, indicating    whether the aggregated authentication results performed by <code>check</code> should be    added to the message as an    Authentication-Results    header via msg:add_authentication_results.</li> <li><code>server_id</code> - a string which specifies the <code>server_id</code> parameter that should be    passed to msg:add_authentication_results    when <code>add_authentication_results</code> is enabled.  If you do not specify <code>server_id</code>    then the <code>hostname</code> metadata value will be extracted from the <code>MSG</code>.</li> <li><code>resolver</code> - a string corresponding to the name of a resolver defined via    kumo.dns.define_resolver for more advanced    use cases.  The default behavior is to use the overall KumoMTA DNS resolver    configuration.</li> </ul> <p>The return value of <code>mail_auth.check</code> is an object with the following fields:</p> <ul> <li><code>dkim</code> - an array style table holding the list of DKIM    authenticationresults, one for each signature,    or a single one indicating that there was no signature.  If <code>OPT_CONFIG.dkim    == false</code> then this field will be absent.</li> <li><code>spf</code> - The authenticationresult produced by    the spf check.  If <code>OPT_CONFIG.spf == false</code> then this field will be absent.</li> <li><code>iprev</code> - The authenticationresult produced by    the iprev check.  If <code>OPT_CONFIG.iprev == false</code> then this field will be absent.</li> <li><code>smtp_auth</code> - The authenticationresult produced by    the SMTP authentication check.  If <code>OPT_CONFIG.smtp_auth == false</code> then this    field will be absent.</li> <li><code>dmarc</code> - The authenticationresult produced by    the DMARC check.  If <code>OPT_CONFIG.dmarc == false</code> then this field will be absent.</li> <li><code>arc</code> - The authenticationresult produced by    the ARC check.  If <code>OPT_CONFIG.arc == false</code> then this field will be absent.</li> <li><code>auth_results</code> - An array style table holding the list of all    authenticationresults produced by the checks    that we carried out.  This is useful to pass onwards to    msg:arc_seal.</li> </ul>"},{"location":"reference/policy-extras.mail_auth/check/#example","title":"Example","text":"<pre><code>local mail_auth = require 'policy-extras.mail_auth'\n\nkumo.on('smtp_server_message_received', function(msg, conn_meta)\n  -- Perform checks, an annotate the message with an Authentication-Results header\n  local check_result = mail_auth.check(msg)\n\n  -- You could pass on check_result.auth_results to msg:arc_seal here if\n  -- you are signing and sealing messages with ARC\nend)\n</code></pre>"},{"location":"reference/policy-extras.mail_auth/iprev/","title":"iprev","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local mail_auth = require 'policy-extras.mail_auth'\nlocal auth_result = mail_auth.iprev(IP)\n</code></pre> <p>The <code>mail_auth.iprev</code> function performs the <code>iprev</code> authentication method as specified by RFC8601 Section 3, and returns an AuthenticationResult representing the status of the check.</p> <p>The <code>IP</code> parameter is a string representation of the IP address; for example, <code>\"127.0.0.1\"</code> for an IPv4 address of <code>\"::1\"</code> for an IPv6 address.</p> <p>See mail_auth.iprev_msg for a version of this check at accepts a Message object instead.</p>"},{"location":"reference/policy-extras.mail_auth/iprev_msg/","title":"iprev_msg","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <pre><code>local mail_auth = require 'policy-extras.mail_auth'\nlocal auth_result = mail_auth.iprev(MSG)\n</code></pre> <p>The <code>mail_auth.iprev</code> function performs the <code>iprev</code> authentication method as specified by RFC8601 Section 3, and returns an AuthenticationResult representing the status of the check.</p> <p>The <code>MSG</code> parameter is a Message object.</p> <p>See mail_auth.iprev for a version of this check at accepts an IP address without needing a message object.</p>"},{"location":"reference/proxy/","title":"proxy","text":"<p>The <code>proxy</code> module provides HTTP metrics and administration endpoints for the KumoProxy server.</p> <pre><code>local proxy = require 'proxy'\n</code></pre> <p>Note</p> <p>This module is only available to the <code>proxy-server</code> executable.</p> <p>These functions should be called from inside your proxy_init event handler.</p>"},{"location":"reference/proxy/start_http_listener/","title":"proxy.start_http_listener","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>proxy.start_http_listener { PARAMS }\n</code></pre> <p>Configure and start an HTTP service for the proxy server.</p> <p>Note</p> <p>This function is only available to the <code>proxy-server</code> executable.</p> <p>This function should be called only from inside your proxy_init event handler.</p> <p>The HTTP listener provides access to Prometheus-compatible metrics for monitoring the proxy server, including connection counts, bytes transferred, and active connections.</p> <pre><code>local kumo = require 'kumo'\nlocal proxy = require 'proxy'\n\nkumo.on('proxy_init', function()\n  -- Start the SOCKS5 proxy\n  proxy.start_proxy_listener {\n    listen = '0.0.0.0:1080',\n  }\n\n  -- Start the HTTP listener for metrics\n  proxy.start_http_listener {\n    listen = '0.0.0.0:8080',\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\nend)\n</code></pre>"},{"location":"reference/proxy/start_http_listener/#parameters","title":"Parameters","text":"<p><code>PARAMS</code> accepts the same keys as kumo.start_http_listener.</p>"},{"location":"reference/proxy/start_http_listener/#available-endpoints","title":"Available Endpoints","text":"<p>The HTTP listener exposes the following endpoints:</p> Endpoint Description <code>/metrics</code> Prometheus-compatible metrics in text format <code>/metrics.json</code> Metrics in JSON format <code>/proxy/status</code> Simple health check endpoint <code>/api/admin/set_diagnostic_log_filter/v1</code> Runtime log filter adjustment <code>/rapidoc</code> Interactive API documentation <code>/api-docs/openapi.json</code> OpenAPI specification"},{"location":"reference/proxy/start_http_listener/#metrics","title":"Metrics","text":"<p>The proxy server exposes Prometheus-compatible metrics for monitoring. All metrics are automatically documented via the <code>declare_metric!</code> macro.</p> <p>The metrics include: - <code>proxy_connections_accepted_total</code> - Total incoming connections accepted by the proxy - <code>proxy_connections_failed_total</code> - Connections that failed during handshake or proxying - <code>proxy_connections_completed_total</code> - Proxy sessions that completed successfully - <code>proxy_active_connections</code> - Current number of active proxy connections - <code>proxy_bytes_client_to_dest_total</code> - Total bytes transferred from client to destination - <code>proxy_bytes_dest_to_client_total</code> - Total bytes transferred from destination to client - <code>proxy_outbound_connections_total</code> - Outbound connections made to destinations - <code>proxy_tls_handshake_failures_total</code> - TLS handshake failures</p> <p>Access these metrics via the <code>/metrics</code> endpoint in Prometheus text format or <code>/metrics.json</code> for JSON format.</p>"},{"location":"reference/proxy/start_http_listener/#api-documentation","title":"API Documentation","text":"<p>The HTTP listener automatically provides an OpenAPI specification at <code>/api-docs/openapi.json</code> and interactive documentation at <code>/rapidoc</code>.</p> <p>You can also generate the OpenAPI spec by running:</p> <pre><code>proxy-server --dump-openapi-spec &gt; proxy-server.openapi.json\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/","title":"proxy.start_proxy_listener","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <pre><code>proxy.start_proxy_listener { PARAMS }\n</code></pre> <p>Configure and start a SOCKS5 proxy server.</p> <p>Note</p> <p>This function is only available to the <code>proxy-server</code> executable.</p> <p>This function should be called only from inside your proxy_init event handler.</p> <p>The proxy server implements the SOCKS5 protocol and can be used by KumoMTA's egress sources to route outbound connections through the proxy. This is useful for scenarios where you need to control the egress IP address or route traffic through specific network paths.</p> <pre><code>kumo.on('proxy_init', function()\n  proxy.start_proxy_listener {\n    listen = '0.0.0.0:1080',\n  }\nend)\n</code></pre> <p>To enable TLS and authentication:</p> <pre><code>kumo.on('proxy_init', function()\n  proxy.start_proxy_listener {\n    listen = '0.0.0.0:1080',\n    use_tls = true,\n    tls_certificate = '/path/to/cert.pem',\n    tls_private_key = '/path/to/key.pem',\n    require_auth = true,\n  }\nend)\n\nkumo.on('proxy_server_auth_rfc1929', function(username, password, conn_meta)\n  -- Validate credentials here\n  return username == 'user' and password == 'secret'\nend)\n</code></pre> <p><code>PARAMS</code> is a lua table that can accept the keys listed below:</p>"},{"location":"reference/proxy/start_proxy_listener/hostname/","title":"hostname","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Specifies the hostname to use when generating a self-signed TLS certificate.</p> <p>The default is the system hostname.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_tls = true,\n  hostname = 'proxy.example.com',\n}\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/listen/","title":"listen","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Specifies the local IP and port number to which the proxy service should bind and listen.</p> <p>Use <code>0.0.0.0</code> to bind to all IPv4 addresses.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n}\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/require_auth/","title":"require_auth","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>If true, the proxy server will require RFC 1929 username/password authentication from clients before allowing them to use the proxy.</p> <p>When enabled, you must also register a handler for the proxy_server_auth_rfc1929 event to validate credentials.</p> <p>The default is <code>false</code> which allows clients to optionally authenticate.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  require_auth = true,\n}\n\nkumo.on('proxy_server_auth_rfc1929', function(username, password, conn_meta)\n  -- Validate credentials\n  return username == 'user' and password == 'secret'\nend)\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/timeout/","title":"timeout","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Specifies the connection timeout duration. If a client does not complete the SOCKS5 handshake or send data within this duration, the connection will be closed.</p> <p>The default is 60 seconds.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  timeout = '30 seconds',\n}\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/tls_certificate/","title":"tls_certificate","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Specify the path to a TLS certificate file to use for the server identity when use_tls is set to <code>true</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_tls = true,\n  tls_certificate = '/path/to/cert.pem',\n}\n</code></pre> <p>You may specify that the certificate be loaded from a HashiCorp Vault:</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_tls = true,\n  tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/proxy.example.com.cert',\n  },\n}\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/tls_private_key/","title":"tls_private_key","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>Specify the path to a TLS private key file to use for the server identity when use_tls is set to <code>true</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_tls = true,\n  tls_private_key = '/path/to/key.pem',\n}\n</code></pre> <p>You may specify that the key be loaded from a HashiCorp Vault:</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_tls = true,\n  tls_private_key = {\n    vault_mount = 'secret',\n    vault_path = 'tls/proxy.example.com.key',\n  },\n}\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/use_splice/","title":"use_splice","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>On Linux, the proxy server uses <code>splice(2)</code> for efficient zero-copy data transfer between the client and remote connections. This can significantly reduce CPU usage for high-throughput proxy scenarios.</p> <p>Set this to <code>false</code> to disable splice and use regular userspace copying instead.  This may be useful for debugging or if you encounter issues with splice on your system.</p> <p>The default is <code>true</code> (splice is enabled on Linux).</p> <p>Note: splice(2) is only used for plain TCP connections. TLS connections always use regular copying because the data must be decrypted/encrypted in userspace.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_splice = false,\n}\n</code></pre>"},{"location":"reference/proxy/start_proxy_listener/use_tls/","title":"use_tls","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>If true, the listener will start with TLS enabled and require clients to connect using TLS.</p> <p>When TLS is enabled, you can optionally specify tls_certificate and tls_private_key. If not specified, a self-signed certificate will be generated automatically.</p> <pre><code>proxy.start_proxy_listener {\n  listen = '0.0.0.0:1080',\n  use_tls = true,\n}\n</code></pre>"},{"location":"reference/redis/","title":"<code>require 'redis'</code>","text":"<p>The redis module provides access to redis data stores.</p>"},{"location":"reference/redis/open/","title":"redis.open","text":"<pre><code>redis.open { PARAMS }\n</code></pre> <p>Opens a connection to a Redis data store and returns a connection handle.</p> <pre><code>local redis = require 'redis'\n\n-- Open a connection and increment a counter, returning its new value.\n-- Redis URL syntax is: 'redis://[&lt;username&gt;][:&lt;password&gt;@]&lt;hostname&gt;[:port][/[&lt;db&gt;][?protocol=&lt;protocol&gt;]]'\nlocal conn = redis.open { node = 'redis://127.0.0.1/' }\nprint(conn:query('incr', 'test-count'))\n</code></pre> <p>PARAMS is a lua table with the following keys:</p> <ul> <li> <p><code>node</code> - the redis URL string identifying the server.  Can be a table listing   multiple servers if you have a redis cluster deployed.  Redis URL strings   have the form <code>redis://[&lt;username&gt;][:&lt;password&gt;@]&lt;hostname&gt;[:port][/[&lt;db&gt;][?protocol=&lt;protocol&gt;]]</code></p> </li> <li> <p><code>pool_size</code> - optional integer. Specifies the maximum number of spare   connections to be maintained by the connection pool.  The default is 10.</p> </li> <li> <p><code>read_from_replicas</code> - optional boolean. If true, when connecting to a redis   cluster, reads are issued to replicas while writes are issued to the primary   data stores.</p> </li> <li> <p><code>username</code> - optional string. convenience for working with the cluster, so   that you only need to specify the username once. This is not used for connecting   to a single node.</p> </li> <li> <p><code>password</code> - optional string. convenience for working with the cluster, so   that you only need to specify the password once. This is not used for connecting   to a single node.</p> </li> <li> <p><code>connect_timeout</code> - optional duration string. Specify how long to keep attempting   to connect to redis. The default is <code>30 seconds</code>. (Since: Version 2024.06.10-84e84b89)</p> </li> <li> <p><code>wait_timeout</code> - optional duration string. Specify how long to wait for an   available connection. If the pool is at capacity (<code>pool_size</code>), then an <code>open</code>   call will block for up this duration for a connection to be released and made    to connect to redis. The default is <code>30 seconds</code>. (Since: Version 2024.09.02-c5476b89)</p> </li> <li> <p><code>response_timeout</code> - optional duration string. Specify how long to wait for the   response to a query.  (Since: Version 2024.09.02-c5476b89)</p> </li> <li> <p><code>recycle_timeout</code> - optional duration string. Specify how long to wait for the   liveness check when testing whether a connection can be resused.   (Since: Version 2024.09.02-c5476b89)</p> </li> <li> <p><code>cluster</code> - optional boolean. Set this to true to explicit use a cluster-enabled   client. The default is false if the number of nodes is one, or true if the   number of nodes is greater than one. You generally don't need to set this,   but can do so to force a cluster connection when you have only a single   node address. (Since: Version 2024.09.02-c5476b89)</p> </li> </ul> <p>The returned connection handle has a single <code>\"query\"</code> method:</p>"},{"location":"reference/redis/open/#connquerycmd-args","title":"<code>conn:query(CMD, [ARGS])</code>","text":"<p>Issue a redis command and return the result.</p> <p>See Redis Commands for a list of commands.</p> <p>The redis INCRBY command increments a key by a value; it has the syntax:</p> <pre><code>INCRBY key increment\n</code></pre> <p>To use INCRBY to increment <code>my-key</code> by <code>2</code>:</p> <pre><code>conn:query(\"INCRBY\", \"my-key\", 2)\n</code></pre>"},{"location":"reference/regex/","title":"<code>require 'kumo.regex'</code>","text":"<p>The regex module provides access to the Rust regular expression crate with a more familiar regular expression syntax than that of Lua.</p>"},{"location":"reference/regex/compile/","title":"kumo.regex.compile","text":"<pre><code>kumo.regex.compile(PATTERN)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Compiles the regular expression <code>PATTERN</code>. The supported syntax is described in the Rust regex crate documentation, augmented by fancy regex extensions, and is similar to Perl-Compatible Regex, with a few differences.</p> <p>Note</p> <p>In lua string literals backslash must always be escaped by a backslash, so you will need to write <code>\\\\</code> in cases where in other languages you might have been able to get away with just a single backslash.</p> <p>The return from this function is a <code>Regex</code> object that has the following methods:</p>"},{"location":"reference/regex/compile/#regexcaptureshaystack","title":"regex:captures(HAYSTACK)","text":"<p>Searches for the first match of this regex in the haystack given, and if found, returns a table keyed by the captures defined in the regex.  Index 0 corresponds to the full match. Each subsequent capture group is indexed by the order of its opening <code>(</code>.</p> <pre><code>local re = kumo.regex.compile \"'([^']+)'\\\\s+\\\\((\\\\d{4})\\\\)\"\nlocal cap = re:captures \"Not my favorite movie: 'Citizen Kane' (1941).\"\nassert(cap[0] == \"'Citizen Kane' (1941)\")\nassert(cap[1] == 'Citizen Kane')\nassert(cap[2] == '1941')\n</code></pre> <p>Named capture groups are also supported; in addition to the numeric indices described above, if you have used a named capture group, you can also index the result by its name:</p> <pre><code>local re = kumo.regex.compile \"'(?&lt;title&gt;[^']+)'\\\\s+\\\\((?&lt;year&gt;\\\\d{4})\\\\)\"\nlocal cap = re:captures \"Not my favorite movie: 'Citizen Kane' (1941).\"\nassert(cap[0] == \"'Citizen Kane' (1941)\")\nassert(cap.title == 'Citizen Kane')\nassert(cap.year == '1941')\n</code></pre>"},{"location":"reference/regex/compile/#regexis_matchhaystack","title":"regex:is_match(HAYSTACK)","text":"<p>Returns true if and only if there is a match for the regex anywhere in the haystack given.</p> <p>It is recommended to use this method if all you need to do is test whether a match exists, since the underlying matching engine may be able to do less work.</p> <pre><code>local re = kumo.regex.compile 'oo'\nassert(re:is_match 'foo')\n</code></pre>"},{"location":"reference/regex/compile/#regexfindhaystack","title":"regex:find(HAYSTACK)","text":"<p>Searches for the first match of this regex in the haystack given, and if found, returns it as a string.</p> <pre><code>local re = kumo.regex.compile 'o+'\nassert(re:find 'food' == 'oo')\nassert(re:find 'fooood' == 'oooo')\n</code></pre>"},{"location":"reference/regex/compile/#regexfind_allhaystack","title":"regex:find_all(HAYSTACK)","text":"<p>Searchs for successive non-overlapping matches in the given haystack, returning the matches as an array-like table of the matching strings.</p> <pre><code>local re = kumo.regex.compile '\\\\b\\\\w{13}\\\\b'\nlocal res =\n  re:find_all 'Retroactively relinquishing remunerations is reprehensible.'\nassert(\n  kumo.json_encode(res)\n    == '[\"Retroactively\",\"relinquishing\",\"remunerations\",\"reprehensible\"]'\n)\n</code></pre>"},{"location":"reference/regex/compile/#regexreplacetext-replacement","title":"regex:replace(TEXT, REPLACEMENT)","text":"<p>Replaces the leftmost-first match with the replacement provided.  <code>$N</code> and <code>$name</code> in the replacement string are expanded to match capture groups defined in the regex.</p> <p>If no match is found, then a copy of the string is returned unchanged.</p> <p>All instances of <code>$name</code> in the replacement text is replaced with the corresponding capture group name.</p> <p><code>name</code> may be an integer corresponding to the index of the capture group (counted by order of opening parenthesis where <code>0</code> is the entire match) or it can be a name (consisting of letters, digits or underscores) corresponding to a named capture group.</p> <p>If <code>name</code> isn\u2019t a valid capture group (whether the name doesn\u2019t exist or isn\u2019t a valid index), then it is replaced with the empty string.</p> <p>The longest possible <code>name</code> is used. e.g., <code>$1a</code> looks up the capture group named <code>1a</code> and not the capture group at index <code>1</code>. To exert more precise control over the name, use braces, e.g., <code>${1}a</code>.</p> <p>To write a literal <code>$</code> use <code>$$</code>.</p> <pre><code>local re = kumo.regex.compile '[^01]+'\nassert(re:replace('1078910', '') == '1010')\n</code></pre> <pre><code>local re = kumo.regex.compile '(?P&lt;last&gt;[^,\\\\s]+),\\\\s+(?P&lt;first&gt;\\\\S+)'\nassert(\n  re:replace('Springsteen, Bruce', '$first $last') == 'Bruce Springsteen'\n)\n</code></pre>"},{"location":"reference/regex/compile/#regexreplace_alltext-replacement","title":"regex:replace_all(TEXT, REPLACEMENT)","text":"<p>Replaces all non-overlapping matches in text with the replacement provided. This is the same as calling <code>replacen</code> with <code>limit</code> set to <code>0</code>.</p> <p>See the documentation for <code>replace</code> for details on how to access capturing group matches in the replacement string.</p>"},{"location":"reference/regex/compile/#regexreplacentext-limit-replacement","title":"regex:replacen(TEXT, LIMIT, REPLACEMENT)","text":"<p>Replaces at most limit non-overlapping matches in text with the replacement provided. If limit is <code>0</code>, then all non-overlapping matches are replaced.</p> <p>See the documentation for <code>replace</code> for details on how to access capturing group matches in the replacement string.</p>"},{"location":"reference/regex/compile/#regexsplittext","title":"regex:split(TEXT)","text":"<p>Splits <code>text</code> by the regex, returning each delimited string in an array-style table.</p> <pre><code>local re = kumo.regex.compile '[ \\\\t]+'\nlocal res = re:split 'a b \\t  c\\td    e'\nassert(kumo.json_encode(res) == '[\"a\",\"b\",\"c\",\"d\",\"e\"]')\n</code></pre>"},{"location":"reference/regex/escape/","title":"kumo.regex.escape","text":"<pre><code>kumo.regex.escape(PATTERN)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Escapes all regular expression meta characters in <code>PATTERN</code>.</p> <p>The string returned may be safely used as a literal in a regular expression.</p>"},{"location":"reference/sqlite/","title":"<code>require 'sqlite'</code>","text":"<p>The sqlite module provides access to sqlite databases.</p>"},{"location":"reference/sqlite/open/","title":"sqlite.open","text":"<pre><code>sqlite.open(PATH, [BUSY_TIMEOUT=500])\n</code></pre> <p>Opens the sqlite database at <code>PATH</code> and returns a connection handle.</p> <p><code>BUSY_TIMEOUT</code> specifies the time in milliseconds over which sqlite should retry operations when it is unable to get an exclusive lock. The default is 500ms.</p> <p>Note</p> <p>when using the special path <code>:memory:</code>, sqlite will create an in-memory database which is great for this contrived example, but not a great deal of use in a real worl usage inside KumoMTA.</p> <p>The returned connection object has the following methods:</p>"},{"location":"reference/sqlite/open/#dbexecutequery-params","title":"<code>db:execute(QUERY, [PARAMS])</code>","text":"<p>The execute method can be used to execute a query.</p> <pre><code>local sqlite = require 'sqlite'\nlocal db = sqlite.open ':memory:'\n\n-- For the sake of this example, populate with some simple data\ndb:execute 'CREATE TABLE people (name, age)'\n\n-- You can use prepared statements with positional arguments like this:\ndb:execute('INSERT INTO people (name, age) values (?, ?)', 'john', 42)\n\n-- and with named arguments like this:\ndb:execute(\n  'INSERT INTO people (name, age) values (:name, :age)',\n  { name = 'fred', age = 32 }\n)\n\n-- Lets print out just the ages from the database; when the query\n-- returns only a single column, the returned value will be an\n-- array style lua table consisting of just the values.  In this case,\n-- it is equivalent to `{32, 42}`\nprint 'query ages'\nlocal ages = db:execute 'select age from people order by age'\nfor k, v in ipairs(ages) do\n  print(k, v)\nend\n\n-- When multiple columns are returned, they are presented as\n-- an array style table of lua object style tables will be returned.\n-- In this case it is equivalent to:\n-- `{ {name=\"john\", age=42 }, {name=\"fred\", age=32}}`\nprint 'query all'\nlocal ages = db:execute 'select * from people order by age'\nfor k, v in ipairs(ages) do\n  print('row', k)\n  for name, value in pairs(v) do\n    print(name, value)\n  end\nend\n\n-- When no rows are returned by the query, the return value is\n-- the number of rows affected by the query. In this case, because\n-- 2 records are being deleted, this will print 2\nprint('deleted rows:', db:execute 'delete from people')\n</code></pre> <p>sqlite queries are executed via a thread pool so that the query won't block important IO scheduling.</p> <p>Queries and query results are not implicitly cached.</p>"},{"location":"reference/sqlite/open/#dbclose","title":"<code>db:close()</code>","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Explicitly close the sqlite connection.</p>"},{"location":"reference/string/","title":"<code>require 'kumo.string'</code>","text":"<p>The regex module provides access to a number of string functions beyond those in the base Lua string library.</p>"},{"location":"reference/string/eval_template/","title":"kumo.string.eval_template","text":"<pre><code>kumo.string.eval_template(NAME, SOURCE, CONTEXT, OPT_DIALECT)\n</code></pre> Since: Version 2025.03.19-1d3f1f67 <p>The functionality described in this section requires version 2025.03.19-1d3f1f67 of KumoMTA, or a more recent version.</p> <p>Evaluates a minijinja template.</p> <p>The parameters are:</p> <ul> <li><code>NAME</code> - the nominal \"file name\" for the template. No actual file I/O is   performed; this parameter tells the template engine what the filename would   have been if it were loaded from disk. The filename is used to decide what   strategy should be used for automatic output escaping.  For example, if the   name ends with <code>.json</code> or <code>.html</code> then appropriate json or html entity   escaping will automatically be applied to the output.</li> <li><code>SOURCE</code> - the template source code. This must follow the template syntax.</li> <li><code>CONTEXT</code> - an object that defines the variables that are available to the template engine.</li> </ul> <pre><code>-- This will print `\"John\"`\nprint(\n  kumo.string.eval_template('example.json', [[{{ name }}]], { name = 'John' })\n)\n</code></pre> <pre><code>local kumo = require 'kumo'\n\nlocal log_record = kumo.serde.json_parse [=[\n{\n    \"type\": \"Delivery\",\n    \"id\": \"1d98076abbbc11ed940250ebf67f93bd\",\n    \"sender\": \"user@sender.example.com\",\n    \"recipient\": \"user@recipient.example.com\",\n    \"queue\": \"campaign:tenant@domain\",\n    \"site\": \"source2-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com.\",\n    \"size\": 1047,\n    \"response\": {\n        \"code\": 250,\n        \"enhanced_code\": {\n            \"class\": 2,\n            \"subject\": 0,\n            \"detail\": 0\n        },\n        \"content\": \"OK ids=8a5475ccbbc611eda12250ebf67f93bd\",\n        \"command\": \".\"\n    },\n    \"peer_address\": {\n        \"name\": \"gmail-smtp-in.l.google.com.\",\n        \"addr\": \"142.251.2.27\"\n    },\n    \"timestamp\": 1678069691,\n    \"created\": 1678069691,\n    \"num_attempts\": 0,\n    \"bounce_classification\": \"Uncategorized\",\n    \"egress_pool\": \"pool0\",\n    \"egress_source\": \"source2\",\n    \"source_address\": {\n        \"address\": \"10.0.0.1:53210\",\n        \"protocol\": \"socks5\",\n        \"server\": \"192.168.1.1:5000\"\n    },\n    \"feedback_report\": null,\n    \"meta\": {},\n    \"headers\": {},\n    \"delivery_protocol\": \"ESMTP\",\n    \"reception_protocol\": \"ESMTP\",\n    \"bogus\": null,\n    \"nodeid\": \"557f3ad4-2c8c-11ee-976e-782d7e12e173\",\n    \"tls_cipher\": \"TLS_AES_256_GCM_SHA384\",\n    \"tls_protocol_version\": \"TLSv1.3\",\n    \"tls_peer_subject_name\": [\"C=US\",\"ST=CA\",\"L=SanFrancisco\",\"O=Fort-Funston\",\n                              \"OU=MyOrganizationalUnit\",\"CN=do.havedane.net\",\n                              \"name=EasyRSA\",\"emailAddress=me@myhost.mydomain\"],\n    \"session_id\": \"9bcd689e-23d9-41b7-a015-63a1382f8b57\"\n}\n]=]\n\nprint(kumo.string.eval_template(\n  'log.json',\n  [[{}\n]],\n  { log_record = log_record }\n))\n</code></pre>","tags":["templates"]},{"location":"reference/string/eval_template/#template-dialect","title":"Template Dialect","text":"Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>It is now possible to specify which template engine will be used for template expansion via the <code>OPT_DIALECT</code> parameter. It can have one of the following values:</p> <ul> <li><code>Jinja</code> - this is the implied default.  The Mini Jinja    template dialect will be parsed and evaluated.</li> <li><code>Static</code> - The content is treated as a static string and    no template expansion will be performed</li> <li><code>Handlebars</code> - The content will be evaluated by a handlebars    compatible template engine.</li> </ul>","tags":["templates"]},{"location":"reference/string/normalize_smtp_response/","title":"kumo.string.normalize_smtp_response","text":"<pre><code>kumo.string.normalize_smtp_response(TEXT)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>The purpose of this function is to normalize out per-user, per-transaction variations from an input SMTP response line.  The normalization is intended to make it easier for downstream log processing to group similar events together.</p> <p>Note</p> <p>The normalization process is not guaranteed to remove any/all user- or transaction-centric content from a string, but rather to make a best effort attempt to tokenize out the more obvious parts of the response as a convenience.</p> <p>If you need stronger guarantees that PII will be removed from logs then you will need to make alternative arrangements.</p> <p>Given an input string like:</p> <pre><code>550 5.1.1 The email account that you tried to reach does not exist.\nPlease try double-checking the recipient's email address for typos\nor unnecessary spaces. For more information, go to\nhttps://support.google.com/mail/?p=NoSuchUser 41be03b00d2f7-b93bf44f0c0si6882731a12.803 - gsmtp\n</code></pre> <p>The normalized version would look like:</p> <pre><code>550 5.1.1 The email account that you tried to reach does not exist.\nPlease try double-checking the recipient's email address for typos\nor unnecessary spaces. For more information, go to\nhttps://support.google.com/mail/?p=NoSuchUser {hash} - gsmtp\n</code></pre> <p>Normalization works approximately as follows:</p> <ul> <li>The input is tokenized into whitespace separated words</li> <li>Dictionary words are left unchanged</li> <li>RFC3339 timestamps are recognized and replaced by the token <code>{timestamp}</code></li> <li>UUIDs in a variety of formats are recognized and replaced by the token <code>{uuid}</code></li> <li>Alphanumeric sequences of a certain minimum length and minimum number of both    letters AND digits with optional <code>.</code>, <code>-</code> and <code>_</code> delimiters are replaced    by the token <code>{hash}</code>.</li> <li>IPv4 and IPv6 addresses are replaced by the token <code>{ipaddr}</code></li> <li>Sequences that appear to be valid base64 or base64 URL are replaced by the    token <code>{base64}</code>.</li> <li>RFC5321 email addresses are replaced by the token <code>{email}</code></li> <li>Tokens that look like <code>lhs=rhs</code> are split on the <code>=</code> sign and the right hand    side is recursively processed by the normalizer</li> </ul>"},{"location":"reference/string/psl_domain/","title":"kumo.string.psl_domain","text":"<pre><code>kumo.string.psl_domain(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Get the registrable domain as defined by Mozilla's Public Suffix List.</p> <pre><code>assert(kumo.string.psl_domain 'www.example.com' == 'example.com')\n</code></pre>"},{"location":"reference/string/psl_suffix/","title":"kumo.string.psl_suffix","text":"<pre><code>kumo.string.psl_suffix(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Get the public suffix as defined by Mozilla's Public Suffix List.</p> <pre><code>assert(kumo.string.psl_suffix 'www.example.com' == 'com')\n</code></pre>"},{"location":"reference/string/replace/","title":"kumo.string.replace","text":"<pre><code>kumo.string.replace(STRING, FROM, TO)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Replaces all matches of <code>FROM</code> with <code>TO</code> and returns the resulting string.</p> <pre><code>assert(kumo.string.replace('this is old', 'old', 'new') == 'this is new')\n</code></pre>"},{"location":"reference/string/replacen/","title":"kumo.string.replacen","text":"<pre><code>kumo.string.replacen(STRING, FROM, TO, COUNT)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Replaces the first N matches of <code>FROM</code> with <code>TO</code> and returns the resulting string.</p> <pre><code>assert(\n  kumo.string.replacen('foo foo 123 foo', 'foo', 'new', 2)\n    == 'new new 123 foo'\n)\n</code></pre>"},{"location":"reference/string/rsplit/","title":"kumo.string.rsplit","text":"<pre><code>kumo.string.rsplit(STRING, PATTERN)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Splits <code>STRING</code> by <code>PATTERN</code> in reverse order, returning an array-style table holding the substrings.</p> <pre><code>assert(\n  kumo.json_encode(kumo.string.rsplit('Mary had a little lamb', ' '))\n    == '[\"lamb\",\"little\",\"a\",\"had\",\"Mary\"]'\n)\n</code></pre>"},{"location":"reference/string/rsplitn/","title":"kumo.string.rsplitn","text":"<pre><code>kumo.string.rsplitn(STRING, LIMIT, PATTERN)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Splits <code>STRING</code> by <code>PATTERN</code> in reverse order, returning an array-style table holding at most <code>LIMIT</code> substrings.</p> <pre><code>assert(\n  kumo.json_encode(kumo.string.rsplitn('Mary had a little lamb', 3, ' '))\n    == '[\"lamb\",\"little\",\"Mary had a\"]'\n)\n</code></pre>"},{"location":"reference/string/split/","title":"kumo.string.split","text":"<pre><code>kumo.string.split(STRING, PATTERN)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Splits <code>STRING</code> by <code>PATTERN</code>, returning an array-style table holding the substrings.</p> <pre><code>assert(\n  kumo.json_encode(kumo.string.split('Mary had a little lamb', ' '))\n    == '[\"Mary\",\"had\",\"a\",\"little\",\"lamb\"]'\n)\n</code></pre>"},{"location":"reference/string/split_ascii_whitespace/","title":"kumo.string.split_ascii_whitespace","text":"<pre><code>kumo.string.split_ascii_whitespace(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Splits <code>STRING</code> by ASCII whitespace,.</p> <p>To split by unicode <code>White_Space</code> instead, use split_whitespace.</p> <pre><code>assert(\n  kumo.json_encode(\n    kumo.string.split_ascii_whitespace 'Mary had a little lamb'\n  ) == '[\"Mary\",\"had\",\"a\",\"little\",\"lamb\"]'\n)\n</code></pre>"},{"location":"reference/string/split_whitespace/","title":"kumo.string.split_whitespace","text":"<pre><code>kumo.string.split_whitespace(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Splits <code>STRING</code> by whitespace, as defined by the Unicode Derived Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace, use split_ascii_whitespace instead, as it is cheaper.</p> <pre><code>assert(\n  kumo.json_encode(kumo.string.split_whitespace 'Mary had a little lamb')\n    == '[\"Mary\",\"had\",\"a\",\"little\",\"lamb\"]'\n)\n</code></pre>"},{"location":"reference/string/splitn/","title":"kumo.string.splitn","text":"<pre><code>kumo.string.splitn(STRING, LIMIT, PATTERN)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Splits <code>STRING</code> by <code>PATTERN</code>, returning an array-style table holding at most <code>LIMIT</code> substrings.</p> <pre><code>assert(\n  kumo.json_encode(kumo.string.splitn('Mary had a little lamb', 3, ' '))\n    == '[\"Mary\",\"had\",\"a little lamb\"]'\n)\n</code></pre>"},{"location":"reference/string/trim/","title":"kumo.string.trim","text":"<pre><code>kumo.string.trim(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Returns a string with leading and trailing whitespace removed.</p> <p>\u2018Whitespace\u2019 is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <pre><code>assert(kumo.string.trim '\\n Hello\\tworld\\t\\n' == 'Hello\\tworld')\n</code></pre>"},{"location":"reference/string/trim_end/","title":"kumo.string.trim_end","text":"<pre><code>kumo.string.trim_end(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Returns a string with trailing whitespace removed.</p> <p>\u2018Whitespace\u2019 is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <pre><code>assert(kumo.string.trim_end '\\n Hello\\tworld\\t\\n' == '\\n Hello\\tworld')\n</code></pre>"},{"location":"reference/string/trim_start/","title":"kumo.string.trim_start","text":"<pre><code>kumo.string.trim_start(STRING)\n</code></pre> Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>Returns a string with leading whitespace removed.</p> <p>\u2018Whitespace\u2019 is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <pre><code>assert(kumo.string.trim_start '\\n Hello\\tworld\\t\\n' == 'Hello\\tworld\\t\\n')\n</code></pre>"},{"location":"reference/string/wrap/","title":"kumo.string.wrap","text":"<pre><code>local wrapped = kumo.string.wrap(TEXT, SOFT_LIMIT, HARD_LIMIT)\n</code></pre> Since: Version 2025.12.02-67ee9e96 <p>The functionality described in this section requires version 2025.12.02-67ee9e96 of KumoMTA, or a more recent version.</p> <p>Ensures that the <code>TEXT</code> parameter is no longer than <code>HARD_LIMIT</code> by breaking around whitespace to try to keep most lines below <code>SOFT_LIMIT</code>, but hard breaking longer words that exceed <code>HARD_LIMIT</code>.</p> <p>Any breaks introduced will be <code>\\r\\n\\t</code> (CR, LF, then TAB).</p> <p><code>SOFT_LIMIT</code> defaults to <code>75</code>.</p> <p><code>HARD_LIMIT</code> defaults to <code>900</code>.</p> <p>Any trailing whitespace will be trimmed from the returned value.</p>"},{"location":"reference/string/wrap/#example","title":"Example","text":"<pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nutils.assert_eq(kumo.string.wrap 'hello', 'hello')\n\nlocal long_string = string.rep('A', 200)\nlocal expect_wrapped = string.rep('A', 100)\n  .. '\\r\\n\\t'\n  .. string.rep('A', 100)\nutils.assert_eq(kumo.string.wrap(long_string, 75, 100), expect_wrapped)\n\nlocal long_string_spaced = string.rep('hello there ', 10)\nutils.assert_eq(\n  kumo.string.wrap(long_string_spaced, 75, 100),\n  'hello there hello there hello there hello there hello there hello there\\r\\n'\n    .. '\\thello there hello there hello there hello there'\n)\n</code></pre>"},{"location":"reference/template/","title":"Template Syntax","text":"<p>A number of components and facilities in KumoMTA allow you to use the Mini Jinja templating engine.  The full supported syntax is documented here.</p> <p>In addition to the base functionality, we include additional date/time formatting filters and globals via minijinja_contrib.</p> <p>An abbreviated list of various functions and filters is included here for the sake of searchability, but you should consult the resources listed above for a complete list.</p> <ul> <li>Builtin filters: see here</li> </ul>","tags":["templates"]},{"location":"reference/template/cycler/","title":"cycler","text":"<pre><code>pub fn cycler(items: Vec&lt;Value&gt;) -&gt; Result&lt;Value, Error&gt;\n</code></pre> <p>Returns a cycler.</p> <p>Similar to <code>loop.cycle</code>, but can be used outside loops or across multiple loops. For example, render a list of folders and files in a list, alternating giving them \"odd\" and \"even\" classes.</p> <pre><code>{% set row_class = cycler(\"odd\", \"even\") %}\n&lt;ul class=\"browser\"&gt;\n{% for folder in folders %}\n  &lt;li class=\"folder {{ row_class.next() }}\"&gt;{{ folder }}\n{% endfor %}\n{% for file in files %}\n  &lt;li class=\"file {{ row_class.next() }}\"&gt;{{ file }}\n{% endfor %}\n&lt;/ul&gt;\n</code></pre>"},{"location":"reference/template/dateformat/","title":"dateformat","text":"<pre><code>pub fn dateformat(\n    state: &amp;State&lt;'_, '_&gt;,\n    value: Value,\n    kwargs: Kwargs,\n) -&gt; Result&lt;String, Error&gt;\n</code></pre> <p>Formats a timestamp as date.</p> <p>The value needs to be a unix timestamp, or a parsable string (ISO 8601) or a format supported by <code>chrono</code> or <code>time</code>.  If the string does not include time information, then timezone adjustments are not performed.</p> <p>The filter accepts two keyword arguments (<code>format</code> and <code>tz</code>) to influence the format and the timezone.  The default format is <code>\"medium\"</code>.  The defaults for these keyword arguments are taken from two global variables in the template context: <code>DATE_FORMAT</code> and <code>TIMEZONE</code>.  If the timezone is set to <code>\"original\"</code> or is not configured, then the timezone of the value is retained.  Otherwise the timezone is the name of a timezone from the database.</p> <pre><code>{{ value|dateformat }}\n</code></pre> <pre><code>{{ value|dateformat(format=\"short\") }}\n</code></pre> <pre><code>{{ value|dateformat(format=\"short\", tz=\"Europe/Vienna\") }}\n</code></pre> <p>This filter currently uses the <code>time</code> crate to format dates and uses the format string specification of that crate in version 2.  For more information read the Format description documentation. Additionally some special formats are supported:</p> <ul> <li><code>short</code>: a short date format (<code>2023-06-24</code>)</li> <li><code>medium</code>: a medium length date format (<code>Jun 24 2023</code>)</li> <li><code>long</code>: a longer date format (<code>June 24 2023</code>)</li> <li><code>full</code>: a full date format (<code>Saturday, June 24 2023</code>)</li> </ul>"},{"location":"reference/template/datetimeformat/","title":"datetimeformat","text":"<pre><code>pub fn datetimeformat(\n    state: &amp;State&lt;'_, '_&gt;,\n    value: Value,\n    kwargs: Kwargs,\n) -&gt; Result&lt;String, Error&gt;\n</code></pre> <p>Formats a timestamp as date and time.</p> <p>The value needs to be a unix timestamp, or a parsable string (ISO 8601) or a format supported by <code>chrono</code> or <code>time</code>.</p> <p>The filter accepts two keyword arguments (<code>format</code> and <code>tz</code>) to influence the format and the timezone.  The default format is <code>\"medium\"</code>.  The defaults for these keyword arguments are taken from two global variables in the template context: <code>DATETIME_FORMAT</code> and <code>TIMEZONE</code>.  If the timezone is set to <code>\"original\"</code> or is not configured, then the timezone of the value is retained.  Otherwise the timezone is the name of a timezone from the database.</p> <pre><code>{{ value|datetimeformat }}\n</code></pre> <pre><code>{{ value|datetimeformat(format=\"short\") }}\n</code></pre> <pre><code>{{ value|datetimeformat(format=\"short\", tz=\"Europe/Vienna\") }}\n</code></pre> <p>This filter currently uses the <code>time</code> crate to format dates and uses the format string specification of that crate in version 2.  For more information read the Format description documentation. Additionally some special formats are supported:</p> <ul> <li><code>short</code>: a short date and time format (<code>2023-06-24 16:37</code>)</li> <li><code>medium</code>: a medium length date and time format (<code>Jun 24 2023 16:37</code>)</li> <li><code>long</code>: a longer date and time format (<code>June 24 2023 16:37:22</code>)</li> <li><code>full</code>: a full date and time format (<code>Saturday, June 24 2023 16:37:22</code>)</li> <li><code>unix</code>: a unix timestamp in seconds only (<code>1687624642</code>)</li> <li><code>iso</code>: date and time in iso format (<code>2023-06-24T16:37:22+00:00</code>)</li> </ul>"},{"location":"reference/template/filesizeformat/","title":"filesizeformat","text":"<pre><code>pub fn filesizeformat(value: f64, binary: Option&lt;bool&gt;) -&gt; String\n</code></pre> <p>Formats the value like a \u201chuman-readable\u201d file size.</p> <p>For example. 13 kB, 4.1 MB, 102 Bytes, etc. Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to true the binary prefixes are used (Mebi, Gibi).</p>"},{"location":"reference/template/joiner/","title":"joiner","text":"<pre><code>pub fn joiner(sep: Option&lt;Value&gt;) -&gt; Value\n</code></pre> <p>A tiny helper that can be used to \u201cjoin\u201d multiple sections.  A joiner is passed a string and will return that string every time it\u2019s called, except the first time (in which case it returns an empty string). You can use this to join things:</p> <pre><code>{% set pipe = joiner(\"|\") %}\n{% if categories %} {{ pipe() }}\nCategories: {{ categories|join(\", \") }}\n{% endif %}\n{% if author %} {{ pipe() }}\nAuthor: {{ author() }}\n{% endif %}\n{% if can_edit %} {{ pipe() }}\n&lt;a href=\"?action=edit\"&gt;Edit&lt;/a&gt;\n{% endif %}\n</code></pre>"},{"location":"reference/template/normalize_smtp_response/","title":"normalize_smtp_response","text":"<pre><code>pub fn normalize_smtp_response(text: &amp;str) -&gt; String\n</code></pre> <p>This filter normalizes an SMTP response as described in kumo.string.normalize_smtp_response.</p> <pre><code>{{ response.content | normalize_smtp_response }}\n</code></pre>"},{"location":"reference/template/now/","title":"now","text":"<pre><code>pub fn now() -&gt; Value\n</code></pre> <p>Returns the current time in UTC as unix timestamp.</p> <p>To format this timestamp, use the datetimeformat filter.</p>"},{"location":"reference/template/pluralize/","title":"pluralize","text":"<pre><code>pub fn pluralize(\n    v: Value,\n    singular: Option&lt;Value&gt;,\n    plural: Option&lt;Value&gt;,\n) -&gt; Result&lt;Value, Error&gt;\n</code></pre> <p>Returns a plural suffix if the value is not 1, '1', or an object of length 1.</p> <p>By default, the plural suffix is 's' and the singular suffix is empty (''). You can specify a singular suffix as the first argument (or <code>None</code>, for the default). You can specify a plural suffix as the second argument (or <code>None</code>, for the default).</p> <pre><code>{{ users|length }} user{{ users|pluralize }}.\n</code></pre> <pre><code>{{ entities|length }} entit{{ entities|pluralize(\"y\", \"ies\") }}.\n</code></pre> <pre><code>{{ platypuses|length }} platypus{{ platypuses|pluralize(None, \"es\") }}.\n</code></pre>"},{"location":"reference/template/timeformat/","title":"timeformat","text":"<pre><code>pub fn timeformat(\n    state: &amp;State&lt;'_, '_&gt;,\n    value: Value,\n    kwargs: Kwargs,\n) -&gt; Result&lt;String, Error&gt;\n</code></pre> <p>Formats a timestamp as time.</p> <p>The value needs to be a unix timestamp, or a parsable string (ISO 8601) or a format supported by <code>chrono</code> or <code>time</code>.</p> <p>The filter accepts two keyword arguments (<code>format</code> and <code>tz</code>) to influence the format and the timezone.  The default format is <code>\"medium\"</code>.  The defaults for these keyword arguments are taken from two global variables in the template context: <code>TIME_FORMAT</code> and <code>TIMEZONE</code>.  If the timezone is set to <code>\"original\"</code> or is not configured, then the timezone of the value is retained.  Otherwise the timezone is the name of a timezone from the database.</p> <pre><code>{{ value|timeformat }}\n</code></pre> <pre><code>{{ value|timeformat(format=\"short\") }}\n</code></pre> <pre><code>{{ value|timeformat(format=\"short\", tz=\"Europe/Vienna\") }}\n</code></pre> <p>This filter currently uses the <code>time</code> crate to format dates and uses the format string specification of that crate in version 2.  For more information read the Format description documentation. Additionally some special formats are supported:</p> <ul> <li><code>short</code> and <code>medium</code>: hour and minute (<code>16:37</code>)</li> <li><code>long</code>: includes seconds too (<code>16:37:22</code>)</li> <li><code>full</code>: includes subseconds too (<code>16:37:22.0</code>)</li> <li><code>unix</code>: a unix timestamp in seconds only (<code>1687624642</code>)</li> <li><code>iso</code>: date and time in iso format (<code>2023-06-24T16:37:22+00:00</code>)</li> </ul>"},{"location":"reference/tsa/","title":"Module <code>tsa</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This module provides functions to configure the KumoMTA Traffic Shaping Automation daemon.</p> <p>This module is only present in the <code>tsa-daemon</code> process; attempting to <code>require</code> it elsewhere will fail.</p>"},{"location":"reference/tsa/configure_tsa_db_path/","title":"kumo.configure_tsa_db_path","text":"<pre><code>kumo.configure_tsa_db_path(PATH)\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This function should be called only from inside your tsa_init event handler, and MUST be called before kumo.tsa.start_http_listener.</p> <p>Its purpose is to specify the path in which the tsa-daemon will persist event and configuration information in a local sqlite database.</p> <p>The default value for <code>PATH</code> is <code>\"/var/spool/kumomta/tsa.db\"</code>.</p> <p>Since the path is passed to sqlite, you may use URI filenames as specified in the sqlite3_open documentation, such as <code>\":memory:\"</code> to use an in-memory database that will be discarded when the tsa-daemon is restarted.</p>"},{"location":"reference/tsa/start_http_listener/","title":"kumo.start_http_listener","text":"<pre><code>kumo.start_http_listener { PARAMS }\n</code></pre> Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Configure and start the TSA HTTP service.</p> <p>This function should be called only from inside your tsa_init event handler.</p> <p>This function behaves exactly like kumo.start_http_listener except that it will start the Traffic Shaping Automation specific HTTP service.</p>"},{"location":"rustapi/","title":"Internal Rust API","text":"<p>This section contains automatically generated documentation from the internal Rust code.  It is included in here to aid those hacking on the internals.</p> <p>There are no stability guarantees with this API: it may change without any regard for backward compatibility.</p> <p>The following crates are part of the KumoMTA workspace:</p> <ul> <li>bounce_classify</li> <li>cidr_map</li> <li>config</li> <li>data_loader</li> <li>dns_resolver</li> <li>domain_map</li> <li>duration_serde</li> <li>kumo_address</li> <li>kumo_api_client</li> <li>kumo_api_types</li> <li>kumo_chrono_helper</li> <li>kumo_dkim</li> <li>kumo_dmarc</li> <li>kumo_log_types</li> <li>kumo_machine_info</li> <li>kumo_prometheus</li> <li>kumo_server_common</li> <li>kumo_server_lifecycle</li> <li>kumo_server_memory</li> <li>kumo_server_runtime</li> <li>kumo_spf</li> <li>kumo_template</li> <li>kumo_tls_helper</li> <li>kumo_wrap</li> <li>lruttl</li> <li>maildir</li> <li>mailparsing</li> <li>message</li> <li>mod_amqp</li> <li>mod_aws_sigv4</li> <li>mod_crypto</li> <li>mod_digest</li> <li>mod_dns_resolver</li> <li>mod_encode</li> <li>mod_file_type</li> <li>mod_filesystem</li> <li>mod_http</li> <li>mod_kafka</li> <li>mod_memoize</li> <li>mod_mimepart</li> <li>mod_mpsc</li> <li>mod_nats</li> <li>mod_redis</li> <li>mod_regex</li> <li>mod_serde</li> <li>mod_smtp_response_normalize</li> <li>mod_sqlite</li> <li>mod_string</li> <li>mod_time</li> <li>mod_uuid</li> <li>mta_sts</li> <li>regex_set_map</li> <li>rfc5321</li> <li>spool</li> <li>throttle</li> <li>timeq</li> <li>uuid_helper</li> <li>version_info</li> </ul>"},{"location":"rustapi/static.files/SourceSerif4-LICENSE-a2cfd9d5/","title":"SourceSerif4 LICENSE a2cfd9d5","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"rustapi/static.files/SourceSerif4-LICENSE-a2cfd9d5/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"},{"location":"tutorial/checking_logs/","title":"Check for success in the logs","text":"<p>When diagnosing the failure (or monitoring the success) of your test messages, the logs provide extensive information.</p> <p>The easiest way to monitor activity is with the built-in <code>tailer</code> utility. Open a new terminal (because you cannot tail the logs and simultaneously send mail from the same session) and start the <code>tailer</code> utility:</p> <pre><code>sudo /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n</code></pre> <pre><code>{\n  \"type\": \"Reception\",\n  \"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n  \"sender\": \"test@example.com\",\n  \"recipient\": \"test@example.com\",\n  \"queue\": \"example.com\",\n  \"site\": \"\",\n  \"size\": 320,\n  \"response\": {\n    \"code\": 250,\n    \"enhanced_code\": null,\n    \"content\": \"\",\n    \"command\": null\n  },\n  \"peer_address\": {\n    \"name\": \"moto\",\n    \"addr\": \"127.0.0.1\"\n  },\n  \"timestamp\": 1695847980,\n  \"created\": 1695847980,\n  \"num_attempts\": 0,\n  \"bounce_classification\": \"Uncategorized\",\n  \"egress_pool\": null,\n  \"egress_source\": null,\n  \"feedback_report\": null,\n  \"meta\": {},\n  \"headers\": {},\n  \"delivery_protocol\": null,\n  \"reception_protocol\": \"ESMTP\",\n  \"nodeid\": \"d8e014c7-eaeb-4683-a56e-61324e91b1fc\"\n}\n</code></pre> <p>Note</p> <p>These example log entries have been formatted for ease of reading in the documentation.</p> <p>This assumes a default installation with the logs located in <code>/var/log/kumomta/</code>.</p> <p>If you want to dive in deeper, compressed logs are found in <code>/var/log/kumomta/</code> as can be seen in this tree. Logs are segmented by a combination of size/time and stored in compressed files named after the time that the segment was started. To read these, you need to unpack them first. You have many options for configuring logging.</p> <pre><code>/var/log/kumomta\n\u251c\u2500\u2500 20230311-033705\n\u251c\u2500\u2500 20230311-033844\n\u251c\u2500\u2500 20230312-182542\n\u2514\u2500\u2500 20230314-181435\n</code></pre> <p>We can take a look at a specific log by decompressing it and since these are zstd compressed, you can view all but the current one with <code>zstdcat</code>.  ZSTD is a streaming compression utility so the current file cannot be accessed until it is flushed and closed. You can force the current log to close early by stopping or restarting KumoMTA.</p> <p>Using the example above, we can see the content of the newest file after stopping KumoMTA with a <code>zstdcat /var/log/kumomta/20230314-181435</code>.</p> <p>The default for log segments is to flush them after 1GB of data is written, but you can adjust them to flush after a certain amount of time. The kumo.configure_local_logs page of the Reference Manual has all of the available logging configuration options.</p>"},{"location":"tutorial/checking_logs/#next-steps","title":"Next Steps","text":"<p>With KumoMTA installed, configured, and tested, the tutorial is complete.</p> <p>See more on Next Steps.</p>"},{"location":"tutorial/configuring_kumomta/","title":"Configuring KumoMTA","text":"<p>The KumoMTA configuration is entirely written in Lua. Lua is a powerful embedded scripting language that is easy to read and code, and is very powerful. It is used for custom scripts in Cisco security appliances, Roblox, World of Warcraft, and really awesome MTAs. You can read more about how we leverage Lua here.</p> <ol> <li> <p>Create an initial core configuration by copying the example at https://docs.kumomta.com/userguide/configuration/example/ and writing it to <code>/opt/kumomta/etc/policy/init.lua</code>.</p> <p></p> </li> <li> <p>Update the relay_hosts configuration within the start_esmtp_listener function to reflect which networks are authorized to inject mail:</p> <pre><code>-- override the default set of relay hosts\nrelay_hosts = { '127.0.0.1', '192.168.1.0/24' }\n</code></pre> </li> <li> <p>By default only localhost and private networks are able to relay (send) mail.  Add the IP address or CIDR block of your injectors here to allow them to relay mail.</p> <p>For HTTP, this is done with the trusted_hosts setting in a listener stanza:</p> <pre><code>kumo.start_http_listener {\n  listen = '0.0.0.0:8000',\n  -- allowed to access any http endpoint without additional auth\n  trusted_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre> <p>Note</p> <p>If you are going to allow the HTTP listener on any IP other than localhost, you should also configure TLS and HTTP Validation.</p> </li> <li> <p>Create a local copy of the Traffic Shaping Helper configuration file. The helpers are designed to provide simple configuration for standard use cases, but the Traffic Shaping Helper in particular uses a community-managed settings file located in <code>policy-extras</code> that is subject to change when your KumoMTA installation is updated. By copying it to a separate location, you can add your own rules or replace ones from the community file without your changes being lost during an update. The example config is designed so that both files are used. Only edit <code>/opt/kumomta/etc/policy/shaping.toml</code> when you want to make changes.</p> <pre><code>sudo cp /opt/kumomta/share/policy-extras/shaping.toml /opt/kumomta/etc/policy/shaping.toml\n</code></pre> <p>For more information, see the Configure Traffic Shaping Automation section of the User Guide.</p> <p></p> </li> <li> <p>Configure the listener_domains.toml file, written to <code>/opt/kumomta/etc/policy/listener_domains.toml</code> in the following format, substituting your own sending domain information:</p> TOMLJSON <pre><code>[\"bounce.example.com\"]\n# You can specify multiple options if you wish\nlog_oob = true\nlog_arf = true\nrelay_to = false\n</code></pre> <pre><code>{\n  \"bounce.example.com\": {\n    // You can specify multiple options if you wish\n    \"log_oob\": true,\n    \"log_arf\": true,\n    \"relay_to\": false\n  }\n}\n</code></pre> <p>For more information, see the Configuring Inbound and Relay Domains page of the User Guide.</p> <p>Note</p> <p>The preceding example configures the server to accept traffic from the outside world addressed to the bounce.example.com domain, as long as the incoming messages are either Out-Of-Band DSN (bounce) notifications, or Feedback Loop messages, but will not accept regular mail for inbound relay such as with a corporate mail environment.</p> </li> <li> <p>Configure the sources.toml file, written to <code>/opt/kumomta/etc/policy/sources.toml</code> in the following format, substituting your own IP and ehlo information:</p> TOMLJSON <pre><code>[source.\"ip-1\"]\nsource_address = \"10.0.0.1\"\nehlo_domain = 'mta1.examplecorp.com'\n[source.\"ip-2\"]\nsource_address = \"10.0.0.2\"\nehlo_domain = 'mta2.examplecorp.com'\n\n[pool.\"Default\"]\n[pool.\"Default\".\"ip-1\"]\n\n[pool.\"pool-1\"]\n[pool.\"pool-1\".\"ip-2\"]\n</code></pre> <pre><code>{\n  \"source\": {\n    \"ip-1\": {\n      \"source_address\": \"10.0.0.1\",\n      \"ehlo_domain\": \"mta1.examplecorp.com\"\n    },\n    \"ip-2\": {\n      \"source_address\": \"10.0.0.2\",\n      \"ehlo_domain\": \"mta2.examplecorp.com\"\n    }\n  },\n  \"pool\": {\n    \"Default\": {\n      \"ip-1\": {\n      }\n    },\n    \"pool-1\": {\n      \"ip-2\": {\n      }\n    }\n  }\n}\n</code></pre> <p>For more information, see the Configuring Sending IPs page of the User Guide.</p> </li> <li> <p>Configure the queues.toml file, written to <code>/opt/kumomta/etc/policy/queues.toml</code> in the following format, substituting your own tenant names and header names:</p> TOMLJSON <pre><code>scheduling_header = \"X-Schedule\"\ntenant_header = \"X-Tenant\"\nremove_tenant_header = true\n\ncampaign_header = \"X-Campaign\"\nremove_campaign_header = true\n\ndefault_tenant = \"default-tenant\"\n\n[tenant.'default-tenant']\negress_pool = 'default'\n\n[tenant.'mytenant']\negress_pool = 'pool-1'\nmax_age = '10 hours'\n\n[queue.'gmail.com']\nmax_age = '22 hours'\nretry_interval = '17 mins'\n</code></pre> <pre><code>{\n  \"scheduling_header\": \"X-Schedule\",\n  \"tenant_header\": \"X-Tenant\",\n  \"remove_tenant_header\": true,\n  \"campaign_header\": \"X-Campaign\",\n  \"remove_campaign_header\": true,\n  \"default_tenant\": \"default-tenant\",\n  \"tenant\": {\n    \"default-tenant\": {\n      \"egress_pool\": \"default\"\n    },\n    \"mytenant\": {\n      \"egress_pool\": \"pool-1\",\n      \"max_age\": \"10 hours\"\n    }\n  },\n  \"queue\": {\n    \"gmail.com\": {\n      \"max_age\": \"22 hours\",\n      \"retry_interval\": \"17 mins\"\n    }\n  }\n}\n</code></pre> <p>For More information, see the Configuring Queue Management page of the User Guide.</p> </li> <li> <p>Configure DKIM signing keys. Read the guide for details, but the short version is below:</p> <p>Replace the domain and selector with your own, then generate signing keys with:</p> <pre><code>export DOMAIN=&lt;your_domain&gt;\nexport SELECTOR=&lt;your_selector&gt;\nsudo mkdir -p /opt/kumomta/etc/dkim/$DOMAIN\nsudo openssl genrsa -f4 -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key 1024\nsudo openssl rsa -in /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key -outform PEM -pubout -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.pub\nsudo chown kumod:kumod /opt/kumomta/etc/dkim/$DOMAIN -R\n</code></pre> </li> <li> <p>Configure the dkim_data.toml file, written to <code>/opt/kumomta/etc/policy/dkim_data.toml</code> in the following format, substituting your own DKIM signing information:</p> TOMLJSON <pre><code>[base]\n# Default selector to assume if the domain/signature block\n# doesn't specify one\nselector = \"dkim1024\"\n\n# The default set of headers to sign if otherwise unspecified\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"MIME-Version\", \"Content-Type\", \"Sender\"]\n\n# Domain blocks match based on the sender domain of the incoming message\n[domain.\"example.com\"]\nselector = 'dkim1024'\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"MIME-Version\", \"Content-Type\", \"Sender\"]\nalgo = \"sha256\"\n\n# Optional override of keyfile path Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\nfilename = \"/full/path/to/key.\"\n</code></pre> <pre><code>{\n  \"base\": {\n    // Default selector to assume if the domain/signature block\n    // doesn't specify one\n    \"selector\": \"dkim1024\",\n    // The default set of headers to sign if otherwise unspecified\n    \"headers\": [\n      \"From\",\n      \"To\",\n      \"Subject\",\n      \"Date\",\n      \"MIME-Version\",\n      \"Content-Type\",\n      \"Sender\"\n    ]\n  },\n  \"domain\": {\n    // Domain blocks match based on the sender domain of the incoming message\n    \"example.com\": {\n      \"selector\": \"dkim1024\",\n      \"headers\": [\n        \"From\",\n        \"To\",\n        \"Subject\",\n        \"Date\",\n        \"MIME-Version\",\n        \"Content-Type\",\n        \"Sender\"\n      ],\n      \"algo\": \"sha256\",\n      // Optional override of keyfile path Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\n      \"filename\": \"/full/path/to/key.\"\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>These instructions assume that the keyfiles are already created and in place, along with the appropriate DNS records. See the User Guide for more information.</p> </li> </ol> <p>You now have a basic and safe sending configuration that will allow you to move on to Starting KumoMTA.</p>"},{"location":"tutorial/installing_kumomta/","title":"Installing KumoMTA","text":"<p>Pre-built repos are available for supported Operating Systems, making installation straightforward. </p> <p>The following example is for installation on Rocky Linux, for other distros see this page of the User Guide.</p> <pre><code>sudo dnf -y install dnf-plugins-core\nsudo dnf config-manager \\\n    --add-repo \\\n    https://openrepo.kumomta.com/files/kumomta-rocky.repo\nsudo yum install kumomta\n</code></pre> <p>This installs the KumoMTA daemon to /opt/kumomta/sbin/kumod</p> <p>Note</p> <p>Alternatively you can install the kumomta-dev package in order to take advantage of the latest pre-release features. This is only recommended for testing environments.</p> <p>KumoMTA is now installed with a basic policy that allows relay from localhost, but it will need a more granular configuration policy for production use.</p> <p>Proceed to the Configuring KumoMTA section for more details.</p>"},{"location":"tutorial/next_steps/","title":"Next Steps","text":"<p>With KumoMTA installed, configured, and tested, the tutorial is complete.</p> <p>From here, proceed to the User Guide to learn more about Installation, Configuration, Operation, and Advanced Policies.</p>"},{"location":"tutorial/quickstart/","title":"Quickstart Tutorial","text":"<p>Warning</p> <p>This adbridged set of instructions assumes you are an experienced MailOps administrator looking for the basic commands needed for an install. This tutorial will not result in a production-ready install. More detailed instructions are in the next section of the tutorial. This tutorial is not intended to be a replacement for reading the full documentation, but rather will show how to install and configure KumoMTA for a specific environment and serve as a basis to your own unique deployment.</p>"},{"location":"tutorial/quickstart/#prerequisites","title":"Prerequisites","text":"<p>This tutorial requires the following:</p> <ul> <li>A basic understanding of Linux administration.</li> <li>Experience installing and managing an MTA, preferably in a high-volume sending environment.</li> <li>A provisioned physical or virtual machine.</li> <li>A minimal installer for Rocky Linux 9.</li> </ul> <p>Danger</p> <p>Reaching the inbox in bulk requires extensive knowledge and experience in both MailOps and Deliverability. If you have not previously operated a high-volume email sending environment we do not recommend taking this step lightly. Those without the requisite skills are strongly recommended to utilize a SaaS relay solution.</p> <ol> <li> <p>Provision an AWS t2.xlarge (or larger) instance (or any physical or virtual server with at least 4 CPUs, 16Gb RAM, 300Gb Hard Drive).</p> <p>Note</p> <p>The hardware here is for a medium throughput sending environment, but KumoMTA can technically run on a smaller footprint for low-volume environments. if your sending needs are smaller, you can deploy to a server with 1 CPU, 2GB RAM, and 10Gb of storage. Deployments with fewer than 4 cores are officially unsupported in production by our team.</p> </li> <li> <p>Install Rocky Linux 9. A minimal install is sufficient.</p> </li> <li> <p>Update the OS and disable Postfix if needed</p> <pre><code>sudo dnf clean all\nsudo dnf update -y\nsudo systemctl stop postfix.service\nsudo systemctl disable postfix.service\n</code></pre> </li> <li> <p>Add the KumoMTA repo to your config manager and yum install it like this:</p> <pre><code>sudo dnf -y install dnf-plugins-core\nsudo dnf config-manager \\\n    --add-repo \\\n    https://openrepo.kumomta.com/files/kumomta-rocky.repo\nsudo yum install kumomta\n</code></pre> <p>Note</p> <p>Alternatively you can install the kumomta-dev package in order to take advantage of the latest pre-release features. This is only recommended for testing environments.</p> </li> <li> <p>The instructions above will place a default configuration file at /opt/kumomta/etc/policy/init.lua and start the KumoMTA service, if the service does not start by default it can be started and enabled with the following commands:</p> <pre><code>sudo systemctl start kumomta\nsudo systemctl enable kumomta\n</code></pre> <p>Alternately you can run it manually with:</p> <pre><code>sudo /opt/kumomta/sbin/kumod --policy \\\n  /opt/kumomta/etc/policy/init.lua --user kumod&amp;\n</code></pre> <p>KumoMTA will now be installed and running the init.lua configuration from <code>/opt/kumomta/sbin/kumod</code>.  If you started it manually, the <code>&amp;</code> pushes the running process to the background, type 'fg' to bring it forward again.</p> </li> <li> <p>Test your KumoMTA configuration using telnet or the tool of your choice:</p> <pre><code>telnet localhost 25\nTrying ::1...\ntelnet: connect to address ::1: Connection refused\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\n220 localhost.localdomain KumoMTA\nehlo moto\n250-localhost.localdomain Aloha moto\n250-PIPELINING\n250-ENHANCEDSTATUSCODES\n250 STARTTLS\nMAIL FROM:test@example.com\n250 OK EnvelopeAddress(\"test@example.com\")\nRCPT TO:test@example.com\n250 OK EnvelopeAddress(\"test@example.com\")\nDATA\n354 Send body; end with CRLF.CRLF\nSubject: Test Message Using KumoMTA\n\nThis is a test.\n.\n250 OK ids=d7ef132b5d7711eea8c8000c29c33806\nquit\n221 So long, and thanks for all the fish!\n</code></pre> </li> <li> <p>View the log entries related to your test message:</p> <pre><code>sudo /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n</code></pre> <pre><code>{\n  \"type\": \"Reception\",\n  \"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n  \"sender\": \"test@example.com\",\n  \"recipient\": \"test@example.com\",\n  \"queue\": \"example.com\",\n  \"site\": \"\",\n  \"size\": 320,\n  \"response\": {\n    \"code\": 250,\n    \"enhanced_code\": null,\n    \"content\": \"\",\n    \"command\": null\n  },\n  \"peer_address\": {\n    \"name\": \"moto\",\n    \"addr\": \"127.0.0.1\"\n  },\n  \"timestamp\": 1695847980,\n  \"created\": 1695847980,\n  \"num_attempts\": 0,\n  \"bounce_classification\": \"Uncategorized\",\n  \"egress_pool\": null,\n  \"egress_source\": null,\n  \"feedback_report\": null,\n  \"meta\": {},\n  \"headers\": {},\n  \"delivery_protocol\": null,\n  \"reception_protocol\": \"ESMTP\",\n  \"nodeid\": \"d8e014c7-eaeb-4683-a56e-61324e91b1fc\"\n}\n</code></pre> <p>Note</p> <p>In the default configuration, it will take about 10 seconds for the log files to flush and show the log entries in the <code>tailer</code> output. You can speed that up by changing the <code>max_segment_duration</code> in the <code>init.lua</code> file, or through flushing the log files by restarting the server via <code>sudo systemctl restart kumomta</code>.</p> <p>These example log entries have been formatted for ease of reading in the documentation.</p> </li> </ol>"},{"location":"tutorial/quickstart/#next-steps","title":"Next Steps","text":"<p>Congratulations on completing the quickstart tutorial, some things you can do next:</p> <ol> <li> <p>Join our community Discord at https://kumomta.com/discord to ask questions and get feedback on your configuration.</p> </li> <li> <p>Sign up for the latest KumoMTA news here.</p> </li> <li> <p>Work through the full tutorial to learn more about how to set up a working install.</p> </li> <li> <p>Check out our User Guide for more detailed instructions.</p> </li> </ol>"},{"location":"tutorial/server_environment/","title":"Environmental Considerations","text":"<p>When deciding on server hardware, senders must balance vertical and horizontal scaling based on their preferences. KumoMTA is built to support both vertical and horizontal scaling, with both single-node performance of several million messages per hour, as well as support for clustered installations.</p> <p>For illustrative purposes, we will consider a sender who is sending an average of 8 million messages per day, during a core window of 8 hours per day, or one million messages per hour peak throughput.</p> <p>For this example, we will use an average message size of 50 KB, resulting in 1 Million * 50KB = 50,000,000 KB or 50GB total transfer/hour (400GB/day).</p> <p>Expressed in terms of throughput, 50GB / 3600s = 111 Mbps (0.1Gbps), something handled easily by Gigabit networking.</p> <p>This means that our build is targeting a burst speed of one million messages per hour, a common use case for larger scale senders. If your needs are lower, you can certainly provision a smaller server than what will be discussed in this section of the tutorial.</p>"},{"location":"tutorial/server_environment/#network","title":"NETWORK","text":"<p>Because this use case involves slightly over 100Mbps, most network environments will be able to handle this traffic without modification. Be sure to verify that your server (or virtual server host) is connected to a network that supports Gigabit or faster connectivity.</p>"},{"location":"tutorial/server_environment/#storage-volume","title":"STORAGE VOLUME","text":"<p>The total volume is important for calculating storage capacity.  KumoMTA does not store the full body after delivery, but it will be needed to calculate spool capacity and memory use.  In a worst case scenario, if all of your messages are deferred (temporarily undeliverable) then your delayed queue is going to need to store all messages until delivery resumes. Given that the messages relaying through the server add up to 400GB per day, you will need 400G in storage capacity to handle a full-day outage.</p> <p>Under normal circumstances, most messages will deliver in realtime, and queue depth will generally be correlated to your sending reputation; the better your sending reputation, the less spool storage you need, so there is one more good reason to maintain a good sending reputation.</p> <p>You should allocate enough spool storage to accomodate as many days of sending outage as you feel comfortable tolerating, in most cases a day's worth of storage is sufficient, given that you typically don't see full outbound outages that last more than a few hours in well-managed datacenters.</p> <p>Note</p> <p>Spool storage is calculated as ((Average_Message_Size_in_bytes + 512) x message volume)</p> <p>Logs will also consume drive space. The amount of space is highly dependent on your specific configuration, but based on the default server policy, each log line will consume about 250-500 bytes on disk thanks to KumoMTA's use of <code>zstd</code> compression, and there may be an average of 2-5 log lines per message.  In this example we are going to assume logging at a rate of 2KB per message in order to include a safety margin.</p> <p>So we have 2KB * 8 Million messages = ~16.3Gb (per day of log storage). If you are looking at storing 30 days of logs, this results in roughly 500GB of storage for logs.</p> <p>You are also going to need about around 100GB for the OS (including keeping OS logs and other /var elements without the immediate risk of disk overflow), resulting in a total storage allocation of 1Tb. Note that this assumes retention of a full month of MTA logs, a full day of spool delay, and a sizable partition for OS logs. This number can be brought down significantly through log rotation and a more conservative deffered spool estimate.</p> <p>When installing the OS, the disks should be partitioned to keep the spool and logs separate from the OS. In addition, separating the /var directory (other than the directories within /var that are used for KumoMTA) to its own partition is highly recommended.</p>"},{"location":"tutorial/server_environment/#cpu","title":"CPU","text":"<p>KumoMTA is built on a multithreaded scheduler architecture and takes full advantage of multiple CPU cores. While it can operate on a single (v)CPU, we recommend starting with at least four CPU cores to allow for workload between things like DKIM signing, connection handling, and IO management to be spread out more efficiently.</p>"},{"location":"tutorial/server_environment/#ram","title":"RAM","text":"<p>KumoMTA will process as many messages in RAM as possible, so more is better.  We recommend 16Gb RAM, but you will see benefits from adding more as your message processing volume increases.</p> <p>So, from all of that we see a need for 4 vCPUs, 16Gb RAM, and 1TB of storage. In AWS, that translates to somewhere between an xlarge to a 4xlarge instance size, depending on instance type.</p> <p>With our server selected, we can install the OS and prepare it.</p>"},{"location":"tutorial/starting_kumomta/","title":"Starting KumoMTA","text":"<p>If you followed all the instructions above without errors, you should now have a working MTA on a properly sized server.</p> <p>Check to see if it is already running from the install instructions above:</p> <pre><code>sudo systemctl status kumomta\n</code></pre> <p>If the service is already running, you will need to restart it to apply the changes made above:</p> <pre><code>sudo systemctl restart kumomta\n</code></pre> <p>Start the MTA with this:</p> <pre><code>sudo systemctl start kumomta\n</code></pre> <p>You can enable it to restart as a service with a reboot with:</p> <pre><code>sudo systemctl enable kumomta\n</code></pre> <p>Alternately you can start it manually with:</p> <pre><code> sudo /opt/kumomta/sbin/kumod --policy \\\n /opt/kumomta/etc/policy/init.lua --user kumod&amp;\n</code></pre> <ul> <li>Using sudo allows KumoMTA to run as a privileged user so it can access port 25 which is needed to deliver via SMTP to the internet.</li> <li>The daemon <code>kumod</code> is the MTA.</li> <li>The directive --policy makes kumod load the 'init.lua' file as configuration policy.</li> <li>Because we launched with sudo, you need to use the directive --user and provide a valid user to assign responsibility to.</li> <li>The line ends with a <code>&amp;</code> that forces the daemon to run in the background and returns you to a usable prompt (use <code>fg</code> to bring it back to the foreground).</li> </ul> <p>You can also get immediate feedback by pre-pending <code>KUMOD_LOG=kumod=info</code> (or debug for more detail):</p> <pre><code>sudo KUMOD_LOG=kumod=info /opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --user kumod&amp;\n</code></pre> <p>If all goes well, it should return a PID and drop you back to a Linux prompt.</p> <p>If KumoMTA does not start, refer to the Troubleshooting Page of the User Guide.</p>"},{"location":"tutorial/system_preparation/","title":"System Preparation","text":"<p>Now that we know what to build, lets go ahead and build it.</p>"},{"location":"tutorial/system_preparation/#os-installation","title":"OS Installation","text":"<p>For AWS users:</p> <ul> <li>Log into AWS, select EC2 and hit the Launch Instance button.</li> <li>Give this server a name and then search for \"Rocky\" in the OS images, select \"Rocky 9\".</li> <li>Under Instance Type, select a t2.xlarge, provide your keypair for login or create a pair if necessary.</li> <li>In the Network Settings, select or create a security group that includes ports 22,25,80,443,587,2025. These will be important for sending and receiving email in a number of ways.</li> <li>Finally, modify the storage volume to 1TB (or anything over 300Gb) and click Launch Instance.</li> </ul> <p>When AWS has finished building your server instance, you can select it and connect. I prefer to find the SSH client information and use a remote terminal emulator like Putty or Terminal like this:</p> <pre><code>ssh -i \"yourkeyname.pem\" rocky@ec2-\\&lt;pub-lic-ip\\&gt;.&lt;zone&gt;.compute.amazonaws.com\n</code></pre>"},{"location":"tutorial/system_preparation/#os-preparation","title":"OS Preparation","text":"<p>Regardless of what system you deploy, there are things you need to do to prepare the OS before installing the MTA.</p> <ul> <li>Update the installed packages</li> <li>Install basic testing and support tools</li> <li>Turn off services that are wasteful or can interfere</li> <li>Tune the use of memory and file access for best performance</li> <li>Automate updates and startup for resiliency</li> </ul> <p>Note</p> <p>Rocky Linux is very similar to RedHat Enterprise Linux (RHEL), as is Alma and CentOS. The instructions below are shown for a Rocky 9 system but with slight modification, should work for any DNF package management system. For Amazon Linux (AL2) the instructions are identical, but replace \"dnf\" with \"yum\".</p> <pre><code># Do basic updates\nsudo dnf clean all\nsudo dnf update -y\n\n# Grab some handy tools\nsudo dnf install -y wget bind bind-utils telnet firewalld\n\nsudo systemctl start named\nsudo systemctl enable named\n</code></pre> <p>For the sake of simplicity you can automate daily updates of installed packages using <code>cron</code>:</p> <pre><code># Make sure it all stays up to date\n# Run a dnf update at 3AM daily\necho \"0 3 * * * root /usr/bin/dnf update -y &gt;/dev/null 2&gt;&amp;1\" | \\\n sudo tee /etc/cron.d/dnf-updates &gt;/dev/null\n</code></pre> <p>Next configure the local firewall:</p> <pre><code># Build a basic firewall\nsudo echo \"ZONE=public\n\" | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-eth0\n\nsudo systemctl stop firewalld\nsudo systemctl start firewalld.service\nsudo firewall-cmd --set-default-zone=public\nsudo firewall-cmd --zone=public --change-interface=eth0\nsudo firewall-cmd --zone=public --permanent --add-service=http\nsudo firewall-cmd --zone=public --permanent --add-service=https\nsudo firewall-cmd --zone=public --permanent --add-service=ssh\nsudo firewall-cmd --zone=public --permanent --add-service=smtp\nsudo firewall-cmd --zone=public --permanent --add-port=587/tcp\n\nsudo systemctl enable firewalld\nsudo firewall-cmd --reload\n</code></pre> <p>Finally, disable unnecessary services like postfix and qpidd:</p> <pre><code>sudo systemctl stop postfix.service\nsudo systemctl disable postfix.service\nsudo systemctl stop qpidd.service\nsudo systemctl disable qpidd.service\n</code></pre>"},{"location":"tutorial/system_preparation/#creating-a-self-signed-certificate","title":"Creating a Self-Signed Certificate","text":"<p>Before you continue, you should ensure that your system has a valid SSL Certificate.  If you do not have one available, a self-signed certificate is acceptable for most purposes (Change the certificate variables before executing this):</p> <pre><code># For the certificate enter your FQDN\nMYFQDN=\"my.company.com\"\n\n# For the certificate, what country code are you in? (CA,US,UK, etc)\nCERT_CO=US\n\n# For the certificate, what State or Province are you in? (Alberta, California, etc)\"\nCERT_ST=\"California\"\n\n# For the certificate, what city are you in? (Edmonton, Houston, etc)\"\nCERT_LO=\"Los Angeles\"\n\n# For the certificate, what is the name of your company or organization\"\nCERT_ORG=\"My Company\"\n\n# Generate private key\nopenssl genrsa -out ca.key 2048\n\n# Generate CSR\nopenssl req -new -key ca.key -out ca.csr -subj \"/C=$CERT_CO/ST=$CERT_ST/L=$CERT_LO/O=$CERT_ORG/CN=$MYFQDN/\"\n\n# Generate Self Signed Key\nopenssl x509 -req -days 365 -in ca.csr -signkey ca.key -out ca.crt\n\n# Copy the files to the correct locations\nsudo mv -f ca.crt /etc/pki/tls/certs\nsudo mv -f ca.key /etc/pki/tls/private/ca.key\nsudo mv -f ca.csr /etc/pki/tls/private/ca.csr\n\n# If Apache HTTPD is installed, update the SSL config (IGNORE ERRORS)\nsudo sed -i 's/SSLCertificateFile \\/etc\\/pki\\/tls\\/certs\\/localhost.crt/SSLCertificateFile \\/etc\\/pki\\/tls\\/certs\\/ca.crt/' /etc/httpd/conf.d/ssl.conf\nsudo sed -i 's/SSLCertificateKeyFile \\/etc\\/pki\\/tls\\/private\\/localhost.key/SSLCertificateKeyFile \\/etc\\/pki\\/tls\\/private\\/ca.key/' /etc/httpd/conf.d/ssl.conf\n</code></pre> <p>With this preparation complete, we're ready to Install KumoMTA.</p>"},{"location":"tutorial/testing_kumomta/","title":"Testing KumoMTA","text":"<p>Now that you have KumoMTA installed, you should test it from the command line of the installed host. This is easy if you installed the basic tools as described earlier.</p> <p>Note that the default SMTP listener is on port 25, so we have use that in these examples.</p>"},{"location":"tutorial/testing_kumomta/#telnet-method-for-smtp","title":"Telnet method for SMTP","text":"<p>Start a telnet session with <code>telnet localhost 25</code>, replacing youremail@address.com with your actual email address:</p> <pre><code>ehlo moto\nmail from:youremail@address.com\nrcpt to:youremail@address.com\nDATA\nfrom:youremail@address.com\nto:youremail@address.com\nsubject: My First Email\n\nHey, this is my first email!\n.\n</code></pre> <p>Note</p> <p>If you have not specifically requested outbound use of port 25 from AWS, then it is very possible the message will not be delivered.</p>"},{"location":"tutorial/testing_kumomta/#curl-method-for-http-api","title":"Curl method for HTTP API","text":"<pre><code>$ curl -H 'Content-Type: application/json' 'http://127.0.0.1:8000/api/inject/v1' -d '{\n    \"envelope_sender\": \"noreply@example.com\",\n    \"content\": \"Subject: hello\\n\\nHello there\",\n    \"recipients\": [\n        {\n            \"email\": \"recipient@example.com\"\n        }\n    ]\n}'\n</code></pre> <p>See the HTTP injection API reference for more information.</p>"},{"location":"tutorial/testing_kumomta/#using-swaks-for-testing","title":"Using Swaks for testing","text":"<p>Swaks, the Swiss Army Knife for SMTP by John Jetmore is a fantastic tool for testing.</p> <p>Install Swaks:</p> <pre><code>curl -O https://jetmore.org/john/code/swaks/files/swaks-20201014.0.tar.gz\ntar -xvzf swaks-20201014.0.tar.gz\nchmod 755 ./swaks-20201014.0/swaks\n</code></pre> <p>Basic Swaks usage:</p> <pre><code>swaks --to user@example.com --server 127.0.0.1 --port 25\n</code></pre> <p>Regardless of testing method used, the next step is to check the logs.</p>"},{"location":"userguide/","title":"User Guide","text":"<p>This is the KumoMTA User Guide.</p> <p>The User Guide is intended for those who have a general understanding of operating an MTA and are looking for information on how to use KumoMTA in particular.</p> <p>Those who are brand new to email operations, or those who just want the minimum information needed to get started, should refer to the Tutorial.</p> <p>Those who are experienced at using KumoMTA and are looking for more detailed information on specific commands and functions may be better served by the Reference Manual.</p> <p>The user guide is structured in the typical order a user would need in the process of setting up and administrating a server:</p> <ul> <li>General - Information on the project, its history, and how to interact with the developer team.</li> <li>Installation - Information on how to install KumoMTA for a variety of use cases and platforms.</li> <li>Configuration - An explanation of how to configure KumoMTA for typical use cases.</li> <li>Operation - Information on how to manage and interact with a KumoMTA server.</li> <li>Policy - A deeper dive into the policy capabilities of KumoMTA and how to implement advanced use cases.</li> <li>Clustering - Information related to deploying KumoMTA in a multi-node cluster environment.</li> <li>Performance - A description of KumoMTA performance and how to tune for specific use cases.</li> <li>Integrations - Information on how to integrate KumoMTA with external tools and platforms.</li> </ul>"},{"location":"userguide/clustering/","title":"Clustering","text":"<p>KumoMTA is designed to be used in high-volume sending environments where cluster capabilities are essential to effective and manageable scaling.</p> <p>To address these needs, KumoMTA has several features and integrations designed around cluster management.</p>"},{"location":"userguide/clustering/#implementation-approach","title":"Implementation Approach","text":"<p>The KumoMTA team works from a philosophy of \"don't re-invent the wheel\". To the degree possible KumoMTA is designed to work with existing solutions rather than implement our own version of existing tools.</p> <p>For example: KumoMTA does not provide a configuration distribution or versioning tool because there are numerous existing options including Git, Puppet, Chef, K8s, etc.</p>"},{"location":"userguide/clustering/#vertical-vs-horizontal-scaling","title":"Vertical vs Horizontal Scaling","text":"<p>While many existing users coming from commercial MTAs with per-node licensing tend toward vertical scaling, KumoMTA can be either vertically or horizontally scaled.</p> <p>Vertical scaling with high-performance hardware can see over ten million messages per hour on a single node, where horizontal scaling environments tend to aim for between two to four million messages per hour per node. Those leveraging orchestration solutions such as Kubernetes will likely prefer a horizontal scaling architecture.</p>"},{"location":"userguide/clustering/#shared-vs-node-specific-configuration","title":"Shared Vs. Node-Specific Configuration","text":"<p>While it is possible to configure KumoMTA nodes in a cluster with distinct configurations on a per-node basis, the traffic shaping approach used in KumoMTA is most effective when all nodes share the same IP configuration using proxies.</p> <p>In this approach the nodes share a common configuration (implemented using the preferred method of the user) with the <code>Egress_Source</code> configured to use a proxy for sending. Alternatively Reverse NAT or port forwarding could also be used.</p> <p>KumoMTA supports both HAPROXY and SOCKS5, see the Proxy page for information on using KumoMTA with outbound proxies.</p> <p>KumoMTA includes a SOCKS5 proxy implementation, see the KumoProxy page for more information.</p>"},{"location":"userguide/clustering/#managing-shared-secrets","title":"Managing Shared Secrets","text":"<p>One of the most straightforward ways to manage secrets such as DKIM keys and authentication credentials is using a Vault.</p> <p>For more information on using Vault for shared secrets see our Storing Secrets in Hashicorp Vault page.</p>"},{"location":"userguide/clustering/deployment/","title":"Deployment Architecture","text":""},{"location":"userguide/clustering/deployment/#single-node","title":"Single Node","text":"<p>The functional components for a single node look like this:</p> <pre><code>flowchart LR\n\nsubgraph \"MTA Node\"\n    direction LR\n    kumod1[\"kumod\"]\n    tsa_daemon1[\"tsa-daemon\"]\nend\n\n    kumod1 ---&gt; tsa_daemon1</code></pre> <ul> <li><code>kumod</code> is the MTA service</li> <li><code>tsa-daemon</code> is the Traffic Shaping Automation daemon, which   processes log information to feed back and adjust the shaping   configuration of the MTA.</li> </ul>"},{"location":"userguide/clustering/deployment/#multiple-node","title":"Multiple Node","text":"<p>When you have a handful of nodes, you might deploy like this, with a TSA daemon running locally on each MTA node, and each MTA node publishing data to all of the TSA daemons.  Throttle state is stored in redis, which can be deployed in a clustered configuration if desired:</p> <pre><code>flowchart LR\n\nsubgraph \"MTA Node 1\"\n    direction LR\n    kumod1[\"kumod\"]\n    tsa_daemon1[\"tsa-daemon\"]\nend\n\nsubgraph \"MTA Node 2\"\n    direction LR\n    kumod2[\"kumod\"]\n    tsa_daemon2[\"tsa-daemon\"]\nend\n\nredis[(\"Redis (Throttles)\")]\n\n    kumod1 --&gt; redis\n    kumod1 ---&gt; tsa_daemon1\n    kumod1 ---&gt; tsa_daemon2\n    kumod2 --&gt; redis\n    kumod2 ---&gt; tsa_daemon2\n    kumod2 ---&gt; tsa_daemon1\n</code></pre>"},{"location":"userguide/clustering/deployment/#many-nodes","title":"Many Nodes","text":"<p>When you have a large number of nodes, you might factor out the TSA daemon service to a sub-cluster to avoid a full-mesh of log traffic between all of the nodes, as shown in the diagram below, which omits the redis portion for the sake of clarity. You would deploy and run a smaller number of TSA nodes than MTA nodes:</p> <pre><code>flowchart LR\n\nsubgraph \"MTA 1\"\n    kumod1[\"kumod\"]\nend\n\nsubgraph \"MTA 2\"\n    kumod2[\"kumod\"]\nend\n\nsubgraph \"MTA 3\"\n    kumod3[\"kumod\"]\nend\n\n\nsubgraph \"TSA 1 of N\"\n    tsa_daemon1[\"tsa-daemon\"]\nend\n\n    kumod1 --&gt; tsa_daemon1\n    kumod2 --&gt; tsa_daemon1\n    kumod3 --&gt; tsa_daemon1\n</code></pre>"},{"location":"userguide/clustering/deployment/#proxies-for-egress","title":"Proxies for Egress","text":"<p>We recommend the use of a proxy for egress; this allows each node to have an identical configuration while still being able to use an appropriate source IP address. This approach results in a simpler configuration overall and makes it easier to load balance and scale the deployment up or down.</p> <p>We support our own SOCKS-5 based proxy implementation as well as ha-proxy.</p> <pre><code>flowchart LR\n\nsubgraph \"MTA 1\"\n    kumod1[\"kumod\"]\nend\n\nsubgraph \"MTA 2\"\n    kumod2[\"kumod\"]\nend\n\nsubgraph \"MTA 3\"\n    kumod3[\"kumod\"]\nend\n\nsubgraph \"Proxy 1 of N\"\n    proxy\nend\n\nnet(Destination)\n\n    kumod1 --&gt; proxy\n    kumod2 --&gt; proxy\n    kumod3 --&gt; proxy\n    proxy --&gt; net</code></pre>"},{"location":"userguide/clustering/eventdata/","title":"Aggregating Event Data","text":"<p>Clustered environments typically don't aggregate log files in order to collect event data, instead either processing the log files locally and then pushing the event data out, or using webhooks.</p> <p>KumoMTA supports several methods commonly used for event data aggregating:</p>"},{"location":"userguide/clustering/eventdata/#webhooks","title":"Webhooks","text":"<p>KumoMTA can publish log information to HTTP endpoints in the form of webhooks, which can be received and consumed by log processing applications.</p> <p>For more information see the webhooks page of the userguide.</p>"},{"location":"userguide/clustering/eventdata/#amqp","title":"AMQP","text":"<p>KumoMTA also supports relaying log data via AMQP. </p> <p>For more information see the AMQP page of the userguide.</p>"},{"location":"userguide/clustering/eventdata/#kafka","title":"Kafka","text":"<p>KumoMTA supports publishing log events (as well as other messages) via Apache Kafka.</p> <p>For more information see the Kafka page of the userguide.</p>"},{"location":"userguide/clustering/kubernetes/","title":"Deploying KumoMTA on Kubernetes","text":"<p>For an example of how to deploy KumoMTA on Kubernetes, see this community contribution: https://github.com/dschaaff/kumomta-k8s-demo.</p>"},{"location":"userguide/clustering/nodeid/","title":"Node ID","text":"<p>Each KumoMTA (<code>kumod</code>) instance can have its own <code>NodeId</code>, which is a UUID intended identify that specific instance within your own local cluster, help with disambiguation during reporting, and also for future configuration management/provisioning related functionality.</p> <p>The <code>NodeId</code> is reported as the <code>nodeid</code> field in the Log Record.</p> <p>In the default configuration, KumoMTA will use the file <code>/opt/kumomta/etc/.nodeid</code> to persist the <code>NodeId</code>.  If that file doesn't exist, a new ID will be generated and stored in that location.</p> <p>If persisting the <code>NodeId</code> isn't possible, we fall back to generating an id as described in the section below.</p>"},{"location":"userguide/clustering/nodeid/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables influence the Node ID:</p> <ul> <li> <p><code>KUMO_NODE_ID</code> - if this is set to a valid UUID, its value will be used as     the <code>NodeId</code> for the instance.  You might contrive for your orchestration     system to set this if you want total control over the relationship between     the machine and node id.</p> </li> <li> <p><code>KUMO_NODE_ID_PATH</code> - this can be set to an alternative location into which     the nodeid should be stored.  If this is not set, the path is assumed to be     <code>/opt/kumomta/etc/.nodeid</code>.  If the path is not writable for some reason     (eg: permission denied), then a fallback nodeid will be computed.</p> </li> </ul>"},{"location":"userguide/clustering/nodeid/#fallback-node-id","title":"Fallback Node ID","text":"<p>If <code>NodeId</code> cannot be persisted then the following fallback procedure will be used to compute an ID that will have a consistent value across restarts of the kumod process:</p> <ul> <li> <p>First attempt to determine the MAC address of the primary network interface     on the system</p> </li> <li> <p>If we cannot determine the MAC address then use the POSIX <code>gethostid(3)</code>     call to obtain a 32-bit stable identifier for the system, which is extended     to 6 bytes to make it the same size and shape as a MAC address.</p> </li> </ul> <p>The MAC address bytes are then used to compute a V1 (time based) UUID with a fixed timestamp, which produces a UUID that looks something like <code>00000000-0000-1000-8000-XXXXXXXXXXXX</code> where the X's are the hex digits from the MAC address.</p> <p>Neither the true MAC address nor especially the <code>gethostid(3)</code> fallback are ideal if the network interface might change across the lifetime of a logical instance, so we recommend fixing any permission errors that might be preventing persisting a true random UUID or alternatively, adjusting your node provisioning to pre-define a <code>KUMO_NODE_ID</code> environment variable if you have stronger opinions about how you want to provision and manage these things.</p>"},{"location":"userguide/clustering/scaling/","title":"Scaling Up and Down","text":"<p>One advantage of horizontal scaling in virtualized environments is that resources can be conserved by scaling the KumoMTA cluster up and down in response to sending patterns.</p> <p>Note</p> <p>Auto-scaling is a complicated subject that is not recommended except for those with extensive experience in autoscaling technologies. For most senders, the predictable daily sending patterns are adequate for scheduling scaling, with alerting when the cluster size is too small.</p> <p>The most common install approach for scaling clusters involves Docker. For examples on deploying more advanced docker architectures, see https://github.com/KumoCorp/kumomta/tree/main/examples.</p> <p>While the exact implementation of a scaling cluster is up to the user and their tools of choice, KumoMTA offers several tools and APIs that can ease the process.</p>"},{"location":"userguide/clustering/scaling/#monitoring-node-availability","title":"Monitoring Node Availability","text":"<p>When a node is brought online there is some time required for the node to become ready for message injection.</p> <p>To check on the availability of a node, you can check the <code>liveness</code> API on that node:</p> <pre><code>$ curl -X GET \"http://127.0.0.1:8000/api/check-liveness/v1\"\n</code></pre> <p>A <code>200</code> response indicates that the node is available and ready to receive messages.</p>"},{"location":"userguide/clustering/scaling/#draining-the-spool-before-shutdown","title":"Draining The Spool Before Shutdown","text":"<p>When a node needs to come offline the following steps can be used:</p> <ol> <li>Remove the node from the load balancer to prevent future injections.</li> <li> <p>Call the rebind    endpoint of the KumoMTA API to redirect all messages back to the load    balancer. In the following example the load balancer is an IP literal in    square brackets, a hostname can be used without the square brackets:</p> <pre><code>$ kcli rebind --reason=\"Your reason here\" --everything --set 'routing_domain=[192.168.1.100]'\n</code></pre> </li> <li> <p>Monitor the metrics API    endpoint to determine when the node's queues are empty, you can then shut    down the node.</p> </li> </ol>"},{"location":"userguide/clustering/throttles/","title":"Implementing Shared Throttles","text":"<p>When KumoMTA is deployed in a clustered environment using shared IPs the nodes will need to be able to use shared counters in order to adhere to traffic shaping rules.</p> <p>In a clustered deployment KumoMTA can use Redis to store and track counters related to traffic shaping rules, and multiple nodes can leverage the same Redis server(s) to share common throttles.</p> <p>For more information see the configure_redis_throttles page in the Reference Manual.</p>"},{"location":"userguide/clustering/trafficshapingautomation/","title":"Deploying Traffic Shaping Automation","text":"<p>The <code>tsa-daemon</code> process communicates with KumoMTA nodes to process tempfail and permfail events and issue commands to the KumoMTA nodes based on those events.</p> <p>When running in a clustered environment each node needs to talk to each <code>tsa-daemon</code> process running in the cluster.</p> <p>This can either be architected as one daemon per node or one or more daemons common to the cluster (see the Deployment Architecture page).</p> <p>When configuring clustered Traffic Shaping Automation, the steps are similar to what is covered in the Configuring Traffic Shaping Automation page, but with some minor modifications.</p> <ol> <li> <p>In the <code>tsa_init.lua</code> file, the <code>tsa_init</code> handler must use a <code>trusted_hosts</code> list that includes all nodes in the cluster:</p> <pre><code>kumo.on('tsa_init', function()\n  tsa.start_http_listener {\n    listen = '0.0.0.0:8008',\n    trusted_hosts = { '127.0.0.1', '192.168.1.0/24', '::1' },\n  }\nend)\n</code></pre> </li> <li> <p>In the <code>init.lua</code> file, the call to <code>shaping:setup_with_automation</code> must be modified to include publishing to all the TSA daemon instances:</p> <pre><code>local shaper = shaping:setup_with_automation {\n    publish = { 'http://127.0.0.1:8008', 'http://192.168.1.10:8008' },\n    subscribe = { 'http://127.0.0.1:8008' },\n    extra_files = { '/opt/kumomta/etc/policy/shaping.toml' },\n}\n</code></pre> </li> </ol> <p>The KumoMTA nodes only need to subscribe to a single tsa-daemon instance, or can subscribe to a load balancer for fault tolerance.</p>"},{"location":"userguide/configuration/bounce/","title":"Configuring Bounce Classification","text":"<p>By default, the logs will contain extensive information on the responses provided by a remote host during a delivery attempt:</p> <pre><code>// The response from the peer, if applicable\n\"response\": {\n    // the SMTP status code\n    \"code\": 250,\n\n    // The ENHANCEDSTATUSCODE portion of the response parsed\n    // out into individual fields.\n    // This one is from a \"2.0.0\" status code\n    \"enhanced_code\": {\n        \"class\": 2,\n        \"subject\": 0,\n        \"detail\": 0,\n    },\n\n    // the remainder of the response content\n    \"content\": \"OK ids=8a5475ccbbc611eda12250ebf67f93bd\",\n\n    // the SMTP command verb to which the response was made.\n    // eg: \"MAIL FROM\", \"RCPT TO\" etc. \".\" isn't really a command\n    // but is used to represent the response to the final \".:\n    // we send to indicate the end of the message payload.\n    \"command\": \".\"\n},\n</code></pre> <p>This information includes the IANA Status Codes provided by the remote host, but there are a large number of codes that can be interpreted in a variety of ways, and many mailbox providers use status codes differently.</p> <p>To make it easier to handle bounces, the Bounce Classifier can be configured:</p> <pre><code>kumo.on('init', function()\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumomta',\n  }\n  kumo.configure_bounce_classifier {\n    files = {\n      '/opt/kumomta/share/bounce_classifier/iana.toml',\n    },\n  }\nend)\n</code></pre> <p>Once configured, the Bounce Classifier will populate the bounce_classification field in the logs with the applicable category.</p> <p>An example of classification rules:</p> TOMLJSON <pre><code>[rules]\nInvalidRecipient = [\n  \"^(451|550) [45]\\\\.1\\\\.[1234] \",\n  \"^45[02] [45]\\\\.2\\\\.4 \", # Mailing list expansion\n  \"^5\\\\d{2} [45]\\\\.7\\\\.17 \", # RRVS: Mailbox owner has changed\n]\nBadDomain = [\n  \"^(451|550) [45]\\\\.1\\\\.10 \", # NULL MX\n  \"^5\\\\d{2} [45]\\\\.7\\\\.18 \", # RRVS: domain owner has changed\n]\n</code></pre> <pre><code>{\n  \"rules\": {\n    \"InvalidRecipient\": [\n      \"^(451|550) [45]\\\\.1\\\\.[1234] \",\n      \"^45[02] [45]\\\\.2\\\\.4 \",\n      \"^5\\\\d{2} [45]\\\\.7\\\\.17 \"\n    ],\n    \"BadDomain\": [\n      \"^(451|550) [45]\\\\.1\\\\.10 \",\n      \"^5\\\\d{2} [45]\\\\.7\\\\.18 \"\n    ]\n  }\n}\n</code></pre> <p>Users can create their own classification rules file by copying the default file, editing it, and adding the path to their custom rules file to the files option in the kumo.configure_bounce_classifier function call. Each defined rules file will be merged into the full ruleset.</p> <p>For additional information, see the reference manual page on bounce classification.</p>"},{"location":"userguide/configuration/bounce/#configuring-out-of-band-bounce-processing","title":"Configuring Out-Of-Band Bounce Processing","text":"<p>Not all bounces occur while the server is connected to the remote host. It is not uncommon for a remote host to accept a message, perform further processing, and then determine that the message should be rejected. This can be because of user validation, AntiVirus/AntiSpam processing, or other post-connection logic. When a remote host rejects a message after accepting it, RFCs require that a Message Disposition Notification (MDN) message be sent to the return path address of the message specified in the MAIL FROM command during the relay session. See https://en.wikipedia.org/wiki/Bounce_message for more information.</p> <p>The KumoMTA server can process these MDN messages, but must be configured to know which domains are candidates for OOB bounce processing.  This is most simply accomplished using the listener domains policy helper, with a snippet like this:</p> TOMLJSON <pre><code>[\"bounce.examplecorp.com\"]\n# accept and log OOB messages sent to bounce.examplecorp.com\nlog_oob = \"LogThenDrop\"\n</code></pre> <pre><code>{\n  \"bounce.examplecorp.com\": {\n    // accept and log OOB messages sent to bounce.examplecorp.com\n    \"log_oob\": \"LogThenDrop\"\n  }\n}\n</code></pre>"},{"location":"userguide/configuration/bounce/#oob-message-disposition-after-processing","title":"OOB Message Disposition After Processing","text":"<p>For most use cases, the desired outcome after a DSN message is processed is to discard the message, but in some cases it can be desirable to forward the message for further processing or storage, especially during testing and migration.</p> <p>To queue a message after processing, add <code>log_oob = \"LogThenRelay\"</code> to the listener domain configuration:</p> TOMLJSON <pre><code>[\"bounce.examplecorp.com\"]\n# accept and log OOB messages send to bounce.examplecorp.com\nlog_oob = \"LogThenRelay\"\n</code></pre> <pre><code>{\n  \"bounce.examplecorp.com\": {\n    // accept and log OOB messages send to bounce.examplecorp.com\n    \"log_oob\": \"LogThenRelay\"\n  }\n}\n</code></pre> <p>In addition, it should be noted that the MX record for your domain will still be pointed at the KumoMTA instance, which means that in order to avoid a mail loop you will need to configure routing for the domain to specify where the message should be relayed to from the KumoMTA instance:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  if msg:recipient().domain == 'bounce.examplecorp.com' then\n    -- Re-route the message to the intended destination\n    msg:set_meta('routing_domain', '[192.168.1.100]')\n\n    -- In earlier versions of KumoMTA, you need to set the queue\n    -- this way instead\n    -- msg:set_meta('queue', '[192.168.1.100]')\n  end\nend)\n</code></pre>"},{"location":"userguide/configuration/concepts/","title":"Configuration Concepts","text":"<p>KumoMTA uses Lua in place of a more traditional formatted configuration file.</p> <p>Lua is a surprisingly powerful configuration language, allowing you to either statically define configuration or dynamically build it by pulling from multiple data sources.</p> <p>While using a scripting language for configuration may sound complicated, in practice many configurations end up being very succinct and readable.  Take a look at the example policy to see how a Lua configuration can appear quite similar to a traditional configuration file.</p> <p>For more information on implementing policies in KumoMTA, refer to the policy chapter.</p>"},{"location":"userguide/configuration/concepts/#configuration-location","title":"Configuration Location","text":"<p>By default, the server will load from <code>/opt/kumomta/etc/policy/init.lua</code> on startup. We recommend using this location, but information on starting the server with an alternate path can be found in the chapter on starting KumoMTA.</p>"},{"location":"userguide/configuration/concepts/#configuration-scopes","title":"Configuration Scopes","text":"<p>To better understand how a KumoMTA configuration is built, it helps to review the general flow of a message through the KumoMTA server. This is covered in more detail in the Queues chapter of the reference manual but will be summarized here.</p> <pre><code>graph TD\n   SQ[\"Scheduled Queue: campaign:tenant@domain.com\"]\n   SMTPL[\"ESMTP Listener\"]\n   HTTPI[\"Injection API\"]\n   RQ1[\"Ready Queue: 10.0.0.1-&gt;MX(domain.com)\"]\n   RQ2[\"Ready Queue: 10.0.0.2-&gt;MX(domain.com)\"]\n   POOL[\"egress pool\"]\n   IP1[\"Source: 10.0.0.1\"]\n   IP2[\"Source: 10.0.0.2\"]\n   MAINT[\"Queue Maintainer\"]\n   DESTSITE[\"domain.com\"]\n\n   SMTPL --&gt; SQ\n   HTTPI --&gt; SQ\n   SQ --&gt; MAINT\n   IP1 --&gt; POOL\n   IP2 --&gt; POOL\n   POOL -- per tenant:domain config --&gt; MAINT\n   MAINT -- throttle per tenant:domain config --&gt; RQ1\n   MAINT -- throttle per tenant:domain config --&gt; RQ2\n   RQ1 -- throttle per source:domain config\\nconnect via 10.0.0.1 --&gt; DESTSITE\n   RQ2 -- throttle per source:domain config\\nconnect via 10.0.0.2 --&gt; DESTSITE</code></pre> <p>1) A message is injected into the KumoMTA server. This is affected by configuring either an SMTP Listener or an HTTP Listener.</p> <p>2) The message is assigned into a Scheduled Queue based on the combination of its campaign, tenant, and destination domain. If there is no defined campaign or tenant, the message is placed in a queue based on the elements that are present.</p> <p>At this point, the behavior of the queue can be configured to control things such as the age of a message, the retry intervals, and the routing of a message. These options are described in the Configuring Queue Management chapter.</p> <p>3) The KumoMTA server moves the message from the Scheduled Queue into the Ready Queue based on retry intervals configured for the Standby Queue. If a message is on its first attempt, it will be moved to the Ready Queue immediately.</p> <p>4) Messages move from the Ready Queue to their destination via an egress path that was configured for the Ready Queue. This egress path is defined as a combination of an egress source and a site name. Traffic shaping and other similar options are configured based on this combination, see the Configuring Traffic Shaping chapter for more information.</p> <ul> <li> <p>The egress source is a configured structure that defines the name, source IP, and ehlo domain of a given pathway, and it is added to an egress pool, which the message is assigned to as part of the queue config. Note: While routing is assigned at the egress pool level, traffic shaping happens at the egress source level.</p> </li> <li> <p>The site name is an identifier string created by merging the combined MX hostnames for a given destination domain. This approach allows the server to queue and throttle based not on the destination domain for a given message, but on the aggregate of all domains that share the same set of MXes.</p> </li> </ul> <p>5) All delivery attempts are logged, and any messages that receive a 4xx tempfail response from the remote host are returned to the Scheduled Queue to await a retry attempt. See the Configuring Logging chapter for more information on logging.</p>"},{"location":"userguide/configuration/concepts/#configuration-structure","title":"Configuration Structure","text":"<p>There is a lot of flexibility in how a KumoMTA policy file is laid out, but a few things are generally consistent:</p>"},{"location":"userguide/configuration/concepts/#init-event","title":"Init Event","text":"<p>The majority of the base server configuration will reside within an init event handler. The init event is fired when the server first starts up, making it the appropriate time for basic server configuration.</p> <p>Because these attributes are only loaded on init, an explicit reload must be triggered when anything in the init handler is changed, whether the change is in the policy script itself or a change in a data source or file accessed by the policy script.</p> <p>An example:</p> <pre><code>kumo.on('init', function()\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumomta/data',\n    kind = 'RocksDB',\n  }\nend)\n</code></pre>"},{"location":"userguide/configuration/concepts/#realtime-events","title":"Realtime Events","text":"<p>Attributes that are needed at the time of queueing and sending are handled in events that are called repeatedly as messages pass through the server. Any such events are constantly firing, and as such any file or data source access involved in those events will update immediately unless caching is configured.</p> <p>That said, any modification to the policy script itself is subject to caching of the Lua policy, which is refreshed every 300 seconds or 1024 executions by default.</p> <p>An example:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  return kumo.make_queue_config {\n    egress_pool = tenant,\n  }\nend)\n</code></pre>"},{"location":"userguide/configuration/concepts/#external-data","title":"External Data","text":"<p>Because the configuration is implemented through policy, the traditional practice of breaking things up into discrete files and assembling them using include statements does not apply.</p> <p>Since includes were often used for dynamic information such as relay domains or relay hosts, the recommended practice is to store that specific data in a data file or data source and load it using Lua data access functions.</p> <p>For example, DKIM signing information by domain and selector could be stored in a JSON file like this:</p> <pre><code>{\n  \"examplecorp.com\": \"s1024\",\n  \"newcorp.com\": \"dkim2023\"\n}\n</code></pre> <p>The data file could then be read and used to control signing:</p> <pre><code>local DKIM_CONFIG = kumo.json_load '/opt/kumomta/etc/policy/dkim_config.json'\n\nfunction dkim_sign(msg)\n  local sender_domain = msg:from_header().domain\n  local selector = DKIM_CONFIG[sender_domain]\n  -- and so on\nend\n</code></pre> <p>That said, Lua does support Include and Require directives, but they operate similarly to the Include and Require directives commonly used in programming languages.</p>"},{"location":"userguide/configuration/dkim/","title":"Configuring DKIM Signing","text":""},{"location":"userguide/configuration/dkim/#what-it-is","title":"What it is","text":"<p>DomainKeys Identified Mail (DKIM) is a mechanism that allows verification of the source and contents of email messages. Using DKIM, sending domains can include a cryptographic signature in outgoing email messages. A message's signature may be verified by an MTA during transit and by the Mail User Agent (MUA) upon delivery. A verified signature indicates the message was sent by the sending domain and the message was not altered in transit. When a DKIM signature fails verification that indicates the message may have been altered during transit or that the sender is fraudulently using the sending domain name.</p> <p>The 2011 DKIM specification is located here: rfc6376.</p> <p>This diagram gives a graphical view of how DKIM works.</p> <pre><code>---\ntitle: DKIM Process flow\n---\ngraph TD\n    SENDER[\"Sender\"]\n    SMTA[\"Sending MTA\"]\n    SIGN[\"Sign Message Using Private Key\"]\n    VALIDATE[\"Validate Signature using Public Key\"]\n    RMTA[\"Receiving MTA\"]\n    MBOX[\"User Mailbox\"]\n    SPAM[\"Spam Folder\"]\n    DNS\n    SMTA --&gt; SIGN\n    SIGN --&gt; RMTA\n    RMTA --&gt; VALIDATE\n    SENDER -- Publish Public Key --&gt; DNS\n    DNS -- Get Sender's Public Key --&gt; RMTA\n    VALIDATE -- Valid Signature --&gt; MBOX\n    VALIDATE -- Invalid Signature --&gt; SPAM\n\n   style SMTA fill:orange,color:black\n   style RMTA fill:skyblue,color:black\n   style DNS fill:#A2E4B8,color:black\n   style MBOX fill:#E8DD8E,color:black\n</code></pre>"},{"location":"userguide/configuration/dkim/#enabling-dkim-signing-in-kumomta","title":"Enabling DKIM signing in KumoMTA","text":"<p>A system administrator with access to manage DNS generates a public/private key pair to use for signing all outgoing messages for the domain (multiple key pairs are allowed). The public key is published in DNS, and the private key is made available to their DKIM-enabled outbound email servers. This is step \"1\" in the diagram.</p> <p>When an email is sent by an authorized user within the domain, the DKIM-enabled email system uses the stored private key to generate a digital signature of the message. This signature is included in a DKIM-Signature header and prepended to the email. The email is then sent on to the recipient's mail server. This is step \"2\" in the diagram.</p>"},{"location":"userguide/configuration/dkim/#generating-dkim-keys","title":"Generating DKIM Keys","text":"<p>Generate public and private keys for each signing domain and create the DKIM public key DNS records for those domains.</p> <p>The OpenSSL cryptography toolkit can be used to generate RSA or Ed25519 keys for DKIM. The most recent rfc indicates that Ed25519 should be used, but be aware that Ed25519 DKIM support is currently very limited with most email services. RSA keys are also supported and are still more widely accepted. As an example, the following openssl commands are used to generate RSA public and private keys for the a domain you choose with a selector you choose. The files can be stored in any directory such as <code>~/kumomta/keys/</code>, but the default is <code>/opt/kumomta/etc/dkim/</code>.</p> <p>Replace the domain and selector with your own, then generate signing keys with:</p> <pre><code>$ export DOMAIN=&lt;your_domain&gt;\n$ export SELECTOR=&lt;your_selector&gt;\n$ sudo mkdir -p /opt/kumomta/etc/dkim/$DOMAIN\n$ sudo openssl genrsa -f4 -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key 1024\n$ sudo openssl rsa -in /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key \\\n    -outform PEM -pubout -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.pub\n$ sudo chown kumod:kumod /opt/kumomta/etc/dkim/$DOMAIN -R\n</code></pre> <p>Any DKIM verification implementations must support key sizes of 512, 768, 1024, 1536, and 2048 bits. A signer may choose to sign messages using any of these sizes and may use a different size for different selectors. Larger key sizes provide greater security but impose higher CPU costs during message signing and verification. It is not recommended to use a key size lower than 1024 unless absolutely necessary. Note that Google requires senders to sign with a 1024 bit or greater key size.</p> <p>The resulting RSA public key should look similar to:</p> <pre><code>-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDnkmt7Vty2iLsVCpNCx4+tbufL\nxwe+P13AmzYYa9SHIV2Is3G+U4vRlAEg1McK1ssrsjF5GWGSKSeDrYJY06I8ruZS\nCpPIHQo85GAkmGbBPHMhZuk8x5XSgI8VkjAZDbiJAwg1U6MV5deWqrzDC8OJ3+RK\nKPrbKH5ubT9V9pLKawIDAQAB\n-----END PUBLIC KEY-----\n</code></pre> <p>Once the public and private keys have been generated, create a DNS text record for <code>&lt;SELECTOR&gt;._domainkey.&lt;DOMAIN&gt;</code> (IE: <code>dkim1024._domainkey.example.com</code>). The DNS record contains several DKIM \"tag=value\" pairs and should be similiar to the record shown below:</p> <p>for RSA256:</p> <pre><code>default._domainkey.example.com. 86400 IN TXT\n\"v=DKIM1; k=rsa; h=sha256; p=MIbBa...DaQAB\"\n</code></pre> <p>DKIM DNS text record tags are defined below. Do not include the quotes below when including a tag value in the DNS text record.</p> <ul> <li> <p><code>v=</code> DKIM key record version. The value of this tag must be set to \"DKIM1\".</p> </li> <li> <p><code>k=</code> Key type. This tag defines the syntax and semantics of the p= tag     value. Currently, this tag should have the value \"rsa\" or \"ed25519\" as     appropriate.</p> </li> <li> <p><code>h=</code> Hash algorithm. Currently, this tag should have the value \"sha1\"     or \"sha256\" if using RSA.</p> </li> <li> <p><code>t=</code> Flags. The only value currently defined is \"y\". If specified, this     tag indicates the signing domain is testing DKIM.</p> </li> <li> <p><code>p=</code> DKIM public key value* generated as described above.</p> </li> <li> <p><code>s=</code> Service Type. If specified, this tag should be set to \"*\" or     \"email\" which represents all service types or the email service type.     Currently, \"email\" is the only service using this key.</p> </li> <li> <p><code>n=</code> Notes. If specified, the value of this tag is quoted-printable     text used as a note to anyone reading the DNS text record. The tag is not     interpreted by DKIM verification and should be used sparingly because of     space limitations of the DNS text record.</p> </li> </ul>"},{"location":"userguide/configuration/dkim/#using-the-dkim_signlua-policy-helper","title":"Using the dkim_sign.lua Policy Helper","text":"<p>To simplify DKIM configuration using a TOML configuration file, you can use the <code>dkim_sign.lua</code> policy helper.</p> <p>The policy helper is configured to look for keys under the default path of <code>/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key</code> but can be overridden on a per-domain basis if needed.</p> <p>To use the policy helper, add the following to your default policy:</p> <pre><code>local dkim_sign = require 'policy-extras.dkim_sign'\nlocal dkim_signer = dkim_sign:setup { '/opt/kumomta/etc/dkim_data.toml' }\n\nkumo.on('smtp_server_message_received', function(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n\nkumo.on('http_message_generated', function(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n</code></pre> <p>The preceding policy example sets up the <code>dkim_sign</code> helper and adds calls for signing to the events that fire for message arrival. The call to the <code>dkim_signer</code> function must be placed last in the events to ensure that no further manipulation of the messages occur after signing.</p> <p>In addition create and populate the configured <code>dkim_data.toml</code> file, located at <code>/opt/kumomta/etc/dkim_data.toml</code> in this example.</p> TOMLJSON <pre><code>[base]\n# If these are present, we'll use hashicorp vault instead\n# of reading from disk\nvault_mount = \"secret\"\nvault_path_prefix = \"dkim\"\n# Optional: specify a custom key name (defaults to \"key\")\n# vault_key = \"private_key\"\n\n# To do double or triple signing, add each additional\n# signature name to this list and see the `signature.\"MyESPName\"`\n# block below\nadditional_signatures = [\"MyESPName\"]\n\n# Default selector to assume if the domain/signature block\n# doesn't specify one\nselector = \"dkim1024\"\n\n# The default set of headers to sign if otherwise unspecified\n# This recommended set comes from section 5.4.1 of RFC 6376\n# See https://datatracker.ietf.org/doc/html/rfc6376#section-5.4\nheaders = [\n  \"From\", \"Reply-To\", \"Subject\", \"Date\", \"To\", \"Cc\",\n  \"Resent-Date\", \"Resent-From\", \"Resent-To\", \"Resent-Cc\",\n  \"In-Reply-To\", \"References\", \"List-Id\", \"List-Help\",\n  \"List-Unsubscribe\", \"List-Subscribe\", \"List-Post\",\n  \"List-Owner\", \"List-Archive\"\n  ]\n\n# Automatic oversigning can help prevent certain DKIM replay attacks by asserting\n# absence of any additional copies of a given header.\nover_sign = true\n\n# Domain blocks match based on the sender domain of the\n# incoming message\n[domain.\"example.com\"]\nselector = 'dkim1024'\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"Sender\"]\nalgo = \"sha256\" # or \"ed25519\". Omit to use the default of \"sha256\"\n\n# optional overridden filename.\n# Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\nfilename = \"/full/path/to/key.\"\n\n# The signature block is independent of the sender domain.\n# They are consulted based on the value of `base.additional_signatures`\n# above.\n# In addition to the same values that are found in the `domain` block,\n# the following keys are supported\n[signature.\"MyESPName\"]\n# Policy is interpreted differently for these\npolicy = \"Always\" # Always add this signature\n#policy = \"OnlyIfMissingDomainBlock\" # Use this as a fallback\n\n# specifies the signing domain for this signature block\ndomain = \"myesp.com\"\n</code></pre> <pre><code>{\n  \"base\": {\n    // If these are present, we'll use hashicorp vault instead\n    // of reading from disk\n    \"vault_mount\": \"secret\",\n    \"vault_path_prefix\": \"dkim\",\n    // Optional: specify a custom key name (defaults to \"key\")\n    // vault_key = \"private_key\"\n    // \n    // To do double or triple signing, add each additional\n    // signature name to this list and see the `signature.\"MyESPName\"`\n    // block below\n    \"additional_signatures\": [\n      \"MyESPName\"\n    ],\n    // Default selector to assume if the domain/signature block\n    // doesn't specify one\n    \"selector\": \"dkim1024\",\n    // The default set of headers to sign if otherwise unspecified\n    // This recommended set comes from section 5.4.1 of RFC 6376\n    // See https://datatracker.ietf.org/doc/html/rfc6376#section-5.4\n    \"headers\": [\n      \"From\",\n      \"Reply-To\",\n      \"Subject\",\n      \"Date\",\n      \"To\",\n      \"Cc\",\n      \"Resent-Date\",\n      \"Resent-From\",\n      \"Resent-To\",\n      \"Resent-Cc\",\n      \"In-Reply-To\",\n      \"References\",\n      \"List-Id\",\n      \"List-Help\",\n      \"List-Unsubscribe\",\n      \"List-Subscribe\",\n      \"List-Post\",\n      \"List-Owner\",\n      \"List-Archive\"\n    ],\n    // Automatic oversigning can help prevent certain DKIM replay attacks by asserting\n    // absence of any additional copies of a given header.\n    \"over_sign\": true\n  },\n  \"domain\": {\n    // Domain blocks match based on the sender domain of the\n    // incoming message\n    \"example.com\": {\n      \"selector\": \"dkim1024\",\n      \"headers\": [\n        \"From\",\n        \"To\",\n        \"Subject\",\n        \"Date\",\n        \"Sender\"\n      ],\n      \"algo\": \"sha256\",\n      // optional overridden filename.\n      // Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\n      \"filename\": \"/full/path/to/key.\"\n    }\n  },\n  \"signature\": {\n    // The signature block is independent of the sender domain.\n    // They are consulted based on the value of `base.additional_signatures`\n    // above.\n    // In addition to the same values that are found in the `domain` block,\n    // the following keys are supported\n    \"MyESPName\": {\n      // Policy is interpreted differently for these\n      \"policy\": \"Always\",\n      // #policy = \"OnlyIfMissingDomainBlock\" # Use this as a fallback\n      // \n      // specifies the signing domain for this signature block\n      \"domain\": \"myesp.com\"\n    }\n  }\n}\n</code></pre>"},{"location":"userguide/configuration/dkim/#implementing-dkim-signing-using-lua","title":"Implementing DKIM Signing using Lua","text":"<p>Configure KumoMTA to sign emails passing through the MTA with DKIM signatures. This is done with Lua in policy.  The sample <code>init.lua</code> policy provided with KumoMTA declares a basic working DKIM signer that you can copy and modify as needed.  This signs a message with <code>RSA256</code> using a selector named <code>default</code> on headers <code>From</code>, <code>To</code>, and <code>Subject</code> using the DKIM key located at example-private-dkim-key.pem. (More documentation)</p> <pre><code>local signer = kumo.dkim.rsa_sha256_signer {\n  domain = msg:from_header().domain,\n  selector = 'default',\n  headers = { 'From', 'To', 'Subject' },\n  key = 'example-private-dkim-key.pem',\n}\n</code></pre> <p>Where you want to enable dkim signing, simply call that signer in policy.</p> <p>IE:  <code>msg:dkim_sign(signer)</code></p>"},{"location":"userguide/configuration/domains/","title":"Configuring Inbound and Relay Domains","text":"<p>When listening via SMTP, it is common to simply define a list of <code>relay_hosts</code> that are permitted to connect and relay messages through the server. Any host that connects and does not match the list of relay hosts will be allowed to connect to the server, but will not be permitted to relay mail through the server.</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n\n  -- override the default set of relay hosts\n  relay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n}\n</code></pre>"},{"location":"userguide/configuration/domains/#using-the-listener_domainslua-policy-helper","title":"Using the listener_domains.lua Policy Helper","text":"<p>For most basic use cases, it will be simpler to use the <code>listener_domains.lua</code> policy helper script to manage the listener domain configuration in a simple TOML file.</p> <p>To use the helper, add the following to the top level of your server policy script:</p> <pre><code>local listener_domains = require 'policy-extras.listener_domains'\n\nkumo.on(\n  'get_listener_domain',\n  listener_domains:setup { '/opt/kumomta/etc/listener_domains.toml' }\n)\n</code></pre> <p>Then create a text file at <code>/opt/kumomta/etc/listener_domains.toml</code> with the following format:</p> TOMLJSON <pre><code>[\"*\"]\n# You can specify * as a default, overridden by any more explicitly defined domains.\n# Since all options are false by default, this would only be needed to default\n# An option to true for all domains.\nrelay_to = false\nlog_oob = true\nlog_arf = true\n\n[\"example.com\"]\n# allow relaying mail from anyone, so long as it is\n# addressed to example.com\nrelay_to = true\n\n[\"bounce.example.com\"]\n# accept and log OOB bounce reports sent to bounce.example.com\nlog_oob = true\n\n[\"fbl.example.com\"]\n# accept and log ARF feedback reports sent to fbl.example.com\nlog_arf = true\n\n[\"send.example.com\"]\n# relay to anywhere, so long as the sender domain is send.example.com\n# and the connected peer matches one of the listed CIDR blocks\nrelay_from = [ '10.0.0.0/24' ]\n\n[\"auth-send.example.com\"]\n# relay to anywhere, so long as the sender domain is auth-send.example.com\n# and the connected peer has authenticated as any of the authorization identities\n# listed below using SMTP AUTH\nrelay_from_authz = [ 'username1', 'username2' ]\n\n# wildcards are permitted. This will match\n# &lt;anything&gt;.example.com that doesn't have\n# another non-wildcard entry explicitly\n# listed in this set of domains.\n# Note that \"example.com\" won't match\n# \"*.example.com\".\n[\"*.example.com\"]\n# You can specify multiple options if you wish\nlog_oob = true\nlog_arf = true\nrelay_to = true\n\n# and you can explicitly set options to false to\n# essentially exclude an entry from a wildcard\n[\"www.example.com\"]\nrelay_to = false\nlog_arf = false\nlog_oob = false\n\n# Define a per-listener configuration\n[listener.\"127.0.0.1:25\".\"*.example.com\"]\nlog_oob = false\n</code></pre> <pre><code>{\n  \"*\": {\n    // You can specify * as a default, overridden by any more explicitly defined domains.\n    // Since all options are false by default, this would only be needed to default\n    // An option to true for all domains.\n    \"relay_to\": false,\n    \"log_oob\": true,\n    \"log_arf\": true\n  },\n  \"example.com\": {\n    // allow relaying mail from anyone, so long as it is\n    // addressed to example.com\n    \"relay_to\": true\n  },\n  \"bounce.example.com\": {\n    // accept and log OOB bounce reports sent to bounce.example.com\n    \"log_oob\": true\n  },\n  \"fbl.example.com\": {\n    // accept and log ARF feedback reports sent to fbl.example.com\n    \"log_arf\": true\n  },\n  \"send.example.com\": {\n    // relay to anywhere, so long as the sender domain is send.example.com\n    // and the connected peer matches one of the listed CIDR blocks\n    \"relay_from\": [\n      \"10.0.0.0/24\"\n    ]\n  },\n  \"auth-send.example.com\": {\n    // relay to anywhere, so long as the sender domain is auth-send.example.com\n    // and the connected peer has authenticated as any of the authorization identities\n    // listed below using SMTP AUTH\n    \"relay_from_authz\": [\n      \"username1\",\n      \"username2\"\n    ]\n  },\n  // wildcards are permitted. This will match\n  // &lt;anything&gt;.example.com that doesn't have\n  // another non-wildcard entry explicitly\n  // listed in this set of domains.\n  // Note that \"example.com\" won't match\n  // \"*.example.com\".\n  \"*.example.com\": {\n    // You can specify multiple options if you wish\n    \"log_oob\": true,\n    \"log_arf\": true,\n    \"relay_to\": true\n  },\n  // and you can explicitly set options to false to\n  // essentially exclude an entry from a wildcard\n  \"www.example.com\": {\n    \"relay_to\": false,\n    \"log_arf\": false,\n    \"log_oob\": false\n  },\n  \"listener\": {\n    \"127.0.0.1:25\": {\n      // Define a per-listener configuration\n      \"*.example.com\": {\n        \"log_oob\": false\n      }\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>If you configure a domain for <code>relay_to = true</code> you will need to configure a routing domain in the Queues Helper so that KumoMTA knows where to relay the messages to internally, since an MX lookup will return the IP for your KumoMTA instance:</p> TOMLJSON <pre><code>[queue.'my.own.hostname']\nrouting_domain = '[10.0.0.1]'\n</code></pre> <pre><code>{\n  \"queue\": {\n    \"my.own.hostname\": {\n      \"routing_domain\": \"[10.0.0.1]\"\n    }\n  }\n}\n</code></pre>"},{"location":"userguide/configuration/domains/#configuring-domains-for-relaying-bounces-and-feedback-loops","title":"Configuring Domains for Relaying, Bounces, and Feedback Loops","text":"<p>By default, if a host connects to the listener and is not listed in the <code>relay_hosts</code> directive, that host will not be permitted to inject messages. While that is acceptable for most outbound relaying, it is necessary in most use cases to also configure certain exceptions on a destination-domain basis for things such as inbound mail relay, out-of-band bounce processing, and feedback loop processing.</p> <p>When a host not on the relay_hosts list connects to a listener and issues a <code>RCPT TO</code> command, the get_listener_domain hook is fired, allowing for policy to be applied based on the destination domain of the message.</p> <p>To apply policy based on the domain, the <code>make_listener_domain</code> function is used:</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\n  if domain == 'example.com' then\n    return kumo.make_listener_domain {\n      relay_to = true,\n      log_oob = 'LogThenDrop',\n      log_arf = 'LogThenDrop',\n    }\n  end\nend)\n</code></pre> <p>In the preceding example, the domain <code>example.com</code> is permitted for inbound relay, resulting in messages destined for the domain being accepted and queued, while messages will also be checked for whether they are OOB or FBL messages, which are processed, logged, and discarded.</p> <p>Additional information on the <code>log_oob</code> and <code>log_arf</code> options can be found in the Configuring Bounce Classification and the Configuring Feedback Loop Processing chapters respectively.</p> <p>For more information, see the make_listener_domain page of the Reference manual.</p>"},{"location":"userguide/configuration/example/","title":"An Example Configuration","text":"<p>A default policy file is not published with KumoMTA to prevent the average installation from having an excess of commented-out boilerplate from filling production configurations.</p> <p>The following serves as an example of a complete base policy for a functional installation that addresses common use cases for a typical installation. This is not intended as a copy/paste policy file, but as an example to direct new users in developing their server policy file.</p> <p>The content of this example will be detailed in the following sections of this chapter, links will be in the comments of the example policy.</p>"},{"location":"userguide/configuration/example/#the-example-server-policy","title":"The Example Server Policy","text":"<pre><code>-- NOTE: This example policy is not meant to be used as-is, and will require some editing.\n-- We strongly recommend reading the User Guide chapter on configuration before working with\n-- this example policy. See https://docs.kumomta.com/userguide/configuration\n\n-- This file must be written to /opt/kumomta/etc/policy/init.lua for use.\n\n-- This require statement is needed in any script passed to KumoMTA.\n-- Includes from this policy script will not need this declared again.\nlocal kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\n-- Load the policy helpers to simplify common configuration use cases\nlocal shaping = require 'policy-extras.shaping'\nlocal queue_module = require 'policy-extras.queue'\nlocal listener_domains = require 'policy-extras.listener_domains'\nlocal sources = require 'policy-extras.sources'\nlocal dkim_sign = require 'policy-extras.dkim_sign'\nlocal log_hooks = require 'policy-extras.log_hooks'\n\n-- START SETUP\n\n-- Configure the sending IP addresses that will be used by KumoMTA to\n-- connect to remote systems using the sources.lua policy helper.\n-- Note that defining sources and pools does nothing without some form of\n-- policy in effect to assign messages to the source pools you have defined.\n-- WARNING: THIS WILL NOT LOAD WITHOUT THE source.toml FILE IN PLACE\n-- SEE https://docs.kumomta.com/userguide/configuration/sendingips/\nsources:setup { '/opt/kumomta/etc/policy/sources.toml' }\n\n-- Configure DKIM signing. In this case we use the dkim_sign.lua policy helper.\n-- WARNING: THIS WILL NOT LOAD WITHOUT the dkim_data.toml FILE IN PLACE\n-- See https://docs.kumomta.com/userguide/configuration/dkim/\nlocal dkim_signer =\n  dkim_sign:setup { '/opt/kumomta/etc/policy/dkim_data.toml' }\n\n-- Load Traffic Shaping Automation Helper\nlocal shaper = shaping:setup_with_automation {\n  publish = { 'http://127.0.0.1:8008' },\n  subscribe = { 'http://127.0.0.1:8008' },\n  extra_files = { '/opt/kumomta/etc/policy/shaping.toml' },\n}\n\n-- Send a JSON webhook to a local network host.\n-- See https://docs.kumomta.com/userguide/operation/webhooks/\nlog_hooks:new_json {\n  name = 'webhook',\n  url = 'http://10.0.0.1:4242/log',\n  log_parameters = {\n    headers = { 'Subject', 'X-Customer-ID' },\n  },\n}\n\n-- Configure queue management settings. These are not throttles, but instead\n-- control how messages flow through the queues.\n-- WARNING: ENSURE THAT WEBHOOKS AND SHAPING ARE SETUP BEFORE THE QUEUE HELPER FOR PROPER OPERATION\n-- WARNING: THIS WILL NOT LOAD WITHOUT the queues.toml FILE IN PLACE\n-- See https://docs.kumomta.com/userguide/configuration/queuemanagement/\nlocal queue_helper =\n  queue_module:setup { '/opt/kumomta/etc/policy/queues.toml' }\n\n-- END SETUP\n\n--START EVENT HANDLERS\n\n-- Called On Startup, handles initial configuration\nkumo.on('init', function()\n  -- Define the default \"data\" spool location; this is where\n  -- message bodies will be stored.\n  -- See https://docs.kumomta.com/userguide/configuration/spool/\n\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumomta/data',\n    kind = 'RocksDB',\n  }\n\n  -- Define the default \"meta\" spool location; this is where\n  -- message envelope and metadata will be stored.\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumomta/meta',\n    kind = 'RocksDB',\n  }\n\n  -- Configure publishing of TSA logs to automation daemon\n  shaper.setup_publish()\n\n  -- Configure logging to local disk. Separating spool and logs to separate\n  -- disks helps reduce IO load and can help performance.\n  -- See https://docs.kumomta.com/userguide/configuration/logging/\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumomta',\n    max_segment_duration = '1 minute',\n    -- headers = { 'Subject', 'X-Customer-ID' },\n  }\n\n  -- Configure bounce classification.\n  -- See https://docs.kumomta.com/userguide/configuration/bounce/\n  kumo.configure_bounce_classifier {\n    files = {\n      '/opt/kumomta/share/bounce_classifier/iana.toml',\n    },\n  }\n\n  -- Configure HTTP Listeners for injection and management APIs.\n  -- See https://docs.kumomta.com/userguide/configuration/httplisteners/\n  kumo.start_http_listener {\n    listen = '0.0.0.0:8000',\n    -- allowed to access any http endpoint without additional auth\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\n  kumo.start_http_listener {\n    use_tls = true,\n    listen = '0.0.0.0:8001',\n    -- allowed to access any http endpoint without additional auth\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\n\n  -- Define an SMTP listener. Can be used multiple times with different\n  -- parameters to define multiple listeners!\n  -- See https://docs.kumomta.com/userguide/configuration/smtplisteners/\n  kumo.start_esmtp_listener {\n    listen = '0.0.0.0:25',\n    hostname = 'mail.example.com',\n\n    -- override the default set of relay hosts\n    relay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n  }\n\n  -- Add an IPv6 Listener\n  kumo.start_esmtp_listener {\n    listen = '[::]:25',\n    relay_hosts = { '::1' },\n  }\n\n  -- Use shared throttles rather than in-process throttles, do not enable\n  -- without first installing and configuring redis.\n  -- See https://docs.kumomta.com/reference/kumo/configure_redis_throttles/\n  -- kumo.configure_redis_throttles { node = 'redis://127.0.0.1/' }\nend) -- END OF THE INIT EVENT\n\n-- Configure listener domains for relay, oob bounces, and FBLs using the\n-- listener_domains.lua policy helper.\n-- WARNING: THIS WILL NOT LOAD WITHOUT THE listener_domains.toml FILE IN PLACE\n-- SEE https://docs.kumomta.com/userguide/configuration/smtplisteners/\nkumo.on(\n  'get_listener_domain',\n  listener_domains:setup { '/opt/kumomta/etc/policy/listener_domains.toml' }\n)\n\n-- Configure traffic shaping using the shaping.lua policy helper.\n-- Commented out by default since we recommend using the Traffic Shaping Automation helper loaded below.\n-- WARNING: THIS WILL NOT LOAD WITHOUT AN ADDITIONAL SCRIPT IN PLACE\n-- SEE https://docs.kumomta.com/userguide/configuration/trafficshaping/\n-- kumo.on('get_egress_path_config', shaping:setup { '/opt/kumomta/share/policy-extras/shaping.toml', '/opt/kumomta/etc/policy/shaping.toml', })\n\n-- Call the Traffic Shaping Automation Helper to configure shaping rules.\nkumo.on('get_egress_path_config', shaper.get_egress_path_config)\n\n-- Processing of incoming messages via SMTP\nkumo.on('smtp_server_message_received', function(msg)\n  -- Protect against SMTP Smuggling (https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)\n  local failed = msg:check_fix_conformance(\n    -- check for and reject messages with these issues:\n    'NON_CANONICAL_LINE_ENDINGS',\n    -- fix messages with these issues:\n    ''\n  )\n  if failed then\n    kumo.reject(552, string.format('5.6.0 %s', failed))\n  end\n  -- Call the queue helper to set up the queue for the message.\n  queue_helper:apply(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n\n-- Processing of incoming messages via HTTP\nkumo.on('http_message_generated', function(msg)\n  -- Call the queue helper to set up the queue for the message.\n  queue_helper:apply(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n\n-- END OF EVENT HANDLERS\n</code></pre>"},{"location":"userguide/configuration/fbl/","title":"Configuring Feedback Loop Processing","text":"<p>Feedback Loops are provided by several mailbox providers, including AOL, Hotmail, Comcast, and Yahoo! as a method for informing senders regarding which messages are receiving spam complaints.</p> <p>The mailbox providers send registered senders formatted abuse report messages to a pre-configured address in ARF format, but those messages typically do not include information that can help senders suppress future sends to the recipient that reported the message. KumoMTA can not only process and log ARF messages, but it can also inject tracking headers into the message that it can later decode to preserve recipient data needed for unsubscribing recipients that have reported messages as spam.</p> <p>For more information on Feedback Loops and how to apply for them, see https://www.emailfeedbackloops.com/.</p>"},{"location":"userguide/configuration/fbl/#configuring-tracking-headers","title":"Configuring Tracking Headers","text":"<p>By default, KumoMTA will include a supplemental tracking header that will be extracted as part of the ARF message processing. This setting is controlled by the supplemental_header option in the kumo.start_esmtp_listener function. Additional metadata can be preserved by listing the metadata keys desired in the include_meta_names argument.</p> <pre><code>kumo.start_esmtp_listener {\n  -- ..\n  trace_headers = {\n    -- this is the default: add the supplemental header\n    supplemental_header = true,\n\n    -- this is the default: the name of the supplemental header\n    header_name = 'X-KumoRef',\n\n    include_meta_names = { 'tenant', 'campaign' },\n  },\n}\n</code></pre> <p>See the trace headers section of the start_esmtp_listener section of the reference manual for more information.</p>"},{"location":"userguide/configuration/fbl/#configuring-arf-domains","title":"Configuring ARF Domains","text":"<p>For KumoMTA to process inbound messages as ARF, the inbound receiving domain must be configured as a candidate for ARF processing.  This is most simply accomplished using the listener domains policy helper, with a snippet like this:</p> TOMLJSON <pre><code>[\"fbl.examplecorp.com\"]\n# accept and log ARF feedback reports sent to fbl.examplecorp.com\nlog_arf = \"LogThenDrop\" \n</code></pre> <pre><code>{\n  \"fbl.examplecorp.com\": {\n    // accept and log ARF feedback reports sent to fbl.examplecorp.com\n    \"log_arf\": \"LogThenDrop\"\n  }\n}\n</code></pre> <p>The preceding example designates that messages injected from remote hosts destined for fbl.examplecorp.com will be accepted and then processed as ARF abuse report messages.</p>"},{"location":"userguide/configuration/fbl/#message-disposition-after-processing","title":"Message Disposition After Processing","text":"<p>For most use cases, the desired outcome after a message is processed is to discard the message, but in some cases it can be desirable to forward the message for further processing or storage, especially during testing and migration.</p> <p>To queue a message after processing, add <code>log_arf = \"LogThenRelay\"</code> to the domain configuration:</p> TOMLJSON <pre><code>[\"fbl.examplecorp.com\"]\n# accept and log ARF feedback reports sent to fbl.examplecorp.com\nlog_arf = \"LogThenRelay\"\n</code></pre> <pre><code>{\n  \"fbl.examplecorp.com\": {\n    // accept and log ARF feedback reports sent to fbl.examplecorp.com\n    \"log_arf\": \"LogThenRelay\"\n  }\n}\n</code></pre> <p>In addition, it should be noted that the MX record for your domain will still be pointed at the KumoMTA instance, which means that in order to avoid a mail loop you will need to configure routing for the domain to specify where the message should be relayed to from the KumoMTA instance, by overriding the destination queue for the message in the smtp_server_message_received event:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  if msg:recipient():domain() == 'fbl.examplecorp.com' then\n    -- Re-route the message to the intended destination\n    msg:set_meta('routing_domain', '[192.168.1.100]')\n\n    -- In earlier versions of KumoMTA, you need to set the queue\n    -- this way instead\n    -- msg:set_meta('queue', '[192.168.1.100]')\n  end\nend)\n</code></pre>"},{"location":"userguide/configuration/fbl/#fbl-message-logs","title":"FBL Message Logs","text":"<p>All feedback loop messages are logged to the destination configured in the configure_local_logs function, using the <code>Feedback</code> type.</p> <p>The format of a Feedback loop message log entry is as follows:</p> <pre><code>{\n    \"type\": \"Feedback\",\n    \"feedback_report\": {\n        \"feedback_type\": \"abuse\",\n        \"user_agent\": \"SomeGenerator/1.0\",\n        \"version\": 1,\n        \"arrival_date\": \"2005-03-08T18:00:00Z\",\n        \"incidents\": nil,\n        \"original_envelope_id\": nil,\n        \"original_mail_from\": \"&lt;somesender@example.net&gt;\",\n        \"reporting_mta\": {\n            \"mta_type\": \"dns\",\n            \"name\": \"mail.example.com\",\n        },\n        \"source_ip\": \"192.0.2.1\",\n        \"authentication_results\": [\n            \"mail.example.com; spf=fail smtp.mail=somesender@example.com\",\n        ],\n        \"original_rcpto_to\": [\n            \"&lt;user@example.com&gt;\",\n        ],\n        \"reported_domain\": [\n            \"example.net\",\n        ],\n        \"reported_uri\": [\n            \"http://example.net/earn_money.html\",\n            \"mailto:user@example.com\",\n        ],\n\n        // any fields found in the report that do not correspond to\n        // those defined by RFC 5965 are collected into this\n        // extensions field\n        \"extensions\": {\n            \"removal-recipient\": [\n                \"user@example.com\",\n            ],\n        },\n\n        // The original message or message headers, if provided in\n        // the report\n        \"original_message\": \"From: &lt;somesender@example.net&gt;\nReceived: from mailserver.example.net (mailserver.example.net\n    [192.0.2.1]) by example.com with ESMTP id M63d4137594e46;\n    Tue, 08 Mar 2005 14:00:00 -0400\nX-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\nTo: &lt;Undisclosed Recipients&gt;\nSubject: Earn money\nMIME-Version: 1.0\nContent-type: text/plain\nMessage-ID: 8787KJKJ3K4J3K4J3K4J3.mail@example.net\nDate: Thu, 02 Sep 2004 12:31:03 -0500\n\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\n\",\n\n        // if original_message is present, and a kumo-style trace\n        // header was decoded from it, then this holds the decoded\n        // trace information\n        \"supplemental_trace\": {\n            \"recipient\": \"test@example.com\",\n        },\n    }\n}\n</code></pre>"},{"location":"userguide/configuration/httplisteners/","title":"Configuring HTTP Listeners","text":"<p>An HTTP listener can be defined with a <code>kumo.start_http_listener</code> function.  In the example below you can see the definition of IP address, Port, and specific trusted hosts that are permitted to to use that listener.</p> <p>Each listener can have its own trust list, hostname and TLS settings.</p> <pre><code>kumo.start_http_listener {\n  listen = '0.0.0.0:8000',\n  -- allowed to access any http endpoint without additional auth\n  trusted_hosts = { '127.0.0.1', '::1' },\n  use_tls = true,\n}\n</code></pre> <p>Refer to the Reference Manual for detailed options.</p>"},{"location":"userguide/configuration/httplisteners/#what-can-you-use-the-http-listener-for","title":"What can you use the HTTP listener for?","text":"<p>Aside from injecting messages using the Inject API, you can also perform arbitrary administrative bounces, and collect detailed metrics.  A list of HTTP API functions exists here.</p>"},{"location":"userguide/configuration/httplisteners/#configuring-for-https","title":"Configuring for HTTPS","text":"<p>The HTTP listener can easily be secured with TLS by adding the TLS directives and a certificate to the configuration.  Below is an example of an HTTPS configuration.</p> <pre><code>kumo.start_http_listener {\n  trusted_hosts = { '127.0.0.1', '::1' },\n  listen = '0.0.0.0:443',\n  hostname = 'mail.example.com',\n  use_tls = true,\n  tls_certificate = '/path/to/cert.pem',\n  tls_private_key = '/path/to/key.pem',\n\n  --[[ Alternately configure to pull the certificate from HashiCorp Vault ]]\n  --\n  --[[\n   tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.cert',\n    -- Optional: specify a custom key name (defaults to \"key\")\n    -- vault_key = \"certificate\"\n    vault_address = \"http://127.0.0.1:8200\",\n    vault_token = \"hvs.TOKENTOKENTOKEN\",\n  },\n]]\n  --\n}\n</code></pre>"},{"location":"userguide/configuration/logging/","title":"Configuring Logging","text":"<p>By default, KumoMTA writes to a (zstd compressed) JSON log format, the details of which can be found on the Logging Reference Page.</p>"},{"location":"userguide/configuration/logging/#basic-log-configuration","title":"Basic Log Configuration","text":"<p>The simplest logging configuration, added to the init event, is as follows:</p> <pre><code>kumo.configure_local_logs {\n  log_dir = '/var/log/kumomta',\n\n  -- We recommend setting this when you're getting started;\n  -- this option is discussed in more detail below\n  max_segment_duration = '10 seconds',\n}\n</code></pre> <p>For multiple log files, the <code>configure_local_logs</code> function can be called multiple times with different parameters.</p> <p>Note</p> <p>Logs can also be published as webhooks. See the Publishing Log Events Via Webhooks chapter.</p>"},{"location":"userguide/configuration/logging/#os-considerations","title":"OS Considerations","text":"<p>The log directory should be isolated to its own partition, in order to prevent a full log partition from affecting the overall server. For best performance, the log directory should be on a separate disk from the spool. The log partition should be monitored to ensure that the disk does not fill to 100% capacity.</p>"},{"location":"userguide/configuration/logging/#compression-and-rotation","title":"Compression and Rotation","text":"<p>The server writes logs as a series of zstd compressed files, resulting in high storage efficiency as logs are written, instead of having to write large files to disk and compress them during file rotation.</p> <p>By default, files are rotated after every 1Gb of uncompressed log data, resulting in files on disk that are approximately 50MB in size. The maximum size is configurable, see the Logging Reference Page.</p> <p>Logs can be viewed in real time using the <code>tailer</code> utility:</p> <pre><code>$ /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n/var/tmp/kumo-logs/20231013-003826\n{\"type\":\"Reception\",\"id\":\"d69b7572696011eebb51227d27bbd7ab\",...}\n{\"type\":\"TransientFailure\",\"id\":\"d69b7572696011eebb51227d27bbd7ab\",...}\nwaiting for more files\n</code></pre> <p>Logs will appear as the segment files are flushed, which happens as zstd accumulates enough data to write out a block, or when the <code>max_file_size</code> is reached, or when shutting down the server.</p> <p>It is possible to configure KumoMTA to rotate logs on a time interval basis, so that you can see log records emerge more quickly when you are first experimenting with kumomta and have very little load:</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  max_segment_duration = '10 seconds',\n}\n</code></pre> <p>See the Logging Reference Page for more information on this setting.</p>"},{"location":"userguide/configuration/logging/#logging-message-headers","title":"Logging Message Headers","text":"<p>It's a common practice to encode important per-user or per-campaign information in message headers, or to use a message Subject line as an identifier in reporting. This use-case requires logging the headers, which can be achieved very simply by specifying the desired headers in the configuration:</p> <pre><code>kumo.configure_local_logs {\n  -- This is convenient, but costly! Prefer to capture the\n  -- headers into meta and log those instead, as shown in\n  -- the example below!\n  headers = { 'Subject', 'X-Client-ID' },\n}\n</code></pre> <p>Our recommendation is to capture the headers into the message metadata to make the system run faster and more efficiently:</p> <pre><code>kumo.on('init', function()\n  kumo.configure_local_logs {\n    -- ..\n    meta = { 'subject', 'x_client_id' },\n  }\nend)\n\nkumo.on('smtp_server_message_received', function(msg, conn_meta)\n  -- Arrange to log the subject header in the most\n  -- efficient way, by capturing it into the message\n  -- metadata when we receive the message.\n  -- The `msg:import_x_headers` method will capture non-x-header\n  -- names when header names are explicitly passed like this:\n  msg:import_x_headers { 'subject', 'x-client-id' }\nend)\n</code></pre>"},{"location":"userguide/configuration/logging/#customizing-the-log-format","title":"Customizing the log format","text":"<p>If a non-JSON format is needed for the logs, the template option can be used:</p> <pre><code>kumo.configure_local_logs {\n  -- ..\n  per_record = {\n    Bounce = {\n      -- Instead of logging the json record, evaluate this\n      -- template string and log the result.\n      template = [[Bounce! id={{ id }}, from={{ sender }} code={{ code }} age={{ timestamp - created }}]],\n    },\n  },\n}\n</code></pre> <p>The Mini Jinja templating engine, with some supplemental extensions, is used to evaluate logging templates. The syntax and extensions are documented here.</p> <p>Any key present in the default log format can be used in the templating engine.</p>"},{"location":"userguide/configuration/logging/#configuring-individual-record-types","title":"Configuring Individual Record Types","text":"<p>Sometimes it is necessary to configure logging on a more granular basis, especially when using custom log formats. KumoMTA supports this using the per_record option:</p> <pre><code>kumo.configure_local_logs {\n  per_record = {\n    Reception = {\n      -- use names like \"20230306-022811_recv\" for reception logs\n      suffix = '_recv',\n    },\n\n    Delivery = {\n      -- put delivery logs in a different directory\n      log_dir = '/var/log/kumo/delivery',\n    },\n\n    TransientFailure = {\n      -- Don't log transient failures\n      enable = false,\n    },\n\n    Bounce = {\n      -- Instead of logging the json record, evaluate this\n      -- template string and log the result.\n      template = [[Bounce! id={{ id }}, from={{ sender }} code={{ code }} age={{ timestamp - created }}]],\n    },\n\n    -- For any record type not explicitly listed, apply these settings.\n    -- This effectively turns off all other log records\n    Any = {\n      enable = false,\n    },\n  },\n}\n</code></pre> <p>This can be used to override paths, disable logs, or customize the format of specific event types.</p>"},{"location":"userguide/configuration/policy_helpers/","title":"Lua Policy Helpers","text":"<p>KumoMTA is designed around the concept of configuration as code, where all configuration of KumoMTA is implemented through Lua policy rather than static text files.</p> <p>Configuration as code offers numerous advantages, including late loading of config for lower memory consumption and minimal reloads and direct data source connectivity to make your KumoMTA instances a well-integrated part of your DevOps environment rather than a black box that requires automated config file updates and reload commands to be issued.</p> <p>Configuration as code enables advanced use cases such as storing your DKIM signing keys in HashiCorp Vault for realtime DKIM signing and checking SMTP Authentication credentials against a live data source.</p> <p>While configuration as code provides extreme flexibility and deep integration capabilities, that can come at the cost of complexity. In order to make KumoMTA more accessible for those who are accustomed to a static configuration file and don't need deeper integration, we have developed a set of policy helpers. These helpers are premade Lua policy scripts that implement common use cases by reading formatted TOML and JSON files to configure KumoMTA.</p>"},{"location":"userguide/configuration/policy_helpers/#an-example","title":"An Example","text":"<p>For example, DKIM signing can be implemented using Lua directly in the following example:</p> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\n  local signer = kumo.dkim.rsa_sha256_signer {\n    domain = msg:from_header().domain,\n    selector = 'default',\n    headers = { 'From', 'To', 'Subject' },\n    key = 'example-private-dkim-key.pem',\n  }\n  msg:dkim_sign(signer)\nend)\n</code></pre> <p>Or even dynamically configured against a data source:</p> <pre><code>function get_key(domain, selector)\n  local db = sqlite:open '/opt/kumomta/etc/dkim/keys.db'\n  local result = db:execute(\n    'select data from keys where domain=? and selector=?',\n    domain,\n    selector\n  )\n  return result[1]\nend\n\nlocal sqlite_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    key_data = get_key(msg:from_header().domain, 'default'),\n  },\n}\n</code></pre> <p>A more straightforward implementation can be performed by using the DKIM signing helper:</p> <pre><code>local dkim_sign = require 'policy-extras.dkim_sign'\nlocal dkim_signer = dkim_sign:setup { '/opt/kumomta/etc/dkim_data.toml' }\n\nkumo.on('smtp_server_message_received', function(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n\nkumo.on('http_message_generated', function(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n</code></pre> <p>With the helper code in place, users can manage a simple TOML or JSON file to control DKIM signing:</p> TOMLJSON <pre><code>[domain.\"example.com\"]\nselector = 'dkim1024'\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"MIME-Version\", \"Content-Type\", \"Sender\"]\nalgo = \"sha256\"\n\n# optional overridden filename.\n# Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\nfilename = \"/full/path/to/key.\"\n</code></pre> <pre><code>{\n  \"domain\": {\n    \"example.com\": {\n      \"selector\": \"dkim1024\",\n      \"headers\": [\n        \"From\",\n        \"To\",\n        \"Subject\",\n        \"Date\",\n        \"MIME-Version\",\n        \"Content-Type\",\n        \"Sender\"\n      ],\n      \"algo\": \"sha256\",\n      // optional overridden filename.\n      // Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\n      \"filename\": \"/full/path/to/key.\"\n    }\n  }\n}\n</code></pre> <p>This approach allows for full control of DKIM signing without the need to implement a data integration or fully code the signing parameters in Lua.</p>"},{"location":"userguide/configuration/policy_helpers/#current-kumomta-policy-helpers","title":"Current KumoMTA Policy Helpers","text":"<p>All policy helpers listed below are implemented in the Example Lua Policy and can be used to simplify your KumoMTA installation. In addition, the policy helper source code is available to use as a starting point for developing your own integrated configuration: where the helpers are pulling from a TOML or JSON file, they could be modified to connect directly to a data source.</p> <ul> <li>Listener_Domains - Helper for configuring which domains are allowed to relay, process bounces, and process abuse reports.</li> <li>Sources - Helper for configuring the egress sources and pools used for relaying messages.</li> <li>Queues - Helper for configuring tenant and queue configuration, including retry intervals, tenant identifier headers, and the mapping from tenant to egress pool.</li> <li>Shaping - Helper for configuring traffic shaping rules to use for destination domains. Also can be configured for Traffic Shaping Automation.</li> <li>Dkim_Sign - Helper for configuring parameters for DKIM signing for each signing domain.</li> <li>Log_Hooks - Helper for configuring webhooks.</li> </ul>"},{"location":"userguide/configuration/policy_helpers/#validating-your-configuration","title":"Validating Your Configuration","text":"Since: Version 2024.09.02-c5476b89 <p>The functionality described in this section requires version 2024.09.02-c5476b89 of KumoMTA, or a more recent version.</p> <p>You can perform a deep validation on your configuration before you deploy it by running <code>kumod</code> in validation mode:</p> <pre><code>$ /opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --validate\n</code></pre> <p>You can safely run this concurrently with an active <code>kumod</code> service; they will not conflict with each other.</p> <p>When run in this mode, the various helpers that you have enabled will perform deep referential integrity checks, as well as some other extended validations that are not normally performed when the underlying configuration files are refreshed. The sorts of checks performed include the following:</p> <ul> <li> <p><code>shaping</code> - any warnings reported by the underlying rust code       will be reported here and cause validation to fail. This is       functionally equivalent to using the <code>validate-shaping</code> binary,       except that it will automatically be passed the set of shaping       files defined by your <code>init.lua</code></p> <p>If the <code>sources</code> helper is also configured, the list of sources   referenced by the shaping config will be cross-checked against   the sources data to confirm that all possible sources are defined.</p> </li> <li> <p><code>sources</code> - each listed source and pool will be validated by       calling <code>kumo.make_egress_source</code> or <code>kumo.make_egress_pool</code>       respectively.</p> <p>Pool membership will be validated to confirm that every   listed pool is defined in the sources data.</p> </li> <li> <p><code>queues</code> - each domain and tenant that references an <code>egress_pool</code>       will be cross-checked with the <code>sources</code> helper, if the sources       helper has been configured.</p> </li> <li> <p><code>dkim</code> - a dummy message is created and signed for each configured       domain, before being discarded, allowing errors in the configuration to       be detected.  An additional dummy message is created that doesn't match       any configured domain to test additional signature blocks.</p> </li> </ul>"},{"location":"userguide/configuration/queuemanagement/","title":"Configuring Queue Management","text":"<p>After a message is injected, it is placed into a Scheduled Queue based on the combination of its Campaign, Tenant, Destination and Routing Domains. If any of these attributes are not set, the queue will be based on whichever elements are present. The Scheduled Queue is also used for messages that encountered a temporary failure and are awaiting a retry. See Configuration Concepts for more information.</p>"},{"location":"userguide/configuration/queuemanagement/#using-the-queues-helper","title":"Using The Queues Helper","text":"<p>To help simplify configuration for those with typical use cases, we have provided the queue.lua policy helper.</p> <p>The queue.lua policy helper simplifies configuration of queue management, including identifying and assigning tenant and campaign information as well as message scheduling.</p> <p>To use the queue.lua policy helper, adding the following to your init.lua policy:</p> <pre><code>local queue_module = require 'policy-extras.queue'\nlocal queue_helper =\n  queue_module:setup { '/opt/kumomta/etc/policy/queues.toml' }\n</code></pre> <p>In addition, add a call to perform queue management via the <code>queue_helper:apply(msg)</code> method to your incoming message events:</p> <pre><code>-- Processing of incoming messages via SMTP\nkumo.on('smtp_server_message_received', function(msg)\n  -- Call the queue helper to set up the queue for the message.\n  queue_helper:apply(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n\n-- Processing of incoming messages via HTTP\nkumo.on('http_message_generated', function(msg)\n  -- Call the queue helper to set up the queue for the message.\n  queue_helper:apply(msg)\n  -- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\n  dkim_signer(msg)\nend)\n</code></pre> <p>In addition, create a file at <code>/opt/kumomta/etc/queues.toml</code> and populate it as follows:</p> TOMLJSON <pre><code># Allow optional scheduled sends based on this header\n# https://docs.kumomta.com/reference/message/import_scheduling_header\nscheduling_header = \"X-Schedule\"\n\n# Set the tenant from this header and delete the header for added security\ntenant_header = \"X-Tenant\"\nremove_tenant_header = true\n\n# Set the campaign from this header and delete the header for added security\ncampaign_header = \"X-Campaign\"\nremove_campaign_header = true\n\n# The tenant to use if no tenant_header is present\ndefault_tenant = \"default-tenant\"\n\n[tenant.'default-tenant']\negress_pool = 'pool-1'\n\n[tenant.'mytenant']\n# Which pool should be used for this tenant\negress_pool = 'pool-2'\n# Override maximum message age based on tenant; this overrides settings at the domain level\nmax_age = '10 hours'\n\n# Only the authorized identities are allowed to use this tenant via the tenant_header\n#require_authz = [\"daniel\"]\n\n# The default set of parameters\n[queue.default]\nmax_age = '24 hours'\n\n# If you configure a domain for `relay_to = true` in the listener_domains\n# helper, you will need to configure a routing domain so that KumoMTA knows\n# where to relay the messages to internally, since an MX lookup will return\n# the IP for your KumoMTA instance:\n[queue.'my.own.hostname']\nrouting_domain = '[10.0.0.1]'\n\n# Base settings for a given destination domain.\n# These are overridden by more specific settings\n# in a tenant or more specific queue\n[queue.'gmail.com']\nmax_age = '22 hours'\nretry_interval = '17 mins'\n\n[queue.'gmail.com'.'mytenant']\n# options here for domain=gmail.com AND tenant=mytenant for any unmatched campaign\n\n[queue.'gmail.com'.'mytenant'.'welcome-campaign']\n# options here for domain=gmail.com, tenant=mytenant, and campaign='welcome-campaign'\n</code></pre> <pre><code>{\n  // Allow optional scheduled sends based on this header\n  // https://docs.kumomta.com/reference/message/import_scheduling_header\n  \"scheduling_header\": \"X-Schedule\",\n  // Set the tenant from this header and delete the header for added security\n  \"tenant_header\": \"X-Tenant\",\n  \"remove_tenant_header\": true,\n  // Set the campaign from this header and delete the header for added security\n  \"campaign_header\": \"X-Campaign\",\n  \"remove_campaign_header\": true,\n  // The tenant to use if no tenant_header is present\n  \"default_tenant\": \"default-tenant\",\n  \"tenant\": {\n    \"default-tenant\": {\n      \"egress_pool\": \"pool-1\"\n    },\n    \"mytenant\": {\n      // Which pool should be used for this tenant\n      \"egress_pool\": \"pool-2\",\n      // Override maximum message age based on tenant; this overrides settings at the domain level\n      \"max_age\": \"10 hours\"\n    }\n  },\n  \"queue\": {\n    // Only the authorized identities are allowed to use this tenant via the tenant_header\n    // #require_authz = [\"daniel\"]\n    // \n    // The default set of parameters\n    \"default\": {\n      \"max_age\": \"24 hours\"\n    },\n    // If you configure a domain for `relay_to = true` in the listener_domains\n    // helper, you will need to configure a routing domain so that KumoMTA knows\n    // where to relay the messages to internally, since an MX lookup will return\n    // the IP for your KumoMTA instance:\n    \"my.own.hostname\": {\n      \"routing_domain\": \"[10.0.0.1]\"\n    },\n    // Base settings for a given destination domain.\n    // These are overridden by more specific settings\n    // in a tenant or more specific queue\n    \"gmail.com\": {\n      \"max_age\": \"22 hours\",\n      \"retry_interval\": \"17 mins\",\n      \"mytenant\": {\n        // options here for domain=gmail.com AND tenant=mytenant for any unmatched campaign\n        \"welcome-campaign\": {\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"userguide/configuration/queuemanagement/#configuring-message-life-and-retry-times-using-lua","title":"Configuring Message Life and Retry Times Using Lua","text":"<p>There is no throttling configured at the Scheduled Queue level, instead, the Scheduled Queue is where messages are evaluated when retries are needed, meaning that at the Scheduled Queue level we configure settings such as the time between retries and the maximum age of a message.</p> <p>The settings for retry interval and message age are typically set globally and then overridden on a per-tenant basis.</p> <p>In the example below, a collection of per-tenant parameters is created, with global parameters set separately. When the get_queue_config  event fires, the two collections are merged and the resulting collection of parameters is passed to the <code>kumo.make_queue_config</code> function and passed back to the event handler.  See the make_queue_config page of the Reference Manual for more information.</p> <p>While the event includes arguments for the destination domain, tenant, and campaign, this example is based on the assumption that queue configuration is only customized at the tenant level:</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nlocal TENANT_PARAMS = {\n  TenantOne = {\n    max_age = '5 minutes',\n  },\n}\n\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  local params = {\n    max_age = '5 minutes',\n    retry_interval = '10 minutes',\n    max_retry_interval = '100 minutes',\n  }\n  utils.merge_into(TENANT_PARAMS[tenant] or {}, params)\n  return kumo.make_queue_config(params)\nend)\n</code></pre> <p>Note that the example above is designed specifically to show one method of storing and managing the parameters of the kumo.make_queue_config function, but users are free to store and combine parameters as they see fit.</p>"},{"location":"userguide/configuration/queuemanagement/#configuring-egress-pool-assignment-using-lua","title":"Configuring Egress Pool Assignment Using Lua","text":"<p>It's not enough to configure an Egress Pool, the server must also have assignment logic to determine which Egress pool should be used for a given message.</p> <p>Any logic can be used for Egress Pool assignment, leveraging the domain, tenant, and campaign provided for the get_queue_config event. This example is based on the idea that the Egress Pool will be named after the message's tenant:</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n\nlocal TENANT_PARAMS = {\n  TenantOne = {\n    max_age = '5 minutes',\n  },\n}\n\nkumo.on('get_queue_config', function(domain, tenant, campaign)\n  local params = {\n    max_age = '5 minutes',\n    retry_interval = '10 minutes',\n    max_retry_interval = '100 minutes',\n    -- Here we are assuming that there is an egress_pool configured\n    -- for each valid tenant. If tenant is nil then the built-in\n    -- \"unspecified\" egress pool will be used.\n    egress_pool = tenant,\n  }\n  utils.merge_into(TENANT_PARAMS[tenant] or {}, params)\n  return kumo.make_queue_config(params)\nend)\n</code></pre> <p>An example of assigning a tenant name to a message is as follows, occurring during the smtp_server_message_received event, in this case using the tenant name stored in a header called <code>X-Tenant:</code></p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  -- Assign tenant based on X-Tenant header.\n  local tenant = msg:get_first_named_header_value 'X-Tenant'\n  if tenant then\n    msg:set_meta('tenant', tenant)\n  end\nend)\n</code></pre> <p>Note that the example above does not have any handling for an empty or incorrect X-Tenant header.</p>"},{"location":"userguide/configuration/queuemanagement/#throttling-the-scheduled-queue","title":"Throttling The Scheduled Queue","text":"<p>By default KumoMTA moves messages from the Scheduled Queue to the Ready Queue as quickly there is room available in the Ready Queue, with the rate impacted only by how quickly the Ready queues have available space as limited by traffic shaping throttles or sending reputation.</p> <p>Under certain circumstances it can be beneficial to throttle the flow of messages from the Scheduled Queue to the Ready Queue. Some examples of such use cases include:</p> <ul> <li>Throttling a campaign that is expected to result in increased call center load.</li> <li>Throttling a tenant that is new and part of a shared IP pool to limit the impact of potential abuse.</li> <li>Throttling a tenant based on per-domain feedback from a Mailbox Provider (MBP).</li> </ul> <p>By using the max_message_rate option in the queues helper you can define the specific throttle to use for a given Scheduled Queue scope.</p> TOMLJSON <pre><code>[queue.'gmail.com'.'mytenant']\nmax_age = '24 hours'\nmax_message_rate = '100/s'\n</code></pre> <pre><code>{\n  \"queue\": {\n    \"gmail.com\": {\n      \"mytenant\": {\n        \"max_age\": \"24 hours\",\n        \"max_message_rate\": \"100/s\"\n      }\n    }\n  }\n}\n</code></pre> <p>Note that the <code>max_message_rate</code> option applies on a per-queue basis even when configured for a less specific scope, where a queue is defined as campaign@tenant:domain. This means that if you set the <code>max_message_rate</code> option for a given tenant, it does not limit the tenant to a given rate, it limits every created queue for that tenant to the specified rate.</p> <p>To limit the collective set of queues for a given scope use the <code>overall_max_message_rate</code> option. This will enforce the limit across all Scheduled queues for the defined scope:</p> TOMLJSON <pre><code>[tenant.'mytenant']\nmax_age = '24 hours'\noverall_max_message_rate = '100/s'\n</code></pre> <pre><code>{\n  \"tenant\": {\n    \"mytenant\": {\n      \"max_age\": \"24 hours\",\n      \"overall_max_message_rate\": \"100/s\"\n    }\n  }\n}\n</code></pre> <p>In this example the listed <code>mytenant</code> tenant will be throttled to 100 messages per second across all Scheduled queues, or in other words regardless of campaign or destination domain.</p>"},{"location":"userguide/configuration/rollup/","title":"Configuring Queue Rollup","text":"<p>By default, KumoMTA will perform automatic \"rollup\" of the ready queue based on the site name that it derives from the MX records for the destination domain, which means that your shaping rules will automatically apply across sites that share the same MX hosts with no additional configuration required.</p> <p>Some destination sites, notably <code>outlook.com</code>, use a DNS scheme that doesn't work well with this automatic MX-based rollup scheme.</p> <p>KumoMTA ships with a <code>policy-extras.rollup</code> module that can be used to provide an alternative rollup scheme for these domains.</p> <p>Warning</p> <p>Using any kind of rollup scheme other than the automatic MX-based site name approach exposes you to the potential for incorrectly routing mail. For example, some Microsoft domains have regional associations that result in policy rejections when you send to a host other than what would normally be returned from the associated MX records. There is no automatic way for KumoMTA to see through those sorts of site-specific logic from the outside. It is your responsibility to employ these techniques only where they are valid and appropriate and be prepared to adjust this configuration as the policies of the destination site change over time.</p>"},{"location":"userguide/configuration/rollup/#outlook-and-hotmail-mx-records","title":"Outlook and Hotmail MX records","text":"<p>Let's consider the MX records for <code>hotmail.com</code> and <code>outlook.com</code>, which are both owned and operated by the same entity and infrastructure; at the time of writing they look like this:</p> <pre><code>$ dig +short mx hotmail.com\n2 hotmail-com.olc.protection.outlook.com.\n$ dig +short mx outlook.com\n5 outlook-com.olc.protection.outlook.com.\n</code></pre> <p>and their site names:</p> <pre><code>$ /opt/kumomta/sbin/resolve-site-name hotmail.com\nhotmail-com.olc.protection.outlook.com\n$ /opt/kumomta/sbin/resolve-site-name outlook.com\noutlook-com.olc.protection.outlook.com\n</code></pre> <p>What this means is that, by default, mail sent to outlook and hotmail will egress through separate ready queues (because the site names are different), and be subject to separate shaping rules and separate limits/throttles, which may increase the chances of exceeding the sending rate desired by that destination site.</p>"},{"location":"userguide/configuration/rollup/#mx-host-suffix-rollup","title":"MX host suffix rollup","text":"<p>This technique analyzes the host names returned from the MX record of the destination domain and compares them against a mapping table of hostname suffix to routing domain.  If every hostname in the set of MX records matches a suffix in the mapping table, then it is considered to be an overall match and the <code>routing_domain</code> meta value is set to the corresponding domain.</p> <pre><code>local rollup = require 'policy-extras.rollup'\n\nkumo.on('smtp_server_message_received', function(msg)\n  rollup.reroute_using_ip_rollup(msg, {\n    ['.olc.protection.outlook.com.'] = 'outlook.com',\n  })\nend)\n</code></pre> <p>With this configuration in place mail sent to outlook and hotmail will now egress through the same ready queues; hotmail will be treated as though it was <code>outlook.com</code> because its <code>routing_domain</code> will be set to <code>outlook.com</code>.  This configuration will match ANY destination domains whose MX hosts all end with <code>.olc.protection.outlook.com</code>, not just hotmail and outlook.  Your <code>outlook.com</code> shaping rules would then apply across all domains that are matched and rerouted by this module.</p> <p>You will see the routing manifest in the queue names when you look at the metrics and/or <code>kcli queue-summary</code> output; instead of the scheduled queue name being <code>hotmail.com</code> it will appear as <code>hotmail.com!outlook.com</code> to indicate that it will be routed via <code>outlook.com</code>.</p> <p>You can define multiple entries in your mapping table if you wish; they keys are the host name suffixes and the values are the <code>routing_domain</code>s that should be applied.</p>"},{"location":"userguide/configuration/rollup/#ip-based-rollup","title":"IP Based Rollup","text":"<p>Info</p> <p>This technique has a number of caveats and is not generally recommended unless you have no other choice.</p> <p>This technique analyzes the first (lowest preferenced / highest priority) MX record for the destination domain. If it matches a hostname suffix in the provided mapping table it is queued into a special <code>.ip_rollup</code> queue specified by the mapping.</p> <p>Messages in that queue will be relayed to the set of IP addresses from that first MX host name.</p> <p>All domains that have the same matching MX hostname suffix and set of IP addresses will egress through the ready queue and be subject to the same shaping rules.</p> <pre><code>local rollup = require 'policy-extras.rollup'\n\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  local params = {}\n  rollup.apply_ip_rollup_to_queue_config(domain, routing_domain, params)\n  return kumo.make_queue_config(params)\nend)\n\nkumo.on('smtp_server_message_received', function(msg)\n  rollup.reroute_using_ip_rollup(msg, {\n    ['.mail.protection.outlook.com.'] = 'outlook.ip_rollup',\n  })\nend)\n</code></pre> <p>You would configure shaping rules with this in your <code>shaping.toml</code>:</p> <pre><code>[\"outlook.ip_rollup\"]\nmx_rollup = false\n# shaping parameters here\n</code></pre> <p>With above configuration in place, for a hypothetical <code>foo.com</code> domain whose MX and A records look like:</p> <pre><code>$ dig +short mx foo.com\n1 foo-com.mail.protection.outlook.com.\n$ dig +short a foo-com.mail.protection.outlook.com.\n104.47.24.36\n104.47.25.36\n</code></pre> <p>what will happen is:</p> <ul> <li>The message will be queued to a scheduled queue named <code>foo.com!outlook.ip_rollup</code></li> <li>The ready queue that it will use to egress will be named <code>mx_list:[104.47.24.36],[104.47.25.36]</code>.</li> </ul> <p>For some other domain, for example, a hypothetical <code>bar.com</code> domain whose MX and A records look like:</p> <pre><code>$ dig +short mx bar.com\n1 bar-com.mail.protection.outlook.com.\n$ dig +short a bar-com.mail.protection.outlook.com.\n104.47.24.36\n104.47.25.36\n</code></pre> <p>what will happen is:</p> <ul> <li>The message will be queued to a scheduled queue named <code>bar.com!outlook.ip_rollup</code></li> <li>The ready queue that it will use to egress will be named <code>mx_list:[104.47.24.36],[104.47.25.36]</code>.</li> </ul> <p>In this scenario, both <code>foo.com</code> and <code>bar.com</code> will egress through the same ready queue and have the shaping from the <code>outlook.ip_rollup</code> section of your <code>shaping.toml</code> applied across them both.</p> <p>There are a number of important caveats with this particular IP rollup approach:</p> <ul> <li>We will never try anything beyond the highest priority MX for the matching domains</li> <li>The IP addresses for the destination domains can vary over time. The   scheduled queue name (<code>foo.com!outlook.ip_rollup</code>) will remain the same, but   the list of IP addresses in the ready queue name will adjust to match the   evolving DNS. That means that during a transition there may be multiple ready   queues with different names as the IPs rotate.  This can reduce the efficacy   of the rollup, but is a necessary function in order to handle the situation   where the destination site has an outage and we need to stop using the old IPs.</li> <li>If the destination site is using round-robin DNS for load balancing purposes,   this approach is not useful as the resulting <code>mx_list</code> in the site name   will vary too frequently for there to be a meaningful or useful rolling up   of the egress.</li> <li>Since the ready queue names look like <code>mx_list:[IP],[IP]</code> it can be hard to intuit   from a simple glance where that mail is going.</li> </ul> <p>With the above in mind, we recommend using this particular IP rollup implementation only as a last resort.</p>"},{"location":"userguide/configuration/sendingips/","title":"Configuring Sending IPs","text":"<p>By default, all traffic injected to the KumoMTA server will be delivered using the default interface configured on the host server. For smaller installations this is acceptable, but best practices recommend separating mail streams into their own IPs addresses in order to isolate reputation and enable larger sending volumes than would be possible on a single IP address.</p> <p>KumoMTA has the concept of pools of IPs. A given scheduled queue can be associated with a pool and it will then use Weighted Round Robin (WRR) to distribute sends from that scheduled queue across the IPs contained within its associated pool.  When a scheduled queue is idle for approximately 10 minutes, it will idle out and the round robin state will be reset for the next send.</p> <p>Info</p> <p>The Weighted Round Robin implementation in kumomta is considered to be probabilistic, achieving the configured distribution only when the rate of sending is sufficiently high (at least 1 message to a given site every few minutes), and is scoped per-scheduled-queue. There is no whole-machine nor whole-cluster coordination in the round robin implementation as those techniques introduce bottlenecks that limit scalability and are unnecessary at the kinds of volumes where it is important to implement distribution across sending IPs.</p>"},{"location":"userguide/configuration/sendingips/#using-the-sourceslua-policy-helper","title":"Using the sources.lua Policy Helper","text":"<p>While the process for creating Egress Sources and Pools is defined below, most users will want to take advantage of the <code>sources.lua</code> policy helper. This is a supplemental script that takes care of the creation logic by leveraging a TOML configuration file you define.</p> <p>To use the <code>sources.lua</code> policy helper, add the following to your server policy script:</p> <pre><code>-- Configure source IPs.\nlocal sources = require 'policy-extras.sources'\nsources:setup { '/opt/kumomta/etc/sources.toml' }\n</code></pre> <p>In addition, create a file at <code>/opt/kumomta/etc/sources.toml</code> and populate it as follows:</p> TOMLJSON <pre><code>[source.\"ip-1\"]\nsource_address = \"10.0.0.1\"\nehlo_domain = 'mta1.examplecorp.com'\n\n[source.\"ip-2\"]\nsource_address = \"10.0.0.2\"\nehlo_domain = 'mta2.examplecorp.com'\n\n[source.\"ip-3\"]\nsource_address = \"10.0.0.3\"\nehlo_domain = 'mta3.examplecorp.com'\n\n# Pool containing just ip-1, which has weight=1\n[pool.\"pool-1\"]\n[pool.\"pool-1\".\"ip-1\"]\n\n# Pool with multiple ips\n[pool.\"pool-2\"]\n\n[pool.\"pool-2\".\"ip-2\"]\nweight = 2\n\n# We're warming up ip-3, so use it less frequently than ip-2\n[pool.\"pool-2\".\"ip-3\"]\nweight = 1\n</code></pre> <pre><code>{\n  \"source\": {\n    \"ip-1\": {\n      \"source_address\": \"10.0.0.1\",\n      \"ehlo_domain\": \"mta1.examplecorp.com\"\n    },\n    \"ip-2\": {\n      \"source_address\": \"10.0.0.2\",\n      \"ehlo_domain\": \"mta2.examplecorp.com\"\n    },\n    \"ip-3\": {\n      \"source_address\": \"10.0.0.3\",\n      \"ehlo_domain\": \"mta3.examplecorp.com\"\n    }\n  },\n  \"pool\": {\n    // Pool containing just ip-1, which has weight=1\n    \"pool-1\": {\n      \"ip-1\": {\n      }\n    },\n    // Pool with multiple ips\n    \"pool-2\": {\n      \"ip-2\": {\n        \"weight\": 2\n      },\n      // We're warming up ip-3, so use it less frequently than ip-2\n      \"ip-3\": {\n        \"weight\": 1\n      }\n    }\n  }\n}\n</code></pre> <p>The sources you define can include any options listed for the make_egress_source function.</p>"},{"location":"userguide/configuration/sendingips/#assigning-messages-to-pools","title":"Assigning Messages to Pools","text":"<p>It's not enough to simply create an Egress Source and assign it to an Egress Pool, the server requires explicit logic to know which message is assigned to which Egress Pool.</p> <p>This logic occurs in the events related to queue management, see the Queue Management chapter for more information.</p>"},{"location":"userguide/configuration/sendingips/#provisioning-egress-sources-using-lua","title":"Provisioning Egress Sources Using Lua","text":"<p>Note</p> <p>Most users will be satisfied with using the policy helper shown above. This section and the remainder of this page is for more advanced users. The examples show here are illustrative: if all you intend is to copy and paste these into your configuration and use them as-is, we strongly recommend that you use the sources.lua module instead.</p> <p>In KumoMTA, source IPs are described in an Egress Source. And Egress Source represents an object that can be used to send messages and is not attached to a particular protocol. While the most common use case is an IP address used for SMTP, it could also define a specific outbound port for sending through port-based NAT, or a specific configuration for sending over HTTP.</p> <p>An Egress Source is defined using the <code>kumo.make_egress_source</code> function, called during the init event. For more information, see the make_egress_source chapter of the Reference Manual.</p> <p>By default, the only option required for defining an Egress Source is a name, creating a logical grouping for messages used for queueing but still using the default server IP address:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    return kumo.make_egress_source {\n      name = 'ip-1',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre> <p>Typically an Egress source is used to assign messages to a specific IP address for sending. It is a best practice for each source IP to have a unique hostname used during the EHLO command, that matches a PTR record that points to the external IP associated with the Egress Source. The IP address is set with the source address option and the hostname is set using the ehlo_domain option. The IP address used is not required to be unique to a given Egress Source:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1\n    kumo.make_egress_source {\n      name = 'ip-1',\n      source_address = '10.0.0.1',\n      ehlo_domain = 'mta1.examplecorp.com',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre> <p>KumoMTA supports both IPv4 and IPv6 for sending, based on the source address assigned to the Egress Source:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1\n    kumo.make_egress_source {\n      name = 'ip-1',\n      source_address = '2001:db8:3333:4444:5555:6666:7777:8888',\n      ehlo_domain = 'mta2.examplecorp.com',\n    }\n  end\n  error 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"userguide/configuration/sendingips/#provisioning-egress-pools-using-lua","title":"Provisioning Egress Pools Using Lua","text":"<p>Note</p> <p>Most users will be satisfied with using the policy helper shown above. This section and the remainder of this page is for more advanced users. The examples show here are illustrative: if all you intend is to copy and paste these into your configuration and use them as-is, we strongly recommend that you use the sources.lua module instead.</p> <p>Messages cannot be assigned directly to an Egress Source, but are instead assigned to an Egress Pool. An Egress Pool contains one or more Egress Sources, and messages assigned to the pool are assigned in a round-robin fashion by default, with weighted round-robin available as an option.</p> <p>A given Egress Source can be added to multiple Egress Pools.</p> <p>Egress Pools are defined using the <code>kumo.make_egress_pool</code> function, called during the <code>get_egress_pool</code> event:</p> <pre><code>-- Maps a source name to the corresponding IP address\nlocal SOURCE_TO_IP = {\n  ['ip-1'] = '10.0.0.1',\n  ['ip-2'] = '10.0.0.2',\n  ['ip-3'] = '10.0.0.3',\n}\n\n-- This makes it convenient to author the pools, but is not as efficient\n-- as it could be. That is balanced out by using memoize below.\nfunction setup_pools()\n  local pools = {\n    {\n      name = 'BestReputation',\n      entries = {\n        { name = 'ip-1' },\n      },\n    },\n    {\n      name = 'MediumReputation',\n      entries = {\n        { name = 'ip-2', weight = 2 },\n        -- we're warming up ip-3, so use it less frequently than ip-2\n        { name = 'ip-3', weight = 1 },\n      },\n    },\n  }\n  local result = {}\n  for _, pool in ipairs(pools) do\n    result[pool.name] = kumo.make_egress_pool(pool)\n  end\n  return result\nend\n\n-- Wrap setup_pools as a caching version called get_pool_config\nlocal get_pool_config = kumo.memoize(setup_pools, {\n  name = 'setup-my-pools',\n  ttl = '5 minutes',\n  capacity = 10,\n})\n\nkumo.on('get_egress_source', function(source_name)\n  return kumo.make_egress_source {\n    name = source_name,\n    source_address = SOURCE_TO_IP[source_name],\n  }\nend)\n\nkumo.on('get_egress_pool', function(pool_name)\n  local pools = get_pool_config()\n  return pools[pool_name]\nend)\n</code></pre> <p>For more information, see the make_egress_pool chapter of the Reference Manual.</p>"},{"location":"userguide/configuration/smtplisteners/","title":"Configuring SMTP Listeners","text":"<p>An SMTP listener can be defined using the <code>kumo.start_esmtp_listener</code> function.</p> <p>The <code>kumo.start_esmtp_listener</code> function can be called multiple times to define multiple listeners. Each listener can have its own relay list, banner, hostname and list of controls to determine domain behavior.</p> <p>In the example below you can see the definition of IP address, Port, and specific relay hosts that are permitted to use that listener.</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n  hostname = 'mail.example.com',\n  relay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n}\n</code></pre> <p>Refer to the start_esmtp_listener chapter of the Reference Manual for detailed options.</p> <p>For most use cases, it will be necessary to configure listeners on a per-domain basis regarding inbound traffic. This includes designating which domains are allowed for inbound relay and bounce/feedback loop processing. See the Configuring Inbound and Relay Domains section of the User Guide for more information.</p>"},{"location":"userguide/configuration/smtplisteners/#securing-inbound-smtp-listeners-with-smtp-auth","title":"Securing Inbound SMTP Listeners with SMTP AUTH","text":"<p>While the <code>relay_hosts</code> option is often sufficient when receiving mail from internal systems, those environments that receive messages from external hosts should considering implementing SMTP AUTH authentication using username/password.</p> <p>For more information, see the Checking Inbound SMTP Authentication page.</p>"},{"location":"userguide/configuration/spool/","title":"Configuring Spooling","text":"<p>KumoMTA uses separate storage areas for metadata and message contents, named meta and data respectively. The spool is defined as part of the init event within the server's init.lua policy.</p> <p>KumoMTA supports multiple message spooling options.</p> <p>There are two kinds of spool storage possible, detailed below.</p> <p>Note</p> <p>We recommend that most users deploy using RocksDB.</p>"},{"location":"userguide/configuration/spool/#localdisk","title":"LocalDisk","text":"<p>LocalDisk writes to the specified path on disk, separating messages from their metadata. LocalDisk will have a heavy performance dependency on your filesystem IO performance, and it is strongly recommended that the spool be mounted on separate storage from the logs and the rest of the server OS for maximum performance. If SSD drives are not used, 15K RPM disks are recommended. When using disk spooling, we recommend using ext4 with the noatime flag.</p> <pre><code>LABEL=/var/spool/kumomta/data /var/spool/kumomta/data ext4 rw,noatime,barrier=0 0 2\n</code></pre> <p>LocalDisk is the default, so it does not need to be explicitly specified:</p> <pre><code>kumo.on('init', function()\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumo/data',\n  }\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumo/meta',\n  }\nend)\n</code></pre> <p>For additional performance, you can configure your listeners to defer spooling on their messages, see the Configuring SMTP Listeners page for more information.</p>"},{"location":"userguide/configuration/spool/#rocksdb","title":"RocksDB","text":"<p>A higher performance option is RocksDB.</p> <p>RocksDB makes heavy use of memory buffers and intelligent layout of storage to reduce I/O cost and increase performance. This gives increased performance similar to deferred spooling but with less risk because RocksDB uses a write-ahead-log and a background sync thread.</p> <pre><code>kumo.define_spool {\n  name = 'data',\n  path = '/var/spool/kumo/data',\n  kind = 'RocksDB',\n}\nkumo.define_spool {\n  name = 'meta',\n  path = '/var/spool/kumo/meta',\n  kind = 'RocksDB',\n}\n</code></pre>"},{"location":"userguide/configuration/trafficshaping/","title":"Configuring Traffic Shaping","text":"<p>By default, the KumoMTA server will deliver messages as quickly as possible to each destination, with few restrictions regarding number of connections, number of messages per connection, or number of messages per second. Because unthrottled sending is unwelcome by most MailBox Providers (MBPs) it is highly recommended that KumoMTA users implement traffic shaping in order to limit sending speeds to something more aligned with the expectations of the individual MBPs.</p> <p>Common throttles include concurrent connection limits, messages per connection, rate of opening connections, and rate of sending messages. In addition, users can set options for various timeouts, queue sizes, and what encryption rules to use when communicating with remote hosts.</p>"},{"location":"userguide/configuration/trafficshaping/#scoping-traffic-shaping-rules","title":"Scoping Traffic Shaping Rules","text":"<p>When KumoMTA needs to connect to a remote host to deliver messages, the get_egress_path_config event is fired in order to determine what configuration to use for that specific pathway.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, egress_source, site_name)\n  return kumo.make_egress_path {\n    enable_tls = 'OpportunisticInsecure',\n  }\nend)\n</code></pre> <p>The event passes three attributes that are keyed to determine the desired traffic shaping rules, namely the <code>domain</code>, <code>egress_source</code>, and <code>site_name</code>.</p> <p>Where the <code>domain</code> in the event call is the actual domain from the recipient address (for example, corp.com for a message destined to <code>user@corp.com</code>), the site_name is defined in the server by building an expression that represents all MX servers returned in an MX lookup for the <code>domain</code>. For example, if <code>user@corp.com</code> is hosted by Google Workspace then the <code>site_name</code> might be something similar to <code>(alt1|alt2|alt3|alt4)?.aspmx.l.google.com</code>.</p> <p>The site_name concept allows managing traffic more effectively for MBPs that host a large number of domains. Rather than treating each domain as a separate destination with its own queues and traffic shaping counters, the traffic can be grouped and shaped as a single MX group, which is what the MBPs expect when they receive incoming traffic.</p> <p>For example: if a sender wanted to limit connections to 10 per domain, and Google Workspace hosted 1,000 domains in the sender's queues, a server without MX rollup or sitenames would open 10,000 connections (1000 domains * 10 connections each). With the use of <code>site_name</code>, KumoMTA merges the 1,000 domains under a single <code>site_name</code> and maintains the limit of 10 connections per <code>egress_source</code> to the Google Workspace servers.</p> <p>Messages in the Ready Queue are grouped into separate queues based on the combination of egress_source and site_name. The domain is provided for convenience when working out what parameters to use.</p> <p>Note</p> <p>It is important to understand that while KumoMTA will build queues based on a <code>site_name</code>, it is not expected that the end user will configure traffic shaping using a <code>site_name</code>. Instead, configuration is done using a domain identifier that belongs to a given <code>site_name</code> and compare the generated <code>site_name</code> to it, as is done in the <code>shaping.lua</code> helper.</p> <p>For example, when using the helper to configure traffic shaping for the Yahoo! domains, a user would configure traffic shaping for <code>yahoo.com</code>, knowing that all domains that have a matching <code>site_name</code> would also have the same traffic shaping configuration applies.</p>"},{"location":"userguide/configuration/trafficshaping/#the-shapinglua-helper","title":"The <code>shaping.lua</code> Helper","text":"<p>While users are free to implement their traffic shaping rules as they see fit, the KumoMTA team has provided the <code>shaping.lua</code> helper as a pre-built implementation based on static configuration files in either JSON or TOML format, with support for various configuration scopes and automated rules using Traffic Shaping Automation.</p> <p>The remainder of this section of the documentation is focused on the use of the <code>shaping.lua</code> helper.</p>"},{"location":"userguide/configuration/trafficshaping/#traffic-shaping-automation","title":"Traffic Shaping Automation","text":"<p>Many of the largest MailBox Providers (MBPs) operate platforms that provide feedback to senders through their response codes during the SMTP conversation. This feedback will include information related to the traffic shaping patterns in use by the sending including bounces for too many connections, too many messages per connection, sending rate, and sender reputation.</p> <p>To ensure optimum throughput and deliverability, KumoMTA features Traffic Shaping Automation (TSA) that monitors responses from the MBPs and adjusts traffic shaping rules on a granular level to ensure compliance with the guidelines of the MBPs in realtime.</p>"},{"location":"userguide/configuration/trafficshaping/#tsa-architecture","title":"TSA Architecture","text":"<p>To better support clustered installations, as well as to limit load on the primary <code>kumod</code> service, Traffic Shaping Automation is implemented via a standalone daemon called the <code>kumo-tsa-daemon.service</code> that starts automatically when its configuration is present.</p> <p>The daemon monitors the events sent to it by the KumoMTA <code>kumod</code> process and instructs the <code>kumod</code> process to make adjustments to its traffic shaping rules according to user-defined actions.</p> <p>There are three configuration locations required to implement TSA:</p> <ul> <li><code>init.lua</code> - The server's init.lua must be modified in order to properly interact with the TSA daemon.</li> <li><code>tsa_init.lua</code> - A configuration file that controls the behavior of the TSA daemon.</li> <li><code>shaping.toml</code> - A special automation entry is added to domain rules to power TSA adjustments.</li> </ul>"},{"location":"userguide/configuration/trafficshaping/#using-the-shapinglua-helper","title":"Using The Shaping.lua Helper","text":"<p>The following steps must be followed to configure traffic shaping in KumoMTA.</p>"},{"location":"userguide/configuration/trafficshaping/#set-up-traffic-shaping-rules-files","title":"Set Up Traffic Shaping Rules Files","text":"<p>The <code>shaping.lua</code> policy reads one or more configuration files in either TOML or JSON formats.</p>"},{"location":"userguide/configuration/trafficshaping/#the-default-shapingtoml-file","title":"The Default shaping.toml File","text":"<p>By default, <code>shaping.lua</code> reads a <code>shaping.toml</code> file maintained by the KumoMTA team and included in all repos, available at https://github.com/KumoCorp/kumomta/blob/main/assets/policy-extras/shaping.toml, and which is structured as follows:</p> TOMLJSON <pre><code>[\"default\"]\nconnection_limit = 10\nmax_connection_rate = \"100/min\"\nmax_deliveries_per_connection = 100\nmax_message_rate = \"100/s\"\nidle_timeout = \"60s\"\nenable_tls = \"Opportunistic\"\nconsecutive_connection_failures_before_delay = 100\n\n[provider.\"google\"]\nmatch=[\n        {MXSuffix=\".google.com\"},\n        {MXSuffix=\".googlemail.com\"}\n]\nenable_tls = 'Required'\nmax_deliveries_per_connection = 50\nprovider_connection_limit = 5\nconsecutive_connection_failures_before_delay = 5\n\n[[\"gmail.com\".automation]]\nregex = \"This message does not have authentication information\"\naction = \"SuspendTenant\"\nduration = \"3 hours\"\n\n[provider.\"yahoo\"]\nmatch=[{MXSuffix=\".yahoodns.net\"}]\nmax_deliveries_per_connection = 20\n\n[[provider.\"yahoo\".automation]]\nregex = \"\\\\[TS04\\\\]\"\naction = \"Suspend\"\nduration = \"2 hours\"\n\n[\"comcast.net\"]\nconnection_limit = 25\nmax_deliveries_per_connection = 1000\nenable_tls = \"Required\"\nidle_timeout = \"30s\"\nconsecutive_connection_failures_before_delay = 24\n\n[[\"comcast.net\".automation]]\nregex = \"RL0000\"\n# sets max_connection_rate=\"10,000 per hour\"\naction = {SetConfig={name=\"max_connection_rate\", value=\"10000/h\"}}\n# if we see 2 or more matches in an hour. Unlike throttles, this\n# doesn't divide down to per-second rates.\ntrigger = {Threshold=\"2/hr\"}\n# The config override will last for 2 hours\nduration = \"2 hours\"\n</code></pre> <pre><code>{\n  \"default\": {\n    \"connection_limit\": 10,\n    \"max_connection_rate\": \"100/min\",\n    \"max_deliveries_per_connection\": 100,\n    \"max_message_rate\": \"100/s\",\n    \"idle_timeout\": \"60s\",\n    \"enable_tls\": \"Opportunistic\",\n    \"consecutive_connection_failures_before_delay\": 100\n  },\n  \"provider\": {\n    \"google\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".google.com\"\n        },\n        {\n          \"MXSuffix\": \".googlemail.com\"\n        }\n      ],\n      \"enable_tls\": \"Required\",\n      \"max_deliveries_per_connection\": 50,\n      \"provider_connection_limit\": 5,\n      \"consecutive_connection_failures_before_delay\": 5\n    },\n    \"yahoo\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".yahoodns.net\"\n        }\n      ],\n      \"max_deliveries_per_connection\": 20,\n      \"automation\": [\n        {\n          \"regex\": \"\\\\[TS04\\\\]\",\n          \"action\": \"Suspend\",\n          \"duration\": \"2 hours\"\n        }\n      ]\n    }\n  },\n  \"gmail.com\": {\n    \"automation\": [\n      {\n        \"regex\": \"This message does not have authentication information\",\n        \"action\": \"SuspendTenant\",\n        \"duration\": \"3 hours\"\n      }\n    ]\n  },\n  \"comcast.net\": {\n    \"connection_limit\": 25,\n    \"max_deliveries_per_connection\": 1000,\n    \"enable_tls\": \"Required\",\n    \"idle_timeout\": \"30s\",\n    \"consecutive_connection_failures_before_delay\": 24,\n    \"automation\": [\n      {\n        \"regex\": \"RL0000\",\n        // sets max_connection_rate=\"10,000 per hour\"\n        \"action\": {\n          \"SetConfig\": {\n            \"name\": \"max_connection_rate\",\n            \"value\": \"10000/h\"\n          }\n        },\n        // if we see 2 or more matches in an hour. Unlike throttles, this\n        // doesn't divide down to per-second rates.\n        \"trigger\": {\n          \"Threshold\": \"2/hr\"\n        },\n        // The config override will last for 2 hours\n        \"duration\": \"2 hours\"\n      }\n    ]\n  }\n}\n</code></pre> <p>As a special case, the domain can be named default, in which case those settings will apply globally. The global settings are superseded by the domain settings, which are superseded by the source settings.</p> <p>The full set of available options is listed in the kumo.make_egress_path page of the Reference Manual.</p> <p>The full set of Traffic Shaping Automation actions is available on the traffic shaping page of the Reference Manual.</p>"},{"location":"userguide/configuration/trafficshaping/#the-community-shapingtoml-file","title":"The Community shaping.toml File","text":"<p>In addition, the KumoMTA Github repo includes a traffic shaping rules file maintained by the community, available at https://github.com/KumoCorp/kumomta/blob/main/assets/community/shaping.toml that can also be loaded explicitly as an additional resource for users.</p>"},{"location":"userguide/configuration/trafficshaping/#custom-shaping-files","title":"Custom Shaping Files","text":"<p>Finally, users can opt to create their own shaping rules file that can augment or replace the rules defined in the previous two files.</p> <p>If you intend to manually maintain your own shaping rules, we recommend using TOML as your file format, whereas if you intend to automatically maintain your traffic shaping rules, we recommend using JSON as your file format. Both example formats are listed above.</p> <p>While you can place a custom shaping file at any readable location, it is common to place the file at <code>/opt/kumomta/etc/policy/shaping.[toml|json]</code> for consistency with examples used elsewhere in the documentation.</p>"},{"location":"userguide/configuration/trafficshaping/#order-of-definition-and-configuration-file-precedence","title":"Order of Definition and Configuration File Precedence","text":"<p>The order in which your traffic shaping configuration files are defined affects how they are loaded and in turn which options are preserved when there is a conflict between the files.</p> <p>The <code>shaping.lua</code> helper reads files sequentially, and the most recently defined file will overwrite any option set by a previously defined file.</p> <p>Because of this, we recommend setting up shaping following this pattern, which will be explained later in this page:</p> <pre><code>local shaping = require 'policy-extras.shaping'\n\nlocal shaper = shaping:setup_with_automation {\n  publish = { 'http://127.0.0.1:8008' },\n  subscribe = { 'http://127.0.0.1:8008' },\n  extra_files = {\n    '/opt/kumomta/share/policy-extras/shaping.toml',\n    '/opt/kumomta/share/community/shaping.toml',\n    '/opt/kumomta/etc/policy/shaping_custom.toml',\n  },\n}\n</code></pre> <p>Note</p> <p>When a given scope is defined in multiple files, the more recently read file does not completely replace the configuration defined in the previous file, instead the options within that scope are merged.</p> <p>If you want to completely replace the information for a given block, you can indicate that by using <code>replace_base = true</code>:</p> TOMLJSON <pre><code>[\"gmail.com\"]\n# Discard any other `gmail.com` rules provided by earlier files\nreplace_base = true\nconnection_limit = 10\n</code></pre> <pre><code>{\n  \"gmail.com\": {\n    // Discard any other `gmail.com` rules provided by earlier files\n    \"replace_base\": true,\n    \"connection_limit\": 10\n  }\n}\n</code></pre> <p><code>replace_base</code> is only meaningful in the context of the current domain section in the current file; subsequent sections for that same domain will continue to merge in as normal, unless they also use <code>replace_base</code>.</p>"},{"location":"userguide/configuration/trafficshaping/#mx-rollups-and-option-inheritance","title":"MX Rollups and Option Inheritance","text":"<p>By default, shaping.lua treats each domain entry as applying to the site_name generated for that domain, and those settings apply to any destination domain that also maps to the site. If you need to explicitly override a setting for a destination domain without consideration for the site_name, you need to set the <code>mx_rollup</code> option to false when configuring the domain.</p> <p>If you configure a domain that belongs to a configured site without setting the <code>mx_rollup</code> option to false, you will cause an error.</p> <p>Consider the following example, with foo.com being a domain hosted by Yahoo!:</p> TOMLJSON <pre><code>[\"default\"]\nconnection_limit = 10\nmax_connection_rate = \"100/min\"\nmax_deliveries_per_connection = 100\nmax_message_rate = \"100/s\"\nidle_timeout = \"60s\"\nenable_tls = \"Opportunistic\"\nconsecutive_connection_failures_before_delay = 100\n\n[\"yahoo.com\"]\nmax_deliveries_per_connection = 20\n\n[\"foo.com\"]\nmx_rollup = false\nmax_deliveries_per_connection = 50\nconnection_limit = 3\n\n[\"foo.com\".sources.\"IP-1\"]\nmax_deliveries_per_connection = 5\n</code></pre> <pre><code>{\n  \"default\": {\n    \"connection_limit\": 10,\n    \"max_connection_rate\": \"100/min\",\n    \"max_deliveries_per_connection\": 100,\n    \"max_message_rate\": \"100/s\",\n    \"idle_timeout\": \"60s\",\n    \"enable_tls\": \"Opportunistic\",\n    \"consecutive_connection_failures_before_delay\": 100\n  },\n  \"yahoo.com\": {\n    \"max_deliveries_per_connection\": 20\n  },\n  \"foo.com\": {\n    \"mx_rollup\": false,\n    \"max_deliveries_per_connection\": 50,\n    \"connection_limit\": 3,\n    \"sources\": {\n      \"IP-1\": {\n        \"max_deliveries_per_connection\": 5\n      }\n    }\n  }\n}\n</code></pre> <p>This example would result in the following active settings for mail being sent to foo.com on the IP-1 Egress Source:</p> TOMLJSON <pre><code>connection_limit = 3\nmax_deliveries_per_connection = 5\nmax_connection_rate = \"100/min\"\nmax_message_rate = \"100/s\"\n</code></pre> <pre><code>{\n  \"connection_limit\": 3,\n  \"max_deliveries_per_connection\": 5,\n  \"max_connection_rate\": \"100/min\",\n  \"max_message_rate\": \"100/s\"\n}\n</code></pre> <p>The mx_rollup option indicates whether or not the settings should apply to the domain or the site_name. In the example above, even though foo.com is hosted by Yahoo! we want to override the message throttle for the foo.com domain. The mx_rollup option is true by default and only needs to be specified for domains that override the main site name entry.</p> <p>While the default max_deliveries_per_connection is 100, it is overridden for yahoo.com (and all domains that share the same site name as the yahoo.com domain) to 20. The foo.com domain is part of the same site name as yahoo.com, but because mx_rollup is set to false the foo.com domain is treated separately and instead is set to 50. Because there is a sources entry for IP-1, the max_deliveries_per_connection is further overridden to 5 for that source's traffic in particular.</p>"},{"location":"userguide/configuration/trafficshaping/#pattern-matching-rollups","title":"Pattern Matching Rollups","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>There are a number of mailbox providers that host multiple domains, but which do not provide consistent MX results across all hosted domains.</p> <p>For those situations is is desirable to adopt pattern matching against the hostnames used by the provider's MX records, and employ connection limits and message rate throttles for all destination hosts that match.</p> <p>You can configure this using a <code>provider</code> block in your shaping file(s).</p> <p>For an example, let's consider Microsoft. Microsoft hosts two different consumer email domains (Outlook and Hotmail) as well as Office 365. While the consumer domains are run on the same servers, they have two different MX patterns:</p> <pre><code>dig +short mx hotmail.com\n2 hotmail-com.olc.protection.outlook.com.\ndig +short mx outlook.com\n5 outlook-com.olc.protection.outlook.com.\n</code></pre> <p>We can see that the individual MX hostnames have the same <code>.olc.protection.outlook.com</code> suffix, so we can use that to identify the consumer MXes.</p> <p>In addition, Microsoft has recently announced a change to the MX hostnames used by Office 365, where existing MX records will end in <code>.mail.protection.outlook.com</code> but any user who wishes to active DANE to enhance security is to use an MX hostname that ends in <code>.mx.microsoft</code>.</p> <p>To address these three scenarios, we can use the following provider blocks:</p> TOMLJSON <pre><code>[provider.\"outlook\"]\nmatch=[{MXSuffix=\".olc.protection.outlook.com\"}]\nmax_deliveries_per_connection = 50\nprovider_connection_limit = 5\n\n[[provider.\"outlook\".automation]]\nregex = \"temporarily rate limited due to IP reputation\"\naction = \"Suspend\"\nduration = \"1 hour\"\n\n[provider.\"office365\"]\nmatch=[{MXSuffix=\".mail.protection.outlook.com\"}]\nmax_deliveries_per_connection = 50\nprovider_connection_limit = 5\n\n[provider.\"office365-dane\"]\nmatch=[{MXSuffix=\".mx.microsoft\"}]\nenable_dane = true\nmax_deliveries_per_connection = 50\nprovider_connection_limit = 5\n</code></pre> <pre><code>{\n  \"provider\": {\n    \"outlook\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".olc.protection.outlook.com\"\n        }\n      ],\n      \"max_deliveries_per_connection\": 50,\n      \"provider_connection_limit\": 5,\n      \"automation\": [\n        {\n          \"regex\": \"temporarily rate limited due to IP reputation\",\n          \"action\": \"Suspend\",\n          \"duration\": \"1 hour\"\n        }\n      ]\n    },\n    \"office365\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".mail.protection.outlook.com\"\n        }\n      ],\n      \"max_deliveries_per_connection\": 50,\n      \"provider_connection_limit\": 5\n    },\n    \"office365-dane\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".mx.microsoft\"\n        }\n      ],\n      \"enable_dane\": true,\n      \"max_deliveries_per_connection\": 50,\n      \"provider_connection_limit\": 5\n    }\n  }\n}\n</code></pre> <p>Now, messages destined for either <code>hotmail.com</code> or <code>outlook.com</code>, or any other domain whose MX host names all have the suffix <code>.olc.protection.outlook.com</code>, will match the <code>outlook</code> provider block and have the options defined there applied, including an automation rule, and any Office 365 hosted domain using the new <code>.mx.microsoft</code> pattern will have DANE enabled.</p> <p>The <code>match</code> field is an array and can list multiple match candidates. A provider block matches if any of the <code>match</code> elements are matched, as seen in this example:</p> TOMLJSON <pre><code>[provider.\"google\"]\nmatch=[\n        {MXSuffix=\".google.com\"},\n        {MXSuffix=\".googlemail.com\"}\n]\nmax_deliveries_per_connection = 50\nprovider_connection_limit = 5\nconsecutive_connection_failures_before_delay = 5\nprovider_max_message_rate = \"100/s\"\n</code></pre> <pre><code>{\n  \"provider\": {\n    \"google\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".google.com\"\n        },\n        {\n          \"MXSuffix\": \".googlemail.com\"\n        }\n      ],\n      \"max_deliveries_per_connection\": 50,\n      \"provider_connection_limit\": 5,\n      \"consecutive_connection_failures_before_delay\": 5,\n      \"provider_max_message_rate\": \"100/s\"\n    }\n  }\n}\n</code></pre> <p>The match can be one of these possible options:</p> <ul> <li><code>{DomainSuffix=\"SUFFIX\"}</code> - matches if the domain name suffix matches the   specified suffix string.</li> <li><code>{MXSuffix=\"SUFFIX\"}</code> - matches if one of the MX hostnames matches the   specified suffix string. (but see below!)</li> <li><code>{HostName=\"NAME\"}</code> - matches if one of the MX hostnames exactly equals   the specified name. (but see below!) (Since: Version 2025.01.23-7273d2bc)</li> </ul> <p>When matching MX hostnames, rather than DomainSuffixes, every hostname from the MX record must match one or more of the <code>MXSuffix</code> or <code>HostName</code> match rules in order to fully match a destination site against the provider.  The reason for this is to avoid pathologically weird situations when someone has a vanity domain that blends multiple different providers together.</p> <p>Note</p> <p>The suffix matching is not a regex operation, it is purely based on whether the string specified appears at the end of the MX or domain being tested. Do not use any wildcard characters.</p> <p>The provider block introduces two new options: <code>provider_connection_limit</code> and <code>provider_max_message_rate</code>. When a provider is defined, it does not merge the various <code>site_name</code> queues covered by the provider together, which means that the <code>connection_limit</code> and <code>max_message_rate</code> options will not be enforced across all matching queues, but will be applied separately to each ready queue covered by the provider block.</p> <p>When the <code>provider_connection_limit</code> and <code>provider_max_message_rate</code> options are set, the throttles defined will be enforced across all matching site_name ready queues for that provider. This is typically the desired behavior. One example of a scenario where the provider_ options would not be used is Mimecast: each regional MX pattern used by Mimecast is a separate set of servers in that region, but traffic shaping expectations are the same for all regions. To address this we use a provider block without the <code>provider_</code> throttles:</p> TOMLJSON <pre><code>[provider.\"mimecast\"]\nmatch=[{MXSuffix=\".mimecast.com\"},{MXSuffix=\".mimecast.co.za\"},{MXSuffix=\".mimecast-offshore.com\"}]\nmax_deliveries_per_connection = 100\nconnection_limit = 10\n</code></pre> <pre><code>{\n  \"provider\": {\n    \"mimecast\": {\n      \"match\": [\n        {\n          \"MXSuffix\": \".mimecast.com\"\n        },\n        {\n          \"MXSuffix\": \".mimecast.co.za\"\n        },\n        {\n          \"MXSuffix\": \".mimecast-offshore.com\"\n        }\n      ],\n      \"max_deliveries_per_connection\": 100,\n      \"connection_limit\": 10\n    }\n  }\n}\n</code></pre> <p>In this case we can define traffic shaping rules that apply to Mimecast globally, but which are still enforced by each region's ready queue without limiting worldwide traffic.</p> <p>Note</p> <p>Both the <code>provider_</code> and regular throttles can be set, where <code>connection_limit</code> would be for the individual site names, and <code>provider_connection_limit</code> would cap the overall connection count. The same would apply for <code>max_message_rate</code> and <code>provider_max_message_rate</code>.</p>"},{"location":"userguide/configuration/trafficshaping/#shaping-option-resolution-order-and-precedence","title":"Shaping Option Resolution Order and Precedence","text":"<p>When resolving the configuration for a site, the options are resolved in the following order:</p> <ol> <li>The values for the <code>default</code> domain block are taken as the base</li> <li>Any matching <code>provider</code> blocks are then merged in</li> <li>Any matching <code>provider</code> + <code>source</code> blocks for the current source are merged in</li> <li>Any matching site name blocks are merged in. These are domain blocks that have the default (implied) or explicitly configured <code>mx_rollup = true</code> option set in them.</li> <li>Any matching domain blocks are merged in. These are domain blocks that have <code>mx_rollup=false</code> set in them.</li> <li>Any matching site name + <code>source</code> blocks are merged.</li> <li>Any matching domain + <code>source</code> blocks are merged.</li> </ol> <p>Within any of these steps above, the options are merged in the order that they appear across your configuration files, so the most recently specified value will take precedence overall.</p> <p>You can specify <code>replace_base=true</code> in a block to have that block override the current set of accumulated values.</p> <p>Warning</p> <p>There is currently no mechanism for unsetting an option previously merged in. If there is a throttle set earlier (for example in <code>[default]</code>) that you wish to unset rather than explicitly define a different throttle then you must use <code>replace_base=true</code> to replace all previously merged options.</p> <p>Most options merge directly over the top of earlier options, but the additional_connection_limits and additional_message_rate_throttles options merge the maps together.</p>"},{"location":"userguide/configuration/trafficshaping/#writing-your-own-traffic-shaping-rules","title":"Writing Your Own Traffic Shaping Rules","text":"<p>The <code>/opt/kumomta/share/policy-extras/shaping.toml</code> file provides a collection of traffic shaping rules provided by the KumoMTA team that are useful for new servers. In addition, a community-maintained set of traffic shaping rules is available at <code>/opt/kumomta/share/community/shaping.toml</code>.</p> <p>The files listed above are maintained within the KumoMTA GitHub repository and are updated with each release, meaning that any local edits to these files will be lost any time the KumoMTA install is updated.</p> <p>In addition, neither of these files are all-encompassing, you will likely encounter scenarios that require you to implement your own logic, either to address your specific reputation or to reflect specialized knowledge you have gained.</p> <p>To maintain your own traffic shaping rules, create a separate file with your own traffic shaping rules in either TOML or JSON formats, typically called <code>/opt/kumomta/etc/policy/custom-shaping.[toml|json]</code> and pass it as part of the call to set up traffic shaping.</p>"},{"location":"userguide/configuration/trafficshaping/#test-your-shaping-files","title":"Test Your Shaping Files","text":"<p>Included in the standard deployment is a validation tool for testing the syntax of your shaping.toml override file. The file located at <code>/opt/kumomta/sbin/validate-shaping</code> can be used to validate the syntax of your shaping file.  If there are no errors, it will return an \"OK\".</p> <pre><code>$ /opt/kumomta/sbin/validate-shaping /opt/kumomta/etc/policy/custom-shaping.toml\nOK\n</code></pre>"},{"location":"userguide/configuration/trafficshaping/#configure-traffic-shaping-in-your-initlua-server-policy","title":"Configure Traffic Shaping In Your <code>init.lua</code> Server Policy","text":"<p>Note</p> <p>It's easiest to reference the Example Config to see how the complete configuration looks.</p> <p>The server's <code>init.lua</code> file will require modifications to enable it to be used with TSA.</p> <p>First, the following should be added to the start of the <code>init.lua</code> file, just below the initial <code>local kumo = require 'kumo'</code> line:</p> <pre><code>local shaping = require 'policy-extras.shaping'\n\nlocal shaper = shaping:setup_with_automation {\n  publish = { 'http://127.0.0.1:8008' },\n  subscribe = { 'http://127.0.0.1:8008' },\n  extra_files = {\n    '/opt/kumomta/share/policy-extras/shaping.toml',\n    '/opt/kumomta/share/community/shaping.toml',\n    '/opt/kumomta/etc/policy/shaping_custom.toml',\n  },\n}\n</code></pre> <p>This section enabled communication with the TSA daemon. The publish and subscribe URLs correspond to the TSA daemon's HTTP listener endpoint defined in its tsa_init.lua.  For a single node deployment the values shown here are sufficient.  You may list multiple publish and/or subscribe endpoints to publish to multiple hosts and read shaping configuration from multiple hosts, respectively. In addition, while the <code>setup_with_automation</code> call is aware of the community shaping rules file, any custom file must be identified in the <code>extra_files</code> directive as seen in the example above.</p> <p>Warning</p> <p>As mentioned previously, your rules merge with the other files listed unless a given block has <code>replace_base=true</code>. To fully remove the defaults provided by the KumoMTA team you need the following:</p> <pre><code>local shaping = require 'policy-extras.shaping'\n\nlocal shaper = shaping:setup_with_automation {\n  publish = { 'http://127.0.0.1:8008' },\n  subscribe = { 'http://127.0.0.1:8008' },\n  no_default_files=true,\n  extra_files = { \n        '/opt/kumomta/share/community/shaping.toml`, \n        '/opt/kumomta/etc/policy/shaping_custom.toml',\n        },\n}\n</code></pre> <p>Next, the following should be added within the <code>kumo.on('init', function()</code> block:</p> <pre><code>-- Configure publishing of logs to automation daemon\nshaper.setup_publish()\n</code></pre> <p>This enables the logging required by the TSA daemon.</p> <p>Finally, the following must be added outside the init event to enable the TSA manipulations:</p> <pre><code>-- Attach various hooks to the shaper\nkumo.on('get_egress_path_config', shaper.get_egress_path_config)\n</code></pre>"},{"location":"userguide/configuration/trafficshaping/#configure-the-tsa_initlua-file","title":"Configure The <code>tsa_init.lua</code> File","text":"<p>The <code>tsa_init.lua</code> file controls the behavior of the TSA daemon, and should be written to <code>/opt/kumomta/etc/policy/tsa_init.lua</code>.</p> <p>An example of the <code>tsa_init.lua</code> file is below:</p> <pre><code>local tsa = require 'tsa'\nlocal kumo = require 'kumo'\n\nkumo.on('tsa_init', function()\n  tsa.start_http_listener {\n    listen = '0.0.0.0:8008',\n    trusted_hosts = { '127.0.0.1', '::1' },\n  }\nend)\n\nlocal cached_load_shaping_data = kumo.memoize(kumo.shaping.load, {\n  name = 'tsa_load_shaping_data',\n  ttl = '5 minutes',\n  capacity = 4,\n})\n\nkumo.on('tsa_load_shaping_data', function()\n  local shaping = cached_load_shaping_data {\n    '/opt/kumomta/share/policy-extras/shaping.toml',\n    '/opt/kumomta/share/community/shaping.toml',\n    '/opt/kumomta/etc/policy/custom-shaping.toml',\n  }\n  return shaping\nend)\n</code></pre> <p>Note</p> <p>The <code>tsa_init.lua</code> has no implicit loading of the default <code>shaping.toml</code> file. To avoid loading the default file simply omit it.</p>"},{"location":"userguide/configuration/trafficshaping/#monitoring-the-tsa-daemon","title":"Monitoring the TSA Daemon","text":"<p>Adjustments to the traffic shaping rules are achieved by creating a custom <code>shaping.toml</code> file that is maintained by the TSA daemon and loaded as an overlay on the existing `shaping.toml file created by the user.</p> <p>The generated TOML can be monitored by making an HTTP request. One example using curl:</p> <pre><code>$ curl -s 'http://localhost:8008/get_config_v1/shaping.toml'\n# Generated by tsa-daemon\n# Number of entries: 0\n</code></pre> <p>This call returns the current set of shaping rules in the same format as shaping.toml, the example is of an empty set.</p>"},{"location":"userguide/configuration/trafficshaping/#debugging-tips","title":"Debugging Tips","text":"<p>If the tsa-deamon does not appear to be working, you can check to see if it is running with <code>sudo systemctl status kumo-tsa-daemon</code> which should return a message that includes \"active (running)\".  If not you can stop and start it in a similar way.</p> <pre><code>sudo systemctl stop kumo-tsa-daemon\nsudo systemctl start kumo-tsa-daemon\n</code></pre> <p>Another way to identify that the TSA daemon is running is to use its API endpoint with curl:</p> <pre><code>curl -s 'http://localhost:8008/get_config_v1/shaping.toml' | head\n# Generated by tsa-daemon\n# Number of entries: 2576\n</code></pre> <p>Data being sent to the TSA daemon is handled the same as any other message in KumoMTA and will follow the same retry rules. The default is to retry in 20 minutes with exponential fallback.  If desired, this (or any other) scheduled queue can be customized with the get_queue_config hook or in your shaping.toml file.</p>"},{"location":"userguide/configuration/trafficshaping/#clustering","title":"Clustering","text":"<p>There are special considerations when implementing traffic shaping in a clustered environment, see the Clustering Chapter for more information.</p>"},{"location":"userguide/general/about/","title":"About This Manual","text":"<p>This is the Reference Manual for the KumoMTA SMTP server, version 1.0, through release 1.0. For license information, see the Legal Notices.</p> <p>Because this manual serves as a reference, it does not provide general instruction on SMTP or email infrastructure concepts. It also does not teach you how to use your operating system or command-line interpreter.</p> <p>The KumoMTA Software is under constant development, and this Manual is updated frequently as well.</p> <p>If you have questions about using KumoMTA, community support is available in the Forum and the Community Discord.</p>"},{"location":"userguide/general/about/#typographical-and-syntax-conventions","title":"Typographical and Syntax Conventions","text":"<p>This manual uses certain typographical conventions:</p> <p>Note</p> <p>This is a noteworthy section</p> <p>Warning</p> <p>This indicates a warning</p> <p>Danger</p> <p>This indicates something that can have dangerous consequences</p> <p><code>Text in this style</code> indicates input that you type in examples.</p> <p><code>Text in this style</code> indicates the names of executable programs and scripts, examples being <code>kumod</code> (the KumoMTA server executable).</p> <p><code>Text in this style</code> is used for variable input for which you should substitute a value of your own choosing.</p> <p>Text in this style is used for emphasis.</p> <p>Text in this style is used in table headings and to convey especially strong emphasis.</p> <p><code>Text in this style</code> is used to indicate a program option that affects how the program is executed, or that supplies information that is needed for the program to function in a certain way. Example: \u201cThe <code>--policy</code> option tells the <code>kumod</code> server the path to the initial policy file to execute on startup\u201d.</p> <p>File names and directory names are written like this: \u201cThe <code>simple-policy.lua</code> file is located in the <code>/etc/kumod</code> directory.\u201d</p> <p>Character sequences are written like this: \u201cTo specify a wildcard, use the <code>\u2018%\u2019</code> character.\u201d</p> <p>When commands or statements are prefixed by a prompt, we use these:</p> <pre><code>$&gt; type a command here\n#&gt; type a command as root here\nkumo&gt; type a KumoMTA CLI command here\n</code></pre> <p>Commands are issued in your command interpreter. On Unix, this is typically a program such as sh, csh, or bash.</p> <p>!!!     When you enter a command or statement shown in an example, do not type the     prompt shown in the example.</p> <p>In syntax descriptions, square brackets (\u201c[\u201d and \u201c]\u201d) indicate optional words or clauses. For example, in the following statement, --user is optional:</p> <p><code>kumod</code><code>--policy simple-policy.lua [--user] someuser</code></p>"},{"location":"userguide/general/architecture/","title":"KumoMTA Architecture","text":"<p>KumoMTA was built with large-scale sending in mind.  Here are a few key ideas that shape the implementation:</p> <ul> <li>Designed for modern multi-core, multi-threaded systems - Built on top of   Tokio, the core IO scheduler will use all available   parallelism.</li> <li>High Performance spool - We recommend using the RocksDB   based spool for a combination of in-memory buffering, write-ahead logging and   asynchronous data flushing that enable the best performance while minimizing   the risk of low-durability deferred spooling solutions.</li> <li>Advanced Queueing - KumoMTA has first-class support for queuing based on the combination of   tenant, campaign and destination site.  Having separate queues make it   easier to see and manage your traffic.</li> <li>Native MX Rollup - The Destination Site concept makes it easier to shape traffic to big receiving sites   that provide service for many domains. Rather than shaping based on just the   domain name, KumoMTA will traverse the MX records for the destination and use   that information as the basis for shaping. As a result, KumoMTA sees all   G-suite hosted domains as going to the same destination without requiring   any static configuration.  The same approach works for any domains that   share identical MX records, not just G-suite.</li> <li>Powerful Configuration - No limiting, bespoke, domain-specific configuration files   here! KumoMTA embeds the Lua language to express both declarative configuration   as well as enable you to express more advanced configuration to match your   policy or setup.</li> <li>Composable and logical extensibility - There are very few implicit   behaviors or actions, and those that exist are easy to control or disable.   This design principle means that new features can be delivered as new   functions or new modules that you can trigger from your policy configuration   if you wish to use them.</li> </ul>"},{"location":"userguide/general/credits/","title":"Credits","text":"<p>While KumoMTA Corporation owns all copyrights in the KumoMTA software and the KumoMTA manual, we wish to thank the following developers, contributors, and supporters who have helped make KumoMTA what it is today.</p>"},{"location":"userguide/general/credits/#developers","title":"Developers","text":"<p>The following people have made notable contributions to the KumoMTA software:</p> <ul> <li>Wez Furlong - Initial KumoMTA developer and architect.</li> </ul>"},{"location":"userguide/general/credits/#documenters","title":"Documenters","text":"<p>The following people have helped with writing the KumoMTA documentation:</p> <ul> <li> <p>Wez Furlong - Initial author of the Reference Manual sections of the documentation.</p> </li> <li> <p>Tom Mairs - Initial author of the User Guide portion of the documentation.</p> </li> <li> <p>Mike Hillyer - Initial author of the supplemental sections of the documentation.</p> </li> </ul>"},{"location":"userguide/general/credits/#contributors","title":"Contributors","text":"<p>KumoMTA benefits greatly from community contributions, and we thank our contributors, listed on our GitHub Contributions Graph.</p>"},{"location":"userguide/general/credits/#tools-used-to-create-kumomta","title":"Tools Used to Create KumoMTA","text":"<p>The following is a list of some of the tools and components that we have used to create KumoMTA. We owe our thanks to their creators for providing essential elements in our development and deployment:</p> <ul> <li>The Rust Community<ul> <li>Providers of a solid library of crates that made it much faster and easier to build than it would have been otherwise.</li> </ul> </li> </ul>"},{"location":"userguide/general/credits/#supporters","title":"Supporters","text":"<p>The following companies have helped finance the development of the KumoMTA server, such as by paying for feature development or contributing other resources:</p> <ul> <li>TaguchiMarketing Pty Ltd<ul> <li>Our first sponsor, in support of the initial KumoMTA beta release.</li> </ul> </li> </ul>"},{"location":"userguide/general/get_help/","title":"How to Get Help With KumoMTA","text":"<p>Community support for KumoMTA is available both in the forum and in the community Discord server. Paid support customers should consult their support SLA document for information on how to contact KumoMTA support and their relevant guaranteed response and resolution times.</p> <p>More information about KumoMTA's paid support services can be found at https://kumomta.com/support.</p>"},{"location":"userguide/general/get_help/#how-to-ask-for-help","title":"How To Ask For Help","text":"<p>To get the fastest resolution, start by reading the Troubleshooting Section and following the steps listed there.</p> <p>If the troubleshooting steps do not help you resolve your issue, please make sure to provide the following when asking for help:</p> <ol> <li> <p>The version number of your KumoMTA instance, found using <code>/opt/kumomta/sbin/kumod --version</code></p> </li> <li> <p>The Distro and version of the host Operating System, found using <code>uname -a</code></p> </li> <li> <p>The full text of the init.lua policy script running on the KumoMTA instance.</p> </li> <li> <p>The full text of any and all error messages associated with the issue, with details as to which system generated the error in question (error from injector, error from KumoMTA, error from remote host, etc.)</p> </li> <li> <p>An example of the Swaks call that reproduces the issue. See the Swaks documentation for instructions on how to use Swaks. This allows us to reproduce the issue and removes external factors from the issue at hand.</p> </li> <li> <p>A trace of the communications in question gathered using the <code>kcli trace-smtp-server</code> command.</p> </li> <li> <p>Relevant log lines from the KumoMTA logs.</p> </li> <li> <p>If the kumod process is unresponsive, provide a stack trace, see more here on how to collect a stack trace.</p> </li> </ol>"},{"location":"userguide/general/get_help/#discord","title":"Discord","text":"<p>The KumoMTA Discord server is intended for real-time communication about KumoMTA and MailOps/Deliverability in general. The Discord server can be found at https://kumomta.com/discord. Please use the #get-help channel to post your questions and be sure to include information on what version of KumoMTA you are using, your configuration, and full error messages.</p>"},{"location":"userguide/general/history/","title":"The History of KumoMTA","text":"<p>KumoMTA is an open source Message Transfer Agent (MTA) designed to provide high performance outbound email functionality.</p> <p>The KumoMTA project was founded by a group of email industry veterans with decades of experience building and managing high-performance On-Prem MTAs and is supported by a community of some of the largest senders in the world. While paying attention to the lessons of history, KumoMTA was designed from the ground up with new tech as opposed to modifying something that already existed. We specifically avoided making a modification of Postfix or Exim or some other existing MTA and instead wrote entirely new code in Rust.</p>"},{"location":"userguide/general/history/#what-is-a-kumo","title":"What is a \"Kumo\"?","text":"<p>So how did we come up with the name KumoMTA?  We set out to build a cloud deployable on-premises MTA that was flexible enough to install both on bare metal and in a public or private cloud.  Kumo means cloud in Japanese, so \"KumoMTA\" is a Cloud MTA.</p>"},{"location":"userguide/general/history/#why-open-source","title":"Why Open Source?","text":"<p>High volume commercial MTAs tend to have closed source code and steep license fees. Neither of these are particularly bad as long as the software is maintained and is flexible enough to modify. However, the kind of people who typically install very complex high-volume MTAs usually want to modify it or integrate it into other systems. Providing an open source option allows people to modify the code as needed, and contribute modifications easily to the community. The email community is full of very smart, creative people who now have an avenue to contribute to a wider community project.</p>"},{"location":"userguide/general/lua/","title":"Lua Fundamentals","text":"<p>Lua is Portuguese for moon.  It is also the name of the scripting language we use in KumoMTA. Because it is a name, Lua is always capitalized.</p> <p>Understanding Lua is not required to deploy and use KumoMTA, but it will help you leverage the full power of this incredibly flexible system. Lua is easy to learn, easy to read, and easy to implement.</p> <p>You can find many resources at the [official Lua site including online documentation and physical reference books.</p> <p>Here is a simplified primer to help you read the KumoMTA script/configs:</p> <pre><code>-- A single line comment in Lua is 2 dashes (--)\n\n--[[ A multi line comment in Lua\n     is framed in 2 dashes and 2 square brackets\n   ]]\n--\n</code></pre> <pre><code>local myvar\nlocal myvar = 32\n</code></pre> <p>Global variables are implied by excluding the word \"local\".</p> <pre><code>myvar = 32 -- this is a GLOBAL variable\n</code></pre> <p>Danger</p> <p>In KumoMTA, variables should always be declared as \"local\" unless you intend for the value to be constant for the life of the program.</p> <p>The concurrency model used by KumoMTA means that global variables can be shared in unpredictable ways. If you need to share values that change across the life of the program, you should use a data store such as sqlite or redis.</p> <p>Lua supports the following relational operators:</p> Symbol Meaning == equality ~= inequality &lt; less than &gt; greater than &lt;= less than or equal to &gt;= greater than or equal to <p>You can concatenate strings with two dots surrounded by spaces.</p> <pre><code>print('This' .. ' is ' .. 'true.')\n</code></pre> <p>Functions, conditionals, and loops always end with \"end\"</p> <pre><code>if x == 2 then\n  y = 6\nend\n\nfunction dostuff(things)\n  print(things)\nend\n</code></pre>"},{"location":"userguide/general/preface/","title":"Preface and Legal Notices","text":"<p>This is the Documentation for the KumoMTA Message Transfer Agent.</p>"},{"location":"userguide/general/preface/#legal-notices","title":"Legal Notices","text":"<p>KumoMTA and this documentation are Copyright 2023 Kumo Corp. Both are licensed under the Apache License, Version 2.0 (the \"License\");</p> <p>Full Copyright and License information can be found in the KumoMTA repository.</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"userguide/general/report/","title":"How to Report Bugs","text":"<p>This section described the process for submitting a bug report and how to get assistance.</p>"},{"location":"userguide/general/report/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>Before submitting a bug report, please try and verify that what you're encountering is truly a bug and has not been previously reported:</p> <ul> <li>Check the online manual at https://docs.kumomta.com. The manual is updated frequently and contains the latest information on the proper use of KumoMTA. The Changelog helps identify any issues that may be solved by updating to a more recent release of KumoMTA.</li> <li>Check the issues list at https://github.com/KumoCorp/kumomta/issues to see if the bug you've identified has already been reported.</li> </ul> <p>Note</p> <p>The Issue tracker is not a support channel. Any issues submitted that are questions and not bug reports will be summarily closed. See below for information on getting help.</p>"},{"location":"userguide/general/report/#submitting-a-bug-report","title":"Submitting a Bug Report","text":"<p>If you think you have found a previously unreported bug, visit https://github.com/KumoCorp/kumomta/issues/new/choose and follow the instructions on the page.</p> <p>If you submit an issue, please keep the following in mind:</p> <ul> <li>Be sure to include all of the information requested by the form.</li> <li>Remember that the fastest path to resolution is to prevent any   back-and-forth with the developers to gather further information. We can always   act on an issue report with too much detail, but not one with too little.</li> <li>If possible, download and install the latest release of KumoMTA and check   whether it solves your problem. All official KumoMTA releases are thoroughly   tested and should work without issue. We strive to maintain backward   compatibility, allowing you to switch versions of KumoMTA without issue.</li> </ul>"},{"location":"userguide/installation/docker/","title":"Installing KumoMTA in a Docker container","text":"<p>Our CI builds the latest version of our image and publishes it to the GitHub Container registry:</p> <ul> <li><code>ghcr.io/kumocorp/kumomta:latest</code> - the most recent stable release.</li> <li><code>ghcr.io/kumocorp/kumomta:main</code> - the most recent dev release.</li> </ul> <p>You'll need a policy script in order to start kumo.</p> <p>Create a file named <code>init.lua</code> with these contents:</p> <pre><code>local kumo = require 'kumo'\n-- This config acts as a sink that will discard all received mail\n\nkumo.on('init', function()\n  -- Listen on port 25\n  kumo.start_esmtp_listener {\n    listen = '0:25',\n    -- allow all clients to send mail\n    relay_hosts = { '0.0.0.0/0' },\n  }\n\n  -- Define the default \"data\" spool location.\n  -- This is unused by this config, but we are required to\n  -- define a default spool location.\n  kumo.define_spool {\n    name = 'data',\n    path = '/tmp/kumo-sink/data',\n  }\n\n  -- Define the default \"meta\" spool location.\n  -- This is unused by this config, but we are required to\n  -- define a default spool location.\n  kumo.define_spool {\n    name = 'meta',\n    path = '/tmp/kumo-sink/meta',\n  }\nend)\n\nkumo.on('smtp_server_message_received', function(msg)\n  -- Accept and discard all messages\n  msg:set_meta('queue', 'null')\nend)\n</code></pre> <p>When we launch the image, we want to mount our <code>init.lua</code> file into the image and tell it to use it.  The default location for this is <code>/opt/kumomta/etc/policy</code>:</p> <pre><code>$ sudo docker run --rm -p 2025:25 \\\n    -v .:/opt/kumomta/etc/policy \\\n    --name kumo-sink \\\n    ghcr.io/kumocorp/kumomta:latest\n</code></pre> <p>For examples on deploying more advanced docker architectures, see https://github.com/KumoCorp/kumomta/tree/main/examples.</p>"},{"location":"userguide/installation/environment/","title":"Server Environment","text":"<p>KumoMTA can be installed in a physical server, public cloud, or private cloud.  The following environments have all been tested.</p> <ul> <li>AWS</li> <li>Azure</li> <li>GCP</li> <li>VMWare</li> <li>bare metal</li> <li>IBM Cloud</li> <li>Oracle Cloud</li> <li>Contabo</li> </ul> <p>Note that most public cloud platforms block port 25 outbound so you will need to ask for specific permission to use that outbound port.</p> <p>In any case, the server or instance should be a dedicated resource with as much CPU, RAM, Network bandwidth, and storage IOPS as possible.</p>"},{"location":"userguide/installation/hardware/","title":"Hardware Considerations","text":""},{"location":"userguide/installation/hardware/#selecting-a-server-or-instance","title":"Selecting a server or Instance","text":"<p>KumoMTA is a performance MTA that will leverage every bit of power you provide. It may be kind of obvious, but 'more is better' so if you plan to send many millions of messages per hour, deploy the largest server you can. You can deploy in bare metal, public or private cloud, with or without Kubernetes.</p>"},{"location":"userguide/installation/hardware/#ram-and-storage","title":"RAM and Storage","text":"<p>At an absolute minimum, you will need 4Gb RAM and 20Gb Storage.  KumoMTA makes heavy use of both resources and response time is going to be a factor.  For high performance systems you will want to select storage with the fastest IOPS and lowest latency, so local disk is going to be much better than NAS or SAN. Likewise, you can benefit from faster RAM if it is available. In AWS, a t2.medium is adequate for a minimal install.  If you are installing a Docker Image, the same guide applies. See the chart below for sample performance reports.</p>"},{"location":"userguide/installation/hardware/#network-interfaces","title":"Network Interfaces","text":"<p>KumoMTA is capable of processing many millions of message per hour, or more relevant to this conversation, many thousands of bytes per second.  Your network interface could be your biggest bottleneck.  Below is a quick calculation:</p> <p>Assuming the average message is 50kB and you plan to send 1 Million of those per hour, your bandwidth requirement will be:</p> <pre><code>50 * 8000 * 1,000,000 / 3600s =~ 111Mbps\n</code></pre> <p>You can see that a 10Mbps Network interface would fail you quickly.  Any performance system should use at least a 10Gb NIC.</p>"},{"location":"userguide/installation/hardware/#ports-and-security","title":"Ports and Security","text":"<p>Note that in order for KumoMTA to bind to port 25 for inbound mail, it must be run as a privileged user.</p> <p>Note also that if you are deploying to any public cloud, outbound port 25 is probably blocked by default. If this node specificially needs to send mail directly on port 25 to the public internet, you should request access to the port from the cloud provider.  Some hints are below.</p> Provider Resource AWS EC2 port 25 throttle Azure Troubleshoot Outbound SMTP Connectivity GCP Sending Mail <p>~</p>"},{"location":"userguide/installation/linux/","title":"Installing on Linux","text":"<p>Pre-built releases are available for Rocky Linux 8/9, Ubuntu 20.04/22.04, and Amazon Linux 2/2023.</p> <p>A repository is provided to ease installation on supported platforms.</p> <p>The install instructions for supported platforms are shown below. If your platform is not listed, you can build from source.</p> Rocky 8/9Ubuntu 22.04 LTSUbuntu 20.04 LTSAmazon Linux 2Amazon Linux 2023 <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\n    https://openrepo.kumomta.com/files/kumomta-rocky.repo\n$ sudo yum install kumomta\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-22/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ sudo chmod 644 /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu22.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-20/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ sudo chmod 644 /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu20.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta\n</code></pre> <pre><code>$ sudo yum install -y yum-utils\n$ sudo yum-config-manager --add-repo=\\\n    https://openrepo.kumomta.com/files/kumomta-amazon.repo\n$ sudo yum install kumomta\n</code></pre> <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\n    https://openrepo.kumomta.com/files/kumomta-amazon2023.repo\n$ sudo dnf install kumomta\n</code></pre>"},{"location":"userguide/installation/linux/#installing-from-a-dev-repository","title":"Installing from a Dev Repository","text":"<p>If you want to test the latest additions and improvements to KumoMTA, you can instead install from the dev repository on your platform of choice. The dev repository is rebuilt after each commit to the KumoMTA repository, which means the dev repository will always include the latest changes.</p> <p>Warning</p> <p>While we do our best to test all commits, dev repositories should never be installed in production environments.</p> Rocky 8/9Ubuntu 22.04 LTSUbuntu 20.04 LTSAmazon Linux 2Amazon Linux 2023 <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\n    https://openrepo.kumomta.com/files/kumomta-rocky.repo\n$ sudo yum install kumomta-dev\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-22/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ sudo chmod 644 /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu22.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta-dev\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-20/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ sudo chmod 644 /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu20.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta-dev\n</code></pre> <pre><code>$ sudo yum install -y yum-utils\n$ sudo yum-config-manager --add-repo=\\\n    https://openrepo.kumomta.com/files/kumomta-amazon.repo\n$ sudo yum install kumomta-dev\n</code></pre> <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\n    https://openrepo.kumomta.com/files/kumomta-amazon2023.repo\n$ sudo yum install kumomta-dev\n</code></pre>"},{"location":"userguide/installation/linux/#the-initial-config-file","title":"The Initial Config File","text":"<p>KumoMTA is now installed, but it requires a configuration policy so it knows how to behave. The installer creates a minimal configuration policy file at <code>/opt/kumomta/etc/policy/init.lua</code> that enables basic localhost relaying and logging.</p> <p>See the configuration chapter for more information on creating your own configuration policy.</p>"},{"location":"userguide/installation/linux/#starting-kumomta","title":"Starting KumoMTA","text":"<p>To start KumoMTA using systemd, execute the following command:</p> <pre><code>$ sudo systemctl start kumomta\n</code></pre> <p>If you also intend to use the TSA shaping service, start that as well:</p> <pre><code>$ sudo systemctl start kumo-tsa-daemon\n</code></pre> <p>For additional details on starting KumoMTA, including as a persistent service, see the Starting KumoMTA chapter.</p>"},{"location":"userguide/installation/operatingsystem/","title":"Operating System Selection and Configuration","text":"<p>KumoMTA was built from the ground up to be extremely flexible infrastructure. We have built standard package builds (AKA repo install) for the most commonly used Linux Operating Systems, but if you build from source, a wide variety of Operating Systems are possible.</p> <p>So far we've run non-production tests on the following systems.</p> <ul> <li>Rocky (8, 9)</li> <li>Alma (8, 9)</li> <li>Debian (11,12)</li> <li>Ubuntu (18, 20, 22, 24)</li> <li>OpenSuse Leap (15.4)</li> <li>Azure Linux (CBL-Mariner2)</li> <li>Amazon Linux 2</li> <li>Amazon Linux 2023</li> <li>Kali (2003.1)</li> <li>CentOS 7 (obsolete and not recommended)</li> <li>RHEL 7,8,9</li> <li>Mariner</li> <li>Linux Mint (Cinnamon)</li> </ul> <p>KumoMTA works with x86 and Arm processors</p> <p>Note that most \"dnf\" systems work fine with the Rocky install instructions. And that most \"apt\" systems work fine with the Ubuntu install instructions.</p>"},{"location":"userguide/installation/overview/","title":"Installation Overview","text":"<p>This chapter starts with information regarding how to architect your deployment, what environment and hardware to select, as well as descriptions of supported operating systems. We recommend reading this chapter in order before jumping to the chapter for your install environment of choice.</p> <p>KumoMTA can be installed from a repository, as a Docker container, or can be built from source.</p> <p>For instructions on installing from a repository, see the Installing on Linux page.</p> <p>For instructions on installing the Docker container, see the Installing on Docker page.</p> <p>For instructions on building from source, see the Building from Source page.</p> <p>Once installed, Configure and Start your server.</p>"},{"location":"userguide/installation/security/","title":"Security Considerations","text":"<p>This page summarizies the key considerations for deploying a secure installation of KumoMTA.</p>"},{"location":"userguide/installation/security/#operating-system","title":"Operating System","text":"<p>The <code>.deb</code> and <code>.rpm</code> packages that we provide are preconfigured to create a service account named <code>kumod</code> and grant that user write access to the suggested default spool and log locations.</p> <p>The service is launched as the root user in order to bind to the privileged SMTP (port 25). The service immediately on startup, before taking any other action, drops all of the root privileges except for <code>CAP_NET_BIND_SERVICE</code> (which is required to bind to port 25) and then switches its user id to the <code>kumod</code> user.</p>"},{"location":"userguide/installation/security/#spool-log-and-dkim-directory-permissions","title":"Spool, Log and DKIM Directory Permissions","text":"<p>The suggested default locations for these are:</p> <ul> <li><code>/var/spool/kumomta</code></li> <li><code>/var/log/kumomta</code></li> <li><code>/opt/kumomta/etc/dkim</code></li> </ul> <p>In the standard packaging these locations are deployed with owner <code>kumod</code>, group <code>kumod</code> and mode <code>2770</code> to constrain access to just the <code>kumod</code> user.</p> <p>If you mount or otherwise select separate locations for these functions, it is recommended that you apply the same ownership and mode in order that other programs on the system are not able to exfiltrate information about the traffic, message content, or DKIM signing credentials.</p>"},{"location":"userguide/installation/security/#policy-directory-permissions","title":"Policy Directory Permissions","text":"<p>The suggested default locations for the policy files are:</p> <ul> <li><code>/opt/kumomta/etc/policy</code></li> </ul> <p>In the standard packaging these locations are deployed with owner <code>kumod</code>, group <code>kumod</code> and mode <code>755</code>.</p> <p>It is recommended that you avoid encoding secrets directly into files contained with the <code>/opt/kumomta/etc/policy</code> location and instead deploy using a secret manager such as HashiCorp vault, or alternatively, deploy those secrets in a similar way to the DKIM keys mentioned above.</p>"},{"location":"userguide/installation/security/#administrative-access","title":"Administrative Access","text":"<p>Administration is carried out via an HTTP listener that you must explicitly configure. The suggested default configuration for the listener is to bind only on the IPv4 loopback interface on port 8000, and for the loopback address to be considered to be a trusted host.</p> <p>That means that any process or user on the local host can issue administrative commands to the kumod instance in the default configuration.</p> <p>You can widen or restrict this access by changing the listen addresses on which you run http listeners and changing the trusted_hosts</p>"},{"location":"userguide/installation/security/#smtp-relaying","title":"SMTP Relaying","text":"<p>It is important to avoid allowing arbitrary sources of traffic to inject mail and relay it anywhere. The default configuration is to prevent relaying except for the relay_hosts defined in the SMTP listener.</p> <p>You can further control relaying through a combination of SMTP Authentication and relay domains.</p>"},{"location":"userguide/installation/security/#authenticating-incoming-requests","title":"Authenticating Incoming Requests","text":"<p>See the following sections of the docs:</p> <ul> <li>Inbound SMTP Authentication</li> <li>Inbound HTTP Basic Authentication</li> </ul>"},{"location":"userguide/installation/security/#inbound-tls","title":"Inbound TLS","text":"<p>Both the SMTP and HTTP listener will automatically generate a self-signed certificate if you haven't explicitly provisioned a trusted certificate. This allows communication with the service to proceed on an encrypted connection, but without trust.  The self-signed certificate generated for this purpose is held in-memory and will be regenerated when the service is restarted.</p> <p>It is strongly recommended that you provision your own trusted certificates for your listeners.</p>"},{"location":"userguide/installation/security/#outbound-tls","title":"Outbound TLS","text":"<p>The default configuration in the shaping helper for outgoing SMTP is to enable <code>Opportunistic</code> TLS, which is to make use of TLS if the destination host advertises it, but only if the certificate is trusted.</p> <p>Unfortunately, there are a large number of destination sites with poorly maintained TLS, so many kumomta users choose to deploy with <code>OpportunisticInsecure</code> TLS as a default, which will try to use TLS if available, but will allow communicating in clear text if there are any issues trying to establish the connection.  That rationale for this choice is that having an encrypted transport is more private than not having it, even if that means that you cannot assert that the connection is to the intended destination, especially if you are prepared to send the message in clear text as a fallback anyway.</p> <p>Care needs to be taken when employing <code>OpportunisticInsecure</code> as it introduces the risk of a Man-in-the-Middle attack that can intercept the outgoing traffic.</p> <p>There are three main ways in which you can manage that risk:</p> <ul> <li>Use MTA-STS (which   is enabled by default) to allow a destination site to publish its own choice   on TLS policy via a well-known HTTPS endpoint.  Sites that deploy MTA-STS can   ensure that the TLS is set to required even if your default policy is   opportunistic.</li> <li>For well-known sites with working TLS, such as Google, override the   opportunistic TLS with required TLS in your shaping configuration.</li> <li>Consider enabling DANE, which is   similar in effect to MTA-STS, using signed DNS records instead of publishing   its policy via HTTPS. It requires working and trusted DNSSEC   capability in your infrastructure. Since we can't guarantee that it will work   out of the box without the operator explicitly confirming that functionality,   this is not enabled by default.</li> </ul>"},{"location":"userguide/installation/source/","title":"Building From Source","text":"<p>If pre-built binaries are not provided for your system of choice, of if you'd like try your hand at extending KumoMTA, you'll need to build it from source.</p> <p>If you are on Ubuntu or Rocky Linux and just want to try KumoMTA, rather than build from source we recommend that you follow the instructions in the Installing on Linux section.</p>"},{"location":"userguide/installation/source/#prepare-your-environment","title":"Prepare your environment","text":"<p>Read the Environmental considerations before proceeding.  You will need a suitably sized server with all of the prerequisites in order to be successful.</p> <p>In addition, you will need to install some development packages.</p>"},{"location":"userguide/installation/source/#obtain-the-code","title":"Obtain The Code","text":"<p>You will need <code>git</code>:</p> RPM based systemsAPT based systems <pre><code>$ sudo dnf install -y git\n</code></pre> <pre><code>$ sudo apt install -y git curl\n</code></pre> <p>Then clone the repo:</p> <pre><code>$ git clone https://github.com/KumoCorp/kumomta.git\n$ cd kumomta\n</code></pre>"},{"location":"userguide/installation/source/#install-dependencies","title":"Install Dependencies","text":"<p>The <code>get-deps.sh</code> script in the repo knows how to install dependencies for various systems; you should run it the first time you clone the repo, and may need to run it after running a pull to update the repo in the future:</p> <pre><code>$ ./get-deps.sh\n</code></pre> <p>Note</p> <p><code>get-deps.sh</code> will install the various deps, but will complain that rust is not installed the first time that you run it. You can ignore that error as the very next step is to install rust.</p>"},{"location":"userguide/installation/source/#install-rust","title":"Install Rust","text":"<p>You will need the Rust compiler to build KumoMTA.</p> <p>We strongly recommend using rustup to install and manage your Rust compiler. While some distributions offer a version of the Rust compiler, it is often outdated.</p> <p>If you are using a priviledged user, drop back to your non-priviledged user first:</p> <pre><code>$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y\n$ source ~/.cargo/env\n</code></pre>"},{"location":"userguide/installation/source/#building-kumomta","title":"Building KumoMTA","text":"<p>With all the dependencies available, the actual build process is very simple:</p> <pre><code>$ cargo build --release\n</code></pre> <p>This will build everything, leaving the binaries in the <code>target/release</code> directory in the repo.</p>"},{"location":"userguide/installation/source/#building-your-own-package","title":"Building your own package","text":"<p>There are scripts to build out packages in either RPM or DEB format. If you're running on such a system, we recommend building and installing from a package built by our scripts, as those packages will best encapsulate how we intend for KumoMTA to be installed and operated.</p> <p>These scripts will produce a package file that you are then free to install either locally or on a target system elsewhere.</p> RPM based systemsAPT based systems <pre><code>$ assets/build-rpm.sh\n</code></pre> <p>You can find the generated rpm in a directory maintained by rpmbuild; that is usually <code>~/rpmbuild/RPMS/x86_64</code>, but some environments use a different location, so the example below uses <code>rpm --eval</code> to obtain the correct location:</p> <pre><code>$ rpm --eval '%{_rpmdir}/%{_arch}'\n/home/USER/rpmbuild/RPMS/x86_64\n$ ls $(rpm --eval '%{_rpmdir}/%{_arch}')/kumo*.rpm\n/home/USER/rpmbuild/RPMS/x86_64/kumomta-dev-2023.10.24.112314_f8aaa6f1-1.fedora38.x86_64.rpm\n</code></pre> <p>You can install it directly if you wish:</p> <pre><code>$ sudo rpm -Uvh $(ls $(rpm --eval '%{_rpmdir}/%{_arch}')/kumo*.rpm | tail -1)\n</code></pre> <pre><code>$ assets/build-deb.sh\n$ ls *.deb\nkumomta-dev.2023.10.24.112314.f8aaa6f1.Ubuntu22.04.deb\n</code></pre> <p>You can install it directly if you wish:</p> <pre><code>$ sudo apt-get install -y ./kumomta*.deb\n</code></pre>"},{"location":"userguide/installation/source/#installing-from-source","title":"Installing from source","text":"<p>If RPM or DEB is not suitable for your environment for some reason, you can install the various components \"by hand\".  We recommend installing to <code>/opt/kumomta</code> so that various product defaults continue to operate as intended.</p>"},{"location":"userguide/installation/source/#pre-req-service-account","title":"Pre-req: service account","text":"<p>The default service account assumed by the <code>kumod</code> process is the <code>kumod</code> user.</p> <p>You can create the account manually like this:</p> <pre><code>$ sudo useradd --system -g kumod -d /var/spool/kumod -s /sbin/nologin \\\n    -c \"Service account for kumomta\" kumod\n</code></pre>"},{"location":"userguide/installation/source/#directory-structure","title":"Directory Structure","text":"<p>Take care with the ownership and permissions on the various directories, in order to avoid deploying with an insecure configuration:</p> <pre><code>$ sudo install -d --mode 755 --owner kumod --group kumod /opt/kumomta/sbin\n$ sudo install -d --mode 755 --owner kumod --group kumod /opt/kumomta/etc\n$ sudo install -d --mode 755 --owner kumod --group kumod /opt/kumomta/etc/policy\n$ sudo install -d --mode 2770 --owner kumod --group kumod /opt/kumomta/etc/dkim\n$ sudo install -d --mode 2770 --owner kumod --group kumod /var/spool/kumomta\n$ sudo install -d --mode 2770 --owner kumod --group kumod /var/log/kumomta\n</code></pre> <p>The executables:</p> <pre><code>$ for bin in validate-shaping tsa-daemon \\\n    proxy-server kumod kcli traffic-gen tailer ; do\n  install -Dsm755 target/release/$bin -t /opt/kumomta/sbin\ndone\n</code></pre> <p>The helpers and other assets:</p> <pre><code>$ sudo mkdir -p /opt/kumomta/share/bounce_classifier /opt/kumomta/share/policy-extras\n$ sudo install -Dm644 assets/bounce_classifier/* -t /opt/kumomta/share/bounce_classifier\n$ sudo install -Dm644 assets/policy-extras/*.lua -t /opt/kumomta/share/policy-extras\n$ sudo install -Dm644 assets/policy-extras/*.toml -t /opt/kumomta/share/policy-extras\n</code></pre> <p>The example/starter configuration files can be installed like this; you may wish to skip this set and just deploy your own configuration, as discussed in the section below:</p> <pre><code>$ sudo install -Dm644 assets/init.lua -T /opt/kumomta/etc/policy/init.lua\n$ sudo install -Dm644 assets/tsa_init.lua -T /opt/kumomta/etc/policy/tsa_init.lua\n</code></pre>"},{"location":"userguide/installation/source/#systemd-service","title":"Systemd Service","text":"<p>If you wish to use systemd to manage <code>kumod</code> and/or <code>tsa-daemon</code>, you can find the <code>.service</code> files in the <code>assets</code> directory.  Precisely where these files are deployed varies a little depending on your distribution, so copyable instructions for that are not currently provided here.</p>"},{"location":"userguide/installation/source/#creating-the-initial-config","title":"Creating the initial config","text":"<p>KumoMTA is now installed, but it requires a policy configuration script so it knows how to behave.  The policy config is written in Lua and should live in <code>/opt/kumomta/etc/policy/init.lua</code> in order to work with the systemd service definition.</p> <p>Both the from-package and from-source instructions above will pre-populate that file with the basic configuration that is reproduced below. Alternately, there is a more substantial config sample HERE, but you must save it as <code>/opt/kumomta/etc/policy/init.lua</code>.</p> /opt/kumomta/etc/policy/init.lua<pre><code>--[[\n########################################################\n  KumoMTA minimal Send Policy\n  (Save this as /opt/kumomta/etc/policy/init.lua for systemd automation)\n  This config policy defines KumoMTA with a minimal\n  set of modifications from default.\n  Please read the docs at https://docs.kumomta.com/\n  For detailed configuration instructions.\n########################################################\n]]\n--\nlocal kumo = require 'kumo'\n--[[ Start of INIT section ]]\n--\n\nkumo.on('init', function()\n  kumo.start_esmtp_listener {\n    listen = '0.0.0.0:25',\n  }\n\n  kumo.start_http_listener {\n    listen = '127.0.0.1:8000',\n  }\n\n  kumo.define_spool {\n    name = 'data',\n    path = '/var/spool/kumomta/data',\n  }\n\n  kumo.define_spool {\n    name = 'meta',\n    path = '/var/spool/kumomta/meta',\n  }\n\n  kumo.configure_local_logs {\n    log_dir = '/var/log/kumomta',\n    -- Flush logs every 10 seconds.\n    -- You may wish to set a larger value in your production\n    -- configuration; this lower value makes it quicker to see\n    -- logs while you are first getting set up.\n    max_segment_duration = '10s',\n  }\nend)\n--[[ End of INIT Section ]]\n\n--[[ Start of Non-INIT level config ]]\n--\n-- PLEASE read https://docs.kumomta.com/ for extensive documentation on customizing this config.\n--[[ End of Non-INIT level config ]]\n</code></pre>"},{"location":"userguide/installation/source/#running-kumod","title":"Running kumod","text":"<p>If you are not using systemd to manage the service, then you will need to use some other way to launch kumod.  This section shows how you might launch it manually, so that you understand how to automatate/manage this for yourself in your chosen environment:</p> <pre><code>$ sudo /opt/kumomta/sbin/kumod \\\n   --policy /opt/kumomta/etc/policy/init.lua \\\n   --user kumod\n</code></pre> <p>Using <code>sudo</code> (or otherwise spawning as root) to launch the process allows binding to privileged ports, such as port 25, so that you can accept incoming mail on the standard port.</p> <p>When launched with root privileges, <code>kumod</code> requires a service account to switch to after it has bound privileged ports, in order to avoid running in a dangerously insecure mode: you do not want public internet traffic connecting directly to a privileged process!</p> <p>The <code>--policy</code> argument specifies the path to your <code>init.lua</code> configuration.</p> <p>The <code>--user</code> argument specifies the name of the service account to use instead of running as root.</p>"},{"location":"userguide/installation/source/#running-from-your-source-directory","title":"Running from your source directory","text":"<p>Note</p> <p>This section is intended for people that are developing kumomta itself, rather than people that just want to install and use kumomta</p> <p>This command will bring <code>kumod</code> up to date (in case you made changes), and then try to launch it:</p> <pre><code>$ cargo run --release -p kumod -- --policy /opt/kumomta/etc/policy/init.lua\n</code></pre> <p>You can run as root using port 25, in the foreground, with this:</p> <pre><code>$ cargo build --release -p kumod &amp;&amp; \\\n  sudo target/release/kumod \\\n     --policy /opt/kumomta/etc/policy/init.lua \\\n     --user kumod\n</code></pre>"},{"location":"userguide/installation/source/#keeping-the-source-up-to-date","title":"Keeping the source up to date","text":"<p>To synchronize your repo with the latest changes in the <code>main</code> branch:</p> <p><pre><code>$ cd kumomta\n$ git pull --rebase\n$ ./get-deps.sh\n$ cargo build --release\n</code></pre> Note that this builds the new files in <code>target/release/</code>.  If you installed binaries to /opt/kumomta/sbin then you will want to follow the instructions above to build your own package and update the files in <code>/opt/kumomta/</code>.</p>"},{"location":"userguide/installation/system_prep/","title":"System Preparation","text":"<p>Regardless of what OS and hardware you select, there are some basic things you should do to prepare your system before installing KumoMTA. While veteran system admins will probably have done much of this already as a standard course of building a server, it is worth noting these to save you some stress later.</p> <ul> <li> <p>In the cloud service network settings or local security appliance, create a security group that includes the ports you require access to.</p> <p>Port 22: SSH will be required to access the host operating system</p> <p>Port 25: SMTP is required for both outbound mail and inbound mail, including injections and bounce messages.</p> <p>Port 80: HTTP is used for the HTTP API, but should be restricted to authorized hosts.</p> <p>Port 443: HTTPS is the secure (TLS) version of Port 80 so the same access rules apply.</p> <p>Port 587: SMTP for Submission is not required, but recommended for inbound messages.</p> <p>Port 2025: Alternate for SMTP Submission, useful in environments that restrict port 25.</p> </li> <li> <p>Update to the latest patches</p> </li> </ul> <p>It is always good to start with a clean and current system.</p> <p>In dnf managed systems (Rocky, Alma, Fedora, etc) use</p> <pre><code>sudo dnf clean all\nsudo dnf update -y\n</code></pre> <p>In apt managed systems (Debain, Ubuntu, etc) use</p> <pre><code>sudo apt-get -y update\nsudo apt-get -y upgrade\n</code></pre> <ul> <li>Install basic testing and support tools like firewalld tree telnet git bind (or bind9) bind-utils (or bind9-utils)</li> </ul> <p>Note that installing a caching name server is absolutely critical when you are using a high performance mail engine.  Please do yourself a favour and install bind (or some other caching name server) and test it now.</p> <pre><code>sudo apt install bind9 -y\nsudo systemctl start named\n</code></pre> <ul> <li>Turn off services that can interfere, particularly postfix and qpidd</li> </ul> <pre><code>sudo systemctl disable postfix\nsudo systemctl stop postfix\nsudo systemctl disable qpidd\nsudo systemctl stop qpidd\n</code></pre> <ul> <li> <p>Tune the use of memory and file access for best performance. In the sysctl settings, boosting fs.file-max up to 65535 and also setting tcp_tw_reuse = 1 will help performance.  Make other adjustments as needed to make maximum use of RAM, file, and network resources.</p> </li> <li> <p>Automate updates and startup for resiliency</p> </li> </ul> <pre><code># Make sure it all stays up to date\n# Run a dnf update at 3AM daily\necho \"0 3 * * * root /usr/bin/dnf update -y &gt;/dev/null 2&gt;&amp;1\" | \\\n sudo tee /etc/cron.d/dnf-updates &gt;/dev/null\n</code></pre> <ul> <li>Adding your system certificate, or at least generating a self-signed certificate can be helpful before you start.  If you don't, one will be generated based on the available system parameters and the settings may not be what you want.</li> </ul> <p>Now that you have a nicely prepared system, you can move on to installing the MTA.</p>"},{"location":"userguide/installation/upgrading/","title":"Upgrading KumoMTA","text":"<p>If you have installed from a repository, you can upgrade with the same process used for any package upgrade.</p> <p>In dnf managed systems:</p> <pre><code>$ sudo dnf update kumomta[-dev]\n</code></pre> <p>In apt managed systems:</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade kumomta[-dev]\n</code></pre>"},{"location":"userguide/integrations/","title":"Integrations","text":"<p>This chapter is focused on partner and adjacent systems integrations. Some of the third-party integrations could involve a separate external fee, while others are entirely FOSS (Free and Open Source Software).</p> <p>We are available to provide paid professional services to assist you with any of these integrations.</p> <pre><code>---\nconfig:\n  theme: 'base'\n  themeVariables:\n    primaryColor: '#BB8'\n    primaryTextColor: '#000'\n    primaryBorderColor: '#C0000'\n    lineColor: '#F8B229'\n    secondaryColor: '#121212'\n    tertiaryColor: '#F8B22f'\n  kanban:\n    ticketBaseUrl: 'https://docs.kumomta.com/userguide/integrations/#TICKET#'\n---\nkanban\n  Campaign Management\n    [Ongage]@{ticket: ongage}\n    [Mautic Marketing Automation]@{ticket: mautic}\n    [EmailElement]@{ticket: emailelement}\n  [Reporting UIs]\n    [Postmastery Console]@{ticket: postmastery}\n    [Tatami Monitor]@{ticket: tatamimonitor}\n    [Grafana Dashboard]@{ticket: grafana}\n  [Data Feeds]\n    [Prometheus Metrics Monitor]@{ticket: prometheus }\n  [AV/AS]\n    [Hornetsecurity Spam and Malware protection]@{ticket: hornetsecurity }\n    [Rspamd]@{ticket: rspamd }\n</code></pre>"},{"location":"userguide/integrations/emailelement/","title":"EmailElement KumoMTA Integration","text":""},{"location":"userguide/integrations/emailelement/#introduction","title":"Introduction","text":"<p>EmailElement is an all-in-one email email marketing solution where you can build your marketing campaigns from the ground up across multiple brands and mail channels. One of the mail channels supported is KumoMTA. These instructions will show you how to set up your KumoMTA server with EmailElement.</p>"},{"location":"userguide/integrations/emailelement/#instructions","title":"Instructions","text":"<ol> <li>Sign up for EmailElement account at the portal, selecting a tier that works best for you.    https://portal.emailelement.com/signup    Be sure to \u201cConfirm Registration\u201d after you sign up from the email you will receive.</li> <li>Log in after you have confirmed your registration, and set-up a Brand and    Sender Domain. If you need help with any of those items you can find some    documentation on it    here.</li> <li>Go to <code>Send Integrations</code> from the navigation menu and select <code>Create Send Integration</code>.</li> <li>Select <code>SMTP</code> from the <code>Type of Integration</code> dropdown, then choose Kumo and proceed.</li> <li>Enter the required fields and save your integration.</li> <li>Click <code>Run Test</code> to ensure everything is set-up correctly and you\u2019ll be ready to start sending!</li> </ol>"},{"location":"userguide/integrations/grafana/","title":"Grafana integration","text":""},{"location":"userguide/integrations/grafana/#introduction","title":"Introduction","text":"<p>Grafana is a popular tool for visualizing data and generating alerts.</p> <p>Grafana does not directly integrate with KumoMTA, but is a recommended visualization tool that can consume the feed from Prometheus, which does directly integrate with KumomTA.</p>"},{"location":"userguide/integrations/grafana/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/grafana/#get-kumomta","title":"Get KumoMTA","text":"<p>Install KumoMTA as per the installation instructions here.</p> <p>Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.</p> <p>Ensure that you can inject and deliver mail through KumoMTA.</p>"},{"location":"userguide/integrations/grafana/#install-prometheus-and-test","title":"Install Prometheus and test","text":"<p>There are detailed instructions here for installing prometheus in KumoMTA.</p> <ul> <li>You can install directly on the server, or in a separate server, or in    docker.  We recommend using docker    https://hub.docker.com/r/prom/prometheus</li> <li>Note that <code>Node Exporter</code> is not actually required, but will give you access    to additional system metrics like free drive space and other OS operational    data.</li> </ul>"},{"location":"userguide/integrations/grafana/#get-grafana","title":"Get Grafana","text":"<p>Grafana itself can be used in a number of ways.</p> <p>As long as it can read the Prometheus data feed, it can work for you.  While you can install directly on the KumoMTA node following the instructions above, we recommend you use a docker image or the Grafana cloud service.</p> <p>Follow the setup instructions here to configure the prometheus feed, and get the samepl Gafana dashboard.</p> <p>If you have done everything right, you should be able to see your data feed in Grafana within seconds.</p>"},{"location":"userguide/integrations/hornetsecurity/","title":"Hornetsecurity Spam and Malware Protection integration","text":""},{"location":"userguide/integrations/hornetsecurity/#introduction","title":"Introduction","text":"<p>This integration makes Hornetsecurity Email Protection and the Hornetsecurity Filter Engine available for KumoMTA to scan messages in real-time.</p> <p>Only the \"scan\" function is implemented for in-line use with KumoMTA.</p>"},{"location":"userguide/integrations/hornetsecurity/#install","title":"Install","text":"<p>If you have not already done so, contact Hornetsecurity for documentation, binary and license.  Configure Hornetsecurity Email Protection as per their documentation.</p> <p>EG:</p> <pre><code>$ sudo dpkg -i hornetsecurity-emailprotection_5.0.0_amd64.deb\n</code></pre> <p>Then edit settings in <code>/opt/hornetsecurity/emailprotection/etc/emailprotection.toml</code> including the filter LICENSE and PROFILE</p> <p>Add <code>local hornet = require 'policy-extras.hornet'</code> to the top level of init.lua with the other requires.</p> <p>Call the hornet service from inside init.lua with <code>hornet:&lt;function&gt;(params)</code>.  See usage details below</p>"},{"location":"userguide/integrations/hornetsecurity/#api-license-key","title":"API License Key","text":"<p>You need a license key to use the Hornetsecurity Email Protection. This key will be provided to you by Hornetsecurity.</p> <p>This key must be appended to the Email Protection configuration file.</p>"},{"location":"userguide/integrations/hornetsecurity/#usage","title":"Usage","text":""},{"location":"userguide/integrations/hornetsecurity/#hornetconnect","title":"hornet:connect","text":"<p>To connect to a Hornetsecurity Email Protection service use <code>hornethost = hornet:connect(host, params)</code> in the top level of init.lua.</p> <pre><code>Inputs:\n  host: Hornet Service hostname or IP address (string)\n  params: Array of options including\n       PORT (integer, default = 8080),\n       TIMEOUT (integer, Time in seconds. Default =  10),\n       USE_TLS (boolean, To use TLS or not),\n\nReturns: Table of Connection Parameters\n</code></pre>"},{"location":"userguide/integrations/hornetsecurity/#ping-version-enginestatus-update","title":"ping, version, enginestatus, update","text":"<p>These API functions are not necessary and are not directly supported within KumoMTA.  All of these are accessible with simple cURL calls in the command shell.  Please refer to the Hornetsecurity documentation.</p>"},{"location":"userguide/integrations/hornetsecurity/#hornetscan","title":"hornet:scan","text":"<p>To scan a message, use <code>result = hornet:scan(hornethost,extraparams,msg)</code> in any event that can access the full message content. EG: <code>smtp_server_message_received</code></p> <p>Note that <code>hornet:connect</code> must be called prior to <code>hornet:scan</code>. <pre><code>Inputs:\n  hornethost: Hornet service host object\n  extraparams: Table of:\n     addheaders = true/false   -- Add result headers directly to the message?\n     mode = string            -- make this smtpout (default) to indicate outbound scanning, smtpin for inbound\n     x_sanitize = true/false  -- make this true to have the engine remove dangerous attachments\n  msg: The KumoMTA message variable\n\nReturns: array containing the result of the scan\nIE: \"200 OK: {\"state\":1,\"score\":250,\"verdict\":\"spam:low\",\"spamcause\":\"gggr...omh\",\"elapsed\":\"14ms\"}\"\n</code></pre></p> <p>If the extra parameter <code>addheaders</code> = <code>true</code>, then the scan result headers will be added directly to the message before delivery.</p> <pre><code>IE:\nX-Hornet-spamcause: gggr...omh\nX-Hornet-verdict: malware\nX-Hornet-elapsed: 6ms\nX-Hornet-state: 2\nX-Hornet-score: 9999\n</code></pre> <p>Note that messages will not be quarantined or dropped automatically regardless of the <code>verdict</code> or <code>score</code>.  We recommend you code actions based on the Hornetsecurity best practices documentation.</p> <pre><code>if result.verdict == 'malware' then\n  kumo.reject(552, 'Bounced for detected malware')\nend\n</code></pre>"},{"location":"userguide/integrations/hornetsecurity/#example-code","title":"Example code","text":"<pre><code>local hornet = require 'policy-extras.hornet'\n\nkumo.on('smtp_server_message_received', function(msg)\n  -- Connect to Hornetsecurity service on the local node\n  print 'Checking the Hornet Server'\n  local hornethost =\n    hornet:connect('172.31.17.26', { port = '8080', use_tls = 'false' })\n\n  if not hornethost then\n    print 'No connection to Hornetsecurity host'\n  else\n    local extras = {\n      addheaders = true,\n      mode = 'smtpout',\n      X_Sanitize = false,\n    }\n\n    local result = hornet:scan(hornethost, extras, msg)\n    if result ~= nil then\n      if result.error ~= nil then\n        print('Hornetsecurity scan error: ' .. result.error)\n      else\n        --      print (\"Hornetsecurity scan result :\" .. result)\n      end\n\n      if result.verdict == 'malware' then\n        kumo.reject(552, 'Bounced for detected malware')\n      end\n    end\n  end\n\n  -- rest of smtp_server_message_received processing code goes below\nend)\n</code></pre>"},{"location":"userguide/integrations/mautic/","title":"Mautic integration","text":""},{"location":"userguide/integrations/mautic/#introduction","title":"Introduction","text":"<p>Mautic is an open source  marketing automation project that drives email campaigns. This page explains how to use Mautic with KumoMTA.</p>"},{"location":"userguide/integrations/mautic/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/mautic/#get-kumomta","title":"Get KumoMTA","text":"<p>Install KumoMTA as per the installation instructions here.  Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.</p> <p>Ensure that you can inject and deliver mail through KumoMTA.</p> <p>Mautic will require an SMTP_Auth authentication connection to inject to KumoMTA, so you will also need to provide KumoMTA with a way to validate credentials.  There is an explanation and sample code on this page that will allow you to store valid user credentials in KumoMTA.</p> <p>Familiarize yourself with the documentation here on SMTP Injection.</p>"},{"location":"userguide/integrations/mautic/#get-mautic","title":"Get Mautic","text":"<p>Go to https://mautic.org/ and explore the project and your options;  There are many. You can download the production zip or you can checkout the GitHub repo depending on how much you want to customize and contribute.</p> <p>Follow the install instructions here</p> <p>KumoMTA accepts messages for delivery with SMTP_Auth Plain authentication. This is the default for Mautic, but you may need to make specific edits based on their Symfony Mailer ingtegration so the DSN looks like <code>smtp://user:pass@smtp.example.com:port</code>. See this for more detail.</p> <p>If you already have Mautic version 4 or earlier, the next step may be as easy as completing the configuration here</p> <p>If you have Mautic version 5 or newer, then the above is likely still true, but you may need to configure settings to specify the DSN as described here or use this community contributed webhook callback. </p> <p>If you have done everything right, you should now be able to send messages from Mautic through KumoMTA with SMTP.</p>"},{"location":"userguide/integrations/ongage/","title":"Ongage SMTP integration","text":""},{"location":"userguide/integrations/ongage/#introduction","title":"Introduction","text":"<p>Ongage is an email marketing platform that allows you to create and manage content and campaigns then deliver them through your favourite sending engine. This integration describes how to use KumoMTA as the delivery engine for Ongage.</p>"},{"location":"userguide/integrations/ongage/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/ongage/#get-kumomta","title":"Get KumoMTA","text":"<p>Install KumoMTA as per the installation instructions here.  Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.</p> <p>As part of this process, you will be creating a DNS entry for \u201cbounce.yoursendingdomain\u201d, as well as similar tracking and image domains so be prepared to edit your DNS.</p> <p>Ensure that you can inject mail using SMTP_Auth (Plain) with TLS. Remember to add the access credentials and test it. See this page for more information on injection.</p> <p>Note</p> <p>TLS is crucial to this process, so ensure you have a valid and tested certificate attached to your listener config. See tls_certificate.</p>"},{"location":"userguide/integrations/ongage/#get-ongage","title":"Get Ongage","text":"<p>Go to Ongage.com and create an account.</p> <p>Create a support ticket to request access to use the \u201cPrivate SMTP\u201d connector and let them know you are using KumoMTA as the sending MTA.</p> <p>Here is some essential reading before you set up the Private SMTP connector: </p> <p>Once registered, you can add a vendor by selecting Vendors &gt; My Connections in the left menu</p> <p></p> <p>Create a new connection and add \u201cPrivate SMTP\u201d as the connection type.</p> <p>Note</p> <p>If you do not see this as an option, jump back up to step 4 and ask Ongage Support to add it for you.</p> <p>Now fill in all the required fields and test.</p> <ul> <li>You can choose any username and password you like, KumoMTA has no preset or preference.  These credentials should match what you set above.</li> <li>Select PLAIN authentication Type</li> <li>Select YES for \u201cUse TLS\u201d</li> <li>The SMTP Port should match what your listener is listening on.  Remember to update your public firewall too.</li> </ul> <p>If you have done everything right, you will see a positive notification that credentials were verified.</p> <p>Pat yourself on the back then start using Ongage with KumoMTA.</p>"},{"location":"userguide/integrations/postmastery/","title":"Deliverability Reporting with Postmastery Console","text":"<p>Postmastery Console is a third-party cloud-hosted tool for monitoring deliverability and the factors that affect deliverability such as blocklisting, DMARC reports, and messaging best practices. Postmastery Console is able to incorporate data provided by KumoMTA to give a full picture of an organization's deliverability. More information on Postmastery Console can be found at https://www.postmastery.com/postmastery-email-analytics-console/.</p> <p>Postmastery Console integrates with KumoMTA via webhooks.</p> <p>For detailed instructions on configuring KumoMTA to send webhooks to Postmastery Console, see https://postmastery.atlassian.net/wiki/spaces/PD/pages/301596673/KumoMTA+event+webhook+with+log_hook+helper.</p>"},{"location":"userguide/integrations/prometheus/","title":"Observability with Prometheus","text":""},{"location":"userguide/integrations/prometheus/#introduction","title":"Introduction","text":"<p>Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud. Prometheus collects and stores its metrics as time series data, i.e. metrics information is stored with the timestamp at which it was recorded, alongside optional key-value pairs called labels. </p>"},{"location":"userguide/integrations/prometheus/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/prometheus/#get-kumomta","title":"Get KumoMTA","text":"<p>Install KumoMTA as per the installation instructions here</p> <p>Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.</p> <p>Ensure that you can inject and deliver mail before proceeding.</p>"},{"location":"userguide/integrations/prometheus/#get-prometheus","title":"Get Prometheus","text":"<p>First, Install Node-Exporter to collect typical system metrics to push to Prometheus. If you are configuring a cluster, node-exporter should be installed on each node.</p> <p>There is also a very handy step-by-step guide here</p> <pre><code>$ cd\n$ wget https://github.com/prometheus/node_exporter/releases/download/v1.6.0/node_exporter-1.6.0.linux-amd64.tar.gz\n$ tar xvfz node_exporter-*.*-amd64.tar.gz\n$ cd node_exporter-*.*-amd64\n$ ./node_exporter &amp;\n</code></pre> <p>This leaves the process running so press RETURN / Hit ENTER.  You will probably want to add that to your start up processes.</p> <p>You can test this with a simple curl : <code>curl http://localhost:9100/metrics</code></p> <p>Now, Install Prometheus for system reporting. Get an appropriate version from here. Theoretically this can be set up on a remote server to collect metrics from your whole cluster.  In this document we will install version 2.47.2 on localhost. </p> <pre><code>$ cd\n$ wget https://github.com/prometheus/prometheus/releases/download/v2.47.2/prometheus-2.47.2.linux-amd64.tar.gz\n$ tar xvf prometheus-*.*-amd64.tar.gz cd prometheus-2.47.2.linux-amd64/\n</code></pre> <p>Create or modify a Prometheus yaml file so it includes this node\u2019s feed.  If you are configuring a cluster, add references to all the nodes here too.  This can be saved almost anywhere.  The command below creates the file in <code>./myprometheus.yml</code>. The job name <code>kumomta</code> will collect email metrics using the metrics API. The job name <code>systemstats</code> will collect OS and machine metrics.</p> <pre><code>$ echo \" \nglobal: \n   scrape_interval: 15s \nscrape_configs:  \n  - job_name: 'kumomta' \n    static_configs: \n      - targets: ['localhost:8000'] \n  - job_name: 'systemstats' \n    static_configs: \n      - targets: ['localhost:9100'] \n\" &gt; ./myprometheus.yml\n</code></pre> <p>Now start it with the yaml file mentioned above:</p> <pre><code>$ ./prometheus --config.file=./myprometheus.yml\n</code></pre> <p>You should now be able to access and manage data sources in the Prometheus webUI on port 9090. Node metrics will use port 9100 internally to feed data to Prometheus. </p> <p>Remember to update your firewall to securely access port 9090</p> <p>The UI is wide open by default so take measures to lock down access with usual network tools.</p> <p>If you have done this all correctly, you should be able to access the target status with <code>http://&lt;your_domain&gt;:9090/targets</code> in the Prometheus webUI.  The result should look something like this:</p> <p></p>"},{"location":"userguide/integrations/rspamd/","title":"Rspamd Spam filter","text":""},{"location":"userguide/integrations/rspamd/#introduction","title":"Introduction","text":"<p>Rspamd is an open source email spam filtering tool that can be integrated with KumoMTA</p>"},{"location":"userguide/integrations/rspamd/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/rspamd/#first-things","title":"First things","text":"<p>Spam filtering engines can be complex and require an understanding or patern matching and email handling rule sets.  Please read through the quickstart documentation FIRST before proceeding: https://docs.rspamd.com/tutorials/quickstart/</p>"},{"location":"userguide/integrations/rspamd/#get-kumomta","title":"Get KumoMTA","text":"<p>Install KumoMTA as per the installation instructions here.</p> <p>Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.</p> <p>Ensure that you can inject and deliver mail through KumoMTA.</p> <p>Add the following to your init.lua config, in the top part of the config, before the init section, place this variable declaration: </p> <pre><code>local RSPAMD_URL = 'http://localhost:11333/checkv2'\n</code></pre> <p>Then in the <code>smtp_server_message_received</code> event add code to pass the message to rspamd for evaluation:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg, conn_meta)\n  local request = kumo.http.build_client({}):post(RSPAMD_URL)\n  request:body(msg:get_data())\n  local response = request:send()\n  if response:status_code() == 200 then\n    local data = kumo.serde.json_parse(response:text())\n    if data['score'] &gt;= 15 then -- rspamd recommends rejecting the message\n      kumo.reject(550, 'We do not send spam')\n    end\n  end\n  -- the rest of your handler\nend)\n</code></pre> <p>Note that you can modify the score threshold and reject message as needed.</p>"},{"location":"userguide/integrations/rspamd/#get-rspamd","title":"Get Rspamd","text":"<p>Read and follow the first 3 (THREE) steps in this guide: https://docs.rspamd.com/tutorials/quickstart/</p> <p>STOP when you hit step 4.  Do NOT install Postfix.</p> <p>Restart the rspamd process with <code>sudo systemctl restart rspamd</code></p> <p>Continue the install and test process starting at step 5 (five) here: https://docs.rspamd.com/tutorials/quickstart/</p> <p>Your rspamd configuration should now test every mesage injected to KumoMTA.</p>"},{"location":"userguide/integrations/tatamimonitor/","title":"Tatami Monitor integration","text":""},{"location":"userguide/integrations/tatamimonitor/#introduction","title":"Introduction","text":"<p>Tatami Monitor is an email monitoring and alerting platform that brings real-time insights to your email infrastructure. This integration describes how to us e Tatami Monitor with KumoMTA.</p>"},{"location":"userguide/integrations/tatamimonitor/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/tatamimonitor/#get-kumomta","title":"Get KumoMTA","text":"<p>1) Install KumoMTA as per the installation instructions here https://docs.kumomta.com/userguide/installation/overview/</p> <p>Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.</p> <p>2) Ensure that you can inject and deliver mail through KumoMTA.</p>"},{"location":"userguide/integrations/tatamimonitor/#get-connected-to-tatami-monitor","title":"Get connected to Tatami Monitor","text":"<p>3) Go to https://tatamimonitor.com/ and create an account by clicking the \"Sign Up\" button.</p> <p>4) Tatami will send you back a webhook key.  Add a new log-hook to your init.lua right before the init section like this: <pre><code>log_hooks:new_json {\n  name = 'webhook_tatami',\n  url = 'https://tatamimonitor.com/api/v1/webhooks/events/your_webhook_key_goes_here',\n  log_parameters = {\n    headers = { 'Subject', 'X-Customer-ID' },\n  },\n}\n</code></pre></p> <p>5) If you need to, you can modify the <code>log_parameters</code> as per https://docs.kumomta.com/reference/kumo/configure_log_hook/</p> <p>If you have done everything right, you should see your data fill the Tatami Monitor feed almost immediately.</p>"},{"location":"userguide/operation/cancel/","title":"Cancelling Queued Messages","text":"<p>Occasionally, you will have a bad send or for some reason need to cancel a send quickly. OOPS! It happens.  KumoMTA offers an API specifically for administratively canceling messages with surgical precision. The Admin Bounce API can target a specific Campaign, Queue, or entire Tenant for cancellation.</p> <p>You easiest way to invoke this API is via the kcli bounce utility, but you can also use <code>curl</code> directly.</p> <p>Warning</p> <p>There is no way to undo the actions carried out by this request!</p> <p>You can set a time period that you want the bounce to last for; default is 5 minutes.  This can be handy if you need to catch all new injections for the next hour and you don't want to keep running the command.</p> <p>This will bounce everything and is not reversible - handle with care: </p> kclicurl <pre><code>$ /opt/kumomta/sbin/kcli bounce --everything \\\n      --reason 'PURGING ALL THE QUEUES!'\n</code></pre> <pre><code>$ curl -i 'http://localhost:8000/api/admin/bounce/v1' \\\n     -H 'Content-Type: application/json' \\\n     -d '{\"reason\":\"PURGING ALL THE QUEUES!\"}'\n</code></pre> <p>This will bounce all mail destined to yahoo.com:</p> kclicurl <pre><code>$ /opt/kumomta/sbin/kcli bounce --domain yahoo.com \\\n       --reason 'felt like it'\n</code></pre> <pre><code>$ curl -i 'http://localhost:8000/api/admin/bounce/v1' \\\n      -H 'Content-Type: application/json' \\\n      -d '{\"domain\": \"yahoo.com\", \"reason\":\"felt like it\"}'\n</code></pre> <p>This will bounce all mail to any domain in the campaign \u201cBack to school\u201d </p> kclicurl <pre><code>$ /opt/kumomta/sbin/kcli bounce --campaign 'Back to school' \\\n        --reason 'felt like it'\n</code></pre> <pre><code>$ curl -i 'http://localhost:8000/api/admin/bounce/v1' \\\n       -H 'Content-Type: application/json' \\\n       -d '{\"campaign\": \"Back to school\", \"reason\":\"felt like it\"}'\n</code></pre> <p>NOTE: All fields are case-sensitive. However, domain names are normalized to lowercase when a message is queued, so our internal queue names are always built from the lower cased domain name.</p>"},{"location":"userguide/operation/command-line-index/","title":"Supporting utilities","text":"<p>KumoMTA comes with several utilities that are useful for debugging or supporting KumoMTA.  These are located in <code>/opt/kumomta/sbin/</code>.</p>"},{"location":"userguide/operation/command-line-index/#utilities-list","title":"Utilities list","text":"<ul> <li>validate-shaping - Used for validating the syntax of your custom shaping files. Using this tool is as simple as providing the shaping file to the utility on the command line. IE: <code>/opt/kumomta/sbin/validate-shaping /opt/kumomta/etc/policy/shaping.toml</code></li> <li>resolve-shaping-domain - Used for identifying which traffic shaping rules will be applied to a given destination domain. IE: <code>/opt/kumomta/sbin/resolve-shaping-domain mosaicco.com</code></li> <li>tsa-daemon - The TSA Daemon is a tool that can provide centralized traffic shaping data for your entire cluster even across data centers, providing the KumoMTA nodes can connect to it over TCP. This is typically launched from KumoMTA directives as documented here</li> <li>traffic-gen - TrafficGen is a handy performance testing tool that uses core KumoMTA speed to generate high-volume injection testing SMTP messages. Usage instructions are available with <code>/opt/kumomta/sbin/traffic-gen --help</code></li> <li>tailer - Tailer provides a flexible command line tool for tracing log activity in real-time without having to <code>tail -f</code> the actual logs. It allows you to filter for specific patterns or evaluate a specific batch size of log lines. Usage instructions are available with <code>/opt/kumomta/sbin/tailer --help</code>  More details can be found here.</li> <li>proxy-server - KumoProxy is a functional socks5 proxy server that can run independently from KumoMTA.  Usage instructions are available with <code>/opt/kumomta/sbin/proxy-server --help</code></li> <li>accounting.sh - a helpful tool to show volumes of messages sent and received in a calendar month.  This can be helpful for your own purposes in tracking monthly and annual volume.             </li> <li>toml2jsonc - As implied by the name, will convert a TOML file to JSON.</li> <li>explain-throttle - explains how a throttle is interpreted by Kumomta</li> <li>resolve-queue-config  - similar to <code>resolve-shaping-domain</code> but will show queue settings for that particular domain or MX</li> <li>resolve-site-name - provides the result of how KumoMTA sees the MX-Rollup for the target domain.  For instance <code>/opt/kumomta/sbin/resolve-site-name kumomta.com</code> results in <code>smtp.google.com</code></li> <li>tls-probe can be used in two ways.  With the <code>probe</code> option, if can test if an MX supports STARTTLS. With the list-rustls-cipher-suites options, it will show all cipher suites supported by rustls.</li> <li>kcli - KumoMTA Command Line Interface (KCLI) is a useful tool for accessing the HTTP API directly from the command line. Usage instructions are available with <code>/opt/kumomta/sbin/kcli --help</code>  More details can be found here.</li> <li>kumod - this is the actual KumoMTA daemon and is just listed here for completeness.</li> </ul>"},{"location":"userguide/operation/httpinjection/","title":"Injecting Using HTTP","text":"<p>KumoMTA will listen for message injection in any listener defined in configuration. You have complete control over the IPs and Ports available for message injection.</p> <p>The HTTP Listener will accept any properly formatted HTTP connection request allowed by its configuration.  For instance, based on this:</p> <pre><code>kumo.start_http_listener {\n  use_tls = true,\n  listen = '0.0.0.0:8005',\n  -- allowed to access any http endpoint without additional auth\n  trusted_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre> <p>KumoMTA will accept any HTTPS injection on port 8005 from the local host ONLY. (This also enables the full HTTP API from localhost).</p> <p>The simplest test of HTTP injection can be done using cURL right from localhost console.</p> <pre><code>$ curl -i 'http://localhost:8005/api/inject/v1' \\\n -H 'Content-Type: application/json' -d '\n{\"envelope_sender\": \"noreply@example.com\",\n \"content\": \"Subject: hello\\n\\nHello there\",\n \"recipients\": [{\"email\": \"recipient@example.com\"}]\n}'\n</code></pre> <p>That should return something like this:</p> <pre><code>{\"success_count\":1,\"fail_count\":0,\"failed_recipients\":[],\"errors\":[]}\n</code></pre> <p>Any system that can use an HTTP API to pass JSON should work as an injection system if you follow the JSON payload formatting rules posted here</p>"},{"location":"userguide/operation/kcli/","title":"Using the kcli Command-Line Client","text":"<p>KumoMTA comes with several API endpoints to make administration of the server easier for common tasks, and additionally comes with the <code>kcli</code> command-line client which provides access to the APIs for local administrative tasks.</p> <p>The <code>kcli</code> client is located at <code>/opt/kumomta/sbin/kcli</code> and requires a configured HTTP Listener to function.</p> <p>At minimum, the <code>kcli</code> client must be passed an endpoint and a command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-list\n</code></pre> <p>The <code>--endpoint</code> parameter indicates the HTTP API endpoint you have configured for your KumoMTA instance.  This documentation uses <code>http://127.0.0.1:8000</code> because that endpoint is shown as a suggested default for that http listener.  You need to adjust it to match whatever you have configured for your HTTP listener in your environment.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The <code>--endpoint</code> defaults to <code>http://127.0.0.1:8000</code> and can be omitted. If <code>KUMO_KCLI_ENDPOINT</code> is set in the environment, its value will be used if <code>--endpoint</code> is not specified.</p> <p>In earlier versions, you need to explicitly pass <code>--endpoint</code>.</p>"},{"location":"userguide/operation/kcli/#monitoring-queue-status","title":"Monitoring Queue Status","text":"<p>The <code>kcli</code> client can be used to report on messages currently queued in the server with the following format:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 queue-summary\n{\nSITE                                              SOURCE       PROTO       D T C   Q\n(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com hdfc.s-ip102 smtp_client 0 0 5 995\n(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com hdfc.s-ip103 smtp_client 0 0 5 995\n...\n}\n</code></pre> <p>Note</p> <p>This output format is subject to change and is not suitable for a machine to parse. It is expressly unstable and you must not depend upon it in automation.</p> <p>The data behind this output is pulled from the metrics.json endpoint, which is machine readable.</p> <p>The output is presented in two sections:</p> <ol> <li>The ready queues</li> <li>The scheduled queues</li> </ol> <p>The ready queue data is presented in columns that are mostly self explanatory, but the numeric counts are labelled with single character labels:</p> <ul> <li>D - the total number of delivered messages</li> <li>T - the total number of transiently failed messages</li> <li>C - the number of open connections</li> <li>Q - the number of ready messages in the queue</li> </ul> <p>Note that the ready queue counter values reset whenever the ready queue is reaped, which occurs within a few minutes of the ready queue being idle, so those numbers are only useful to get a sense of recent/current activity. Accurate accounting must be performed using the delivery logs and not via this utility.</p> <p>The scheduled queue data is presented in two columns; the queue name and the number of messages in that queue.</p>"},{"location":"userguide/operation/kcli/#managing-bounces","title":"Managing Bounces","text":""},{"location":"userguide/operation/kcli/#bouncing-messages","title":"Bouncing Messages","text":"<p>The kcli bounce command can be used to administratively bounce messages currently queued in the server with the following format:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce --everything --reason purge\n{\n  \"id\": \"0234c7c9-afd3-49f9-9a4c-a1cc37fcc53b\",\n  \"bounced\": {},\n  \"total_bounced\": 0\n}\n</code></pre> <p>Allowed arguments for the bounce command include:</p>"},{"location":"userguide/operation/kcli/#domain","title":"domain","text":"<p>Optional string. The domain name to match. If omitted, any domain will match.</p>"},{"location":"userguide/operation/kcli/#campaign","title":"campaign","text":"<p>Optional string. The campaign name to match. If omitted, any campaign will match.</p>"},{"location":"userguide/operation/kcli/#tenant","title":"tenant","text":"<p>Optional string. The tenant to match. If omitted, any tenant will match.</p> <p>Danger</p> <p>If you specify none of <code>domain</code>, <code>campaign</code> or <code>tenant</code>, then ALL queues will be bounced.</p> <p>With great power, comes great responsibility!</p>"},{"location":"userguide/operation/kcli/#reason","title":"reason","text":"<p>Required. Reason to log in the delivery log.</p>"},{"location":"userguide/operation/kcli/#duration","title":"duration","text":"<p>Optional duration string. Defaults to <code>\"5m\"</code>. Specifies how long this bounce directive remains active.</p> <p>While active, newly injected messages that match the bounce criteria will also be bounced.</p> <p>See the Bounce API page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#listing-current-bounces","title":"Listing Current Bounces","text":"<p>You can list the currently active bounce commands with the kcli bounce-list command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-list\n[\n  {\n    \"id\": \"169c3dc0-6518-41ef-bfbb-1f0ae426cb32\",\n    \"campaign\": null,\n    \"tenant\": null,\n    \"domain\": null,\n    \"reason\": \"purge\",\n    \"duration\": \"4m 50s 207ms 320us 231ns\",\n    \"bounced\": {\n      \"wezfurlong.org\": 1\n    },\n    \"total_bounced\": 1\n  }\n]\n</code></pre> <p>See the Admin Bounce List API page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#removing-a-bounce","title":"Removing a Bounce","text":"<p>Because bounce commands default to a five-minute duration, messages will continue to bounce after the command has been issued. This helps with scenarios such as when a campaign needs to be aborted, but the entire campaign may not have been injected at the time the command was issued.</p> <p>Sometimes after a bounce has been issued there is a need to cancel the bounce before the time window has expired. Once a bounce command's ID is determined with the <code>bounce-list</code> command, the bounce can be canceled with the kcli bounce-cancel command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-cancel --id 169c3dc0-6518-41ef-bfbb-1f0ae426cb32\nremoved 0234c7c9-afd3-49f9-9a4c-a1cc37fcc53b\n</code></pre> <p>See the Bounce Cancel API page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#managing-suspensions","title":"Managing Suspensions","text":""},{"location":"userguide/operation/kcli/#setting-the-diagnostic-log-level","title":"Setting The Diagnostic Log Level","text":"<p>While the log level is typically set in your configuration, it can also be set on an ad-hoc basis using the kcli set-log-filter command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 set-log-filter 'kumod=trace'\nOK\n</code></pre> <p>See the Set Diagnostic Log Filter page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#monitoring-inbound-smtp-handshaking","title":"Monitoring Inbound SMTP handshaking","text":"<p>When debugging, it is often helpful to monitor the full SMTP handshaking process in real-time.  The kcli client enables that for inbound connections with the <code>trace-smtp-server</code> function:</p> <pre><code>$ kcli trace-smtp-server\n</code></pre> <p>Additional information on monitoring inbound connections is available on the kcli trace-smtp-server page of the reference manual.</p>"},{"location":"userguide/operation/kcli/#monitoring-outbound-smtp-connections","title":"Monitoring Outbound SMTP Connections","text":"<p>It is common to encounter issues when attempting to deliver to a given destination, while most destinations are delivered to without issues.</p> <p>In those situations it helps to be able to monitor the oubound connections in question to identify any issues during the communications:</p> <pre><code>$ kcli trace-smtp-client\n</code></pre> <p>Additional information on monitoring outbound connections is available on the kcli trace-smtp-client page of the reference manual.</p>"},{"location":"userguide/operation/kumo-proxy/","title":"Using the KumoProxy Socks5 proxy utility","text":"<p>KumoMTA comes with a socks5 proxy of our own design to assist with deployment of cluster environments.</p> <p>The binary is located at <code>/opt/kumomta/sbin/proxy-server</code> and can be operated independently from KumoMTA.</p> <p>The fast path to success is to clone the KumoMTA repo to a new server that has network capabilities and public facing IPs.  You do not need to configure or start KumoMTA.  To execute the proxy, use the command <code>/opt/kumomta/sbin/proxy-server --listen &lt;IP:Port&gt;</code></p> <p>Ensure that you have configured <code>sysctl</code> to allow for enough file handles, ip forwarding and other important factors. </p> <p>Usage documentation is at <code>/opt/kumomta/sbin/proxy-server --help</code></p>"},{"location":"userguide/operation/kumo-proxy/#configuring-kumpproxy-to-survive-a-restart","title":"Configuring KumpProxy to survive a restart","text":"<p>KumoProxy can be configured as a systemd service</p> <p>Note that this has only been tested for Ubuntu 24.  Your OS may require slightly different configuration.</p> <p>You will need sudo access to perform these changes.  Start by creating a service file.</p> <p><code>sudo vi /etc/systemd/system/kumoproxy.service</code></p> <p>Populate it with: <pre><code>[Unit]\nDescription=KumoMTA SOCKS5 Proxy service\nAfter=syslog.target network.target\n\n[Service]\nType=simple\nRestart=always\nEnvironmentFile=-/opt/kumomta/etc/kumoproxy.env\nExecStart=/opt/kumomta/sbin/proxy-server --listen ${PROXY_IP}:${PROXY_PORT}\nTimeoutStopSec=10\n\n[Install]\nWantedBy=multi-user.target\n</code></pre></p> <p>Next, create an environment file where you can add your system variables.</p> <p><code>sudo vi /opt/kumomta/etc/kumoproxy.env</code></p> <p>Populate with your IP and Port</p> <p>IE: <pre><code>PROXY_IP=\"172.31.37.164\"\nPROXY_PORT=\"5000\"\n</code></pre></p> <p>Reload the services: <code>sudo systemctl daemon-reload</code></p> <p>Now you can <code>start</code>, test <code>status</code> and <code>enable</code> like any other service.  Do these manually once to ensure the service starts.  After it is <code>enabled</code> it will restart automatically on reboot. <pre><code>sudo systemctl start kumoproxy\nsudo systemctl status kumoproxy\nsudo systemctl enable kumoproxy\n</code></pre></p>"},{"location":"userguide/operation/logs/","title":"Viewing Logs","text":"<p>An important part of routine opperations is checking logs. KumoMTA compressed logs are found in <code>/var/log/kumomta/</code> and are named by date stamp. Logs are segmented by a combination of size/time and stored in compressed files named after the time that the segment was started. To read these, you need to unpack them first. You have many options for configuring logging.</p> <pre><code>/var/log/kumomta\n\u251c\u2500\u2500 20230311-033705\n\u251c\u2500\u2500 20230311-033844\n\u251c\u2500\u2500 20230312-182542\n\u2514\u2500\u2500 20230314-181435\n</code></pre>"},{"location":"userguide/operation/logs/#using-tailer","title":"Using <code>tailer</code>","text":"<p>The <code>tailer</code> utility, found at <code>/opt/kumomta/sbin/tailer</code>, is the easiest way to quickly review logs.  The <code>--tail</code> flag will follow the log files in real time:</p> <pre><code>$ sudo /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n/var/log/kumomta/20230809-153944\n{\"type\":\"Reception\",\"id\":\"f68462cf36ca11ee99f450ebf67f93bd\",\"sender\":\"wez@exa\nmple.com\",\"recipient\":\"wez@example.com.org\",\"queue\":\"example.com.org\",\"site\":\n\"\",\"size\":518,\"response\":{\"code\":250,\"enhanced_code\":null,\"content\":\"\",\"comma\nnd\":null},\"peer_address\":{\"name\":\"foo.lan\",\"addr\":\"127.0.0.1\"},\"timestamp\":16\n91595584,\"created\":1691595584,\"num_attempts\":0,\"bounce_classification\":\"Uncat\negorized\",\"egress_pool\":null,\"egress_source\":null,\"feedback_report\":null,\"met\na\":{},\"headers\":{},\"delivery_protocol\":null,\"reception_protocol\":\"ESMTP\",\"nod\neid\":\"4eb22880-dc03-44dc-a4d1-4d0e68ac7845\"}\nwaiting for more files\n</code></pre> <p>The above example is shown artificially wrapped for the purposes of displaying nicely in this documentation. The actual log records are not output with wrapping.</p>"},{"location":"userguide/operation/logs/#manually","title":"Manually","text":"<p>We can take a look at a specific log by decompressing it and since these are zstd compressed, you can view all but the current one with zstdcat. ZSTD is a streaming compression utility so the current file cannot be accessed until it is flushed and closed. You can force the current log to close by stopping KumoMTA.</p> <p>The default for log segments is to flush them after 1GB of data is written, but you can adjust them to flush after a certain amount of time if you find that you are regularly wanting to inspect the logs on a live system.</p> <p>kumo.configure_local_logs has all of the available logging configuration options.</p> <p>Using the example above, we can see the content of the newest file after stopping KumoMTA with a <code>zstdcat /var/log/kumomta/20230314-181435</code>.</p> <p>If you have not done so already, you will want to install <code>zstd</code> with a (<code>dnf</code> or) <code>apt install zstd</code>.  Below there is a sample of a decompressed received log:</p> <pre><code>$ zstdcat /var/log/kumomta/20230428-201424_recv\n{\"type\":\"Reception\",\"id\":\"44d70f50e60111ed8162000d3afc4acf\",\"sender\":\"noreply@example.com\",\n\"recipient\":\"recipient@example.com\",\"queue\":\"example.com\",\"site\":\"\",\"size\":27,\n\"response\":{\"code\":250,\"enhanced_code\":null,\"content\":\"\",\"command\":null},\n\"peer_address\":{\"name\":\"\",\"addr\":\"127.0.0.1\"},\"timestamp\":1682712864,\"created\":1682712864,\n\"num_attempts\":0,\"bounce_classification\":\"Uncategorized\",\"egress_pool\":null,\"egress_source\":null,\n\"feedback_report\":null,\"meta\":{},\"headers\":{\"Subject\":\"hello\"}}\n</code></pre> <p>These JSON formatted logs can be programatically consumed or read manually as shown above for debugging and maintenance.</p> <p>Formatting can also be applied using the Mini Jinja templating engine.</p>"},{"location":"userguide/operation/outbound_auth/","title":"Delivering Messages Using SMTP AUTH","text":"<p>While not used when delivering messages to remote hosts under normal circumstances, there are scenarios where the KumoMTA server must authenticate when relaying mail. Some examples include:</p> <ul> <li>Relaying incoming mail to internal hosts that require authentication.</li> <li>Relaying outgoing mail through a third-party relay provider via SMTP.</li> <li>Delivering mail to a peer system as part of a processing chain.</li> </ul>"},{"location":"userguide/operation/outbound_auth/#configuring-an-egress_path-to-use-auth","title":"Configuring an egress_path to Use AUTH","text":"<p>The following example shows how SMTP AUTH information can be added to an egress_path config:</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      enable_tls = 'Required',\n      smtp_auth_plain_username = 'daniel',\n      -- The password can be any keysource value\n      smtp_auth_plain_password = {\n        key_data = 'tiger',\n      },\n    }\n  end\n)\n</code></pre> <p>Warning</p> <p>The above example would add AUTH credentials to every outbound connection. In production, this should be selectively applied based on the destination host or domain.</p> <p>See the make_egress_path section of the Reference Manual for more information.</p>"},{"location":"userguide/operation/outbound_auth/#using-a-keysource-with-smtp-auth","title":"Using a Keysource with SMTP AUTH","text":"<p>Storing credentials in a static policy file is not recommended. KumoMTA supports multiple options for secure key storage, and we highly recommend that all authentication and signing keys be stored in a keysource.</p> <p>When using a keysource, the value of `smtp_auth_plain_password is any keysource, which allows for specifying the password via a credential manager such as HashiCorp Vault.</p> <pre><code>kumo.on(\n  'get_egress_path_config',\n  function(routing_domain, egress_source, site_name)\n    return kumo.make_egress_path {\n      enable_tls = 'Required',\n      smtp_auth_plain_username = 'daniel',\n      -- The password can be any keysource value.\n      -- Here we are loading the credential for the domain\n      -- from HashiCorp vault\n      smtp_auth_plain_password = {\n        vault_mount = 'secret',\n        vault_path = 'smtp-auth/' .. routing_domain,\n        -- Optional: specify a custom key name (defaults to \"key\")\n        -- vault_key = \"password\"\n      },\n    }\n  end\n)\n</code></pre> <p>See the keysource section of the Reference Manual for more information.</p>"},{"location":"userguide/operation/outbound_auth/#using-the-traffic-shaping-helper-with-auth-parameters","title":"Using The Traffic Shaping Helper with AUTH Parameters","text":"<p>As mentioned earlier, SMTP AUTH must be selectively applied. One way to facilitate the configuration of SMTP AUTH is to use the <code>shaping.lua</code> traffic shaping helper.</p> <p>When using shaping.lua, the hostname or IP of the target host can be used as a domain, with mx_rollup disabled, and the AUTH options listed.</p> <p>For example, to use a keysource with a local host, the following could be added to a custom TOML file:</p> TOMLJSON <pre><code>[\"192.168.1.10\"]\nmx_rollup = false\nsmtp_auth_plain_username = \"daniel\"\nsmtp_auth_plain_password = { vault_mount = \"secret\", vault_path = \"smtp-auth/local\", vault_key = \"password\" }\n</code></pre> <pre><code>{\n  \"192.168.1.10\": {\n    \"mx_rollup\": false,\n    \"smtp_auth_plain_username\": \"daniel\",\n    \"smtp_auth_plain_password\": {\n      \"vault_mount\": \"secret\",\n      \"vault_path\": \"smtp-auth/local\",\n      \"vault_key\": \"password\"\n    }\n  }\n}\n</code></pre> <p>See the traffic shaping section of the User Guide for additional information.</p>"},{"location":"userguide/operation/performance/","title":"Performance","text":"<p>This page has moved, see the Performance chapter.</p>"},{"location":"userguide/operation/proxy/","title":"Routing Messages Via Proxy Servers","text":"<p>KumoMTA support SOCK5 and HAProxy for use as forward proxies as part of message delivery.</p> <p>The most common use cases for a forward proxy are:</p> <ul> <li>Sharing IP addresses between multiple KumoMTA instances for high availability.</li> <li>Leveraging more IP addresses than permitted per instance by a hosting provider.</li> <li>Utilizing IP addresses in remote environments without additional MTA instances.</li> </ul> <p>Due to the limitations inherent in the HAProxy protocol when used as a forward proxy, it is strongly recommended that SOCKS5 be utilized when possible, but HAProxy support is provided for existing installations migrating to KumoMTA.</p>"},{"location":"userguide/operation/proxy/#using-socks5-for-delivery","title":"Using SOCKS5 for Delivery","text":""},{"location":"userguide/operation/proxy/#using-the-kumoproxy-socks5-proxy-server","title":"Using The KumoProxy SOCKS5 Proxy Server","text":"<p>While KumoMTA will work with any compliant SOCKS5 proxy server, we have built KumoProxy to serve as an integrated and supported proxy server specifically for use with KumoMTA.</p> <p>Follow the instructions on the KumoProxy page for install and usage.</p>"},{"location":"userguide/operation/proxy/#configuring-an-egress_source-for-socks5-proxy-use","title":"Configuring an egress_source for SOCKS5 Proxy Use","text":"<p>Configuring an egress_source to use a SOCKS5 proxy server is done as part of the make_egress_source function call:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1, via a proxy server\n    return kumo.make_egress_source {\n      name = 'ip-1',\n\n      -- The SOCKS5 proxy server address and port\n      socks5_proxy_server = '10.0.5.10:5000',\n\n      -- Used by the SOCKS5 proxy server to connect to the destination address\n      socks5_proxy_source_address = '10.0.0.1',\n\n      ehlo_domain = 'mta1.examplecorp.com',\n    }\n  end\nend)\n</code></pre> <p>The SOCKS5 proxy server will forward communications via the <code>socks5_proxy_source_address</code> IP address to reach the remote destination host.</p> <p>Each IP address hosted by a SOCKS5 proxy server should be defined as its own <code>egress_source</code>, IPv4 and IPv6 should be configured as separate sources, but can be hosted by the same HAProxy instance(s).</p> <p>See the make_egress_source page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/proxy/#using-haproxy-for-delivery","title":"Using HAProxy for Delivery","text":"<p>KumoMTA supports V2 of the HAProxy PROXY protocol, enabling the use of HAProxy as a forward SMTP proxy for the delivery of messages via IP addresses on the HAProxy host.</p>"},{"location":"userguide/operation/proxy/#configuring-an-egress_source-for-haproxy-use","title":"Configuring an egress_source for HAProxy Use","text":"<p>Configuring an egress_source to use an HAProxy server is done as part of the make_egress_source function call:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n  if source_name == 'ip-1' then\n    -- Make a source that will emit from 10.0.0.1, via a proxy server\n    return kumo.make_egress_source {\n      name = 'ip-1',\n\n      -- The HAProxy server address and port\n      ha_proxy_server = '10.0.5.10:5000',\n\n      -- Used by HAProxy to connect to the destination address\n      ha_proxy_source_address = '10.0.0.1',\n\n      ehlo_domain = 'mta1.examplecorp.com',\n    }\n  end\nend)\n</code></pre> <p>The HAProxy server will forward communications via the <code>ha_proxy_source_address</code> IP address to reach the remote destination host.</p> <p>Each IP address hosted by an HAProxy instance should be defined as its own <code>egress_source</code>, IPv4 and IPv6 should be configured as separate sources, but can be hosted by the same HAProxy instance(s).</p> <p>See the make_egress_source page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/proxy/#haproxy-server-configuration","title":"HAProxy Server Configuration","text":"<p>An example HAProxy server config is as follows:</p> <pre><code>global\n    log stdout  format raw  local0  debug\n\ndefaults\n    timeout connect 10s\n    timeout client 30s\n    timeout server 30s\n    log global\n\nlisten outboundsmtp\n    log global\n    bind 0:2526 accept-proxy\n    mode tcp\n    use-server v4 if { src 0.0.0.0/0 }\n    use-server v6 if { src ::/0 }\n    server v4 0.0.0.0 source 0.0.0.0 usesrc clientip\n    server v6 ::: source ::: usesrc clientip\n</code></pre> <p>The HAProxy instance would be launched with the following command:</p> <pre><code>$ sudo haproxy -f haproxy.conf -V\n</code></pre> <p>For further information on HAProxy, see the HAProxy Documentation.</p>"},{"location":"userguide/operation/smtpinjection/","title":"Injecting Using SMTP","text":"<p>KumoMTA will listen for message injection in any listener defined in configuration. You have complete control over the IPs and Ports available for message injection.</p> <p>The ESMTP Listener will accept any properly formatted SMTP connection request allowed by its configuration.  For instance, based on this:</p> <pre><code>kumo.start_esmtp_listener {\n  listen = '0.0.0.0:25',\n  hostname = 'mail.example.com',\n  relay_hosts = { '127.0.0.1', '10.5.1.0/24' },\n}\n</code></pre> <p>KumoMTA will accept any SMTP injection from the local host as well as any hosts in the 10.5.1.0/24 CIDR block on port 25.  The most basic form of \"injection\" is to test from localhost using nc or telnet.</p> <pre><code>ehlo moto\nmail from:youremail@address.com\nrcpt to:youremail@address.com\nDATA\nfrom:youremail@address.com\nto:youremail@address.com\nsubject: My First Email\n\nHey, this is my first email!\n.\n</code></pre> <p>If that returns a <code>250 OK</code>, then any more complex injection should work as well.</p> <p>In most campaign systems that connect with third-party MTA's, you will need to enter the configuration settings, and find something like \"SMTP\" or \"OutBound Email\" and set the SMTP Port, Hostname or IP ddress and If you have configured SMTP_Auth, your injection username and password as well.</p> <p>Below is a configuration screen for Ongage</p> <p></p> <p>And this is a sample of the configuration page for Mautic marketing automation.</p> <p></p>"},{"location":"userguide/operation/starting/","title":"Starting KumoMTA","text":"<p>Once KumoMTA has been installed and an initial policy script is in place, the server can be started with the following command:</p> <pre><code>$ sudo systemctl start kumomta\n</code></pre> <p>It can be enabled as a service with:</p> <pre><code>$ sudo systemctl enable kumomta\n</code></pre> <p>You can check the status with:</p> <pre><code>$ sudo systemctl status kumomta\n</code></pre> <p>It can also be started manually with:</p> <pre><code>$ sudo /opt/kumomta/sbin/kumod \\\n    --policy /opt/kumomta/etc/policy/init.lua \\\n    --user kumod\n</code></pre> <ul> <li>Using sudo allows it to run as a privileged user so it can access port 25 which is needed to send and receive from most MTAs.</li> <li>The daemon <code>kumod</code> is the MTA</li> <li>The directive --policy makes kumod load the 'init.lua' file as configuration policy.</li> <li>The --user directive allows the server to drop privileges after attaching to port 25 so that it does not continue to run as root.</li> </ul> <p>For more detailed output, prepend <code>KUMOD_LOG=kumod=info</code> (or debug for even more detail):</p> <pre><code>$ sudo KUMOD_LOG=kumod=info /opt/kumomta/sbin/kumod \\\n   --policy /opt/kumomta/etc/policy/init.lua --user kumod\n</code></pre> <p>If all goes well, it should return a PID and drop you back to a Linux prompt.</p> <p>If KumoMTA does not start, refer to the Troubleshooting Page of the User Guide.</p> <p>NOTE that if you are also planning to use the TSA shaping service, you should enable that as well:</p> <pre><code>$ sudo systemctl start kumo-tsa-daemon\n</code></pre> <p>It can be enabled as a service with:</p> <pre><code>$ sudo systemctl enable kumo-tsa-daemon\n</code></pre> <p>You can check the status with:</p> <pre><code>$ sudo systemctl status kumo-tsa-daemon\n</code></pre>"},{"location":"userguide/operation/status/","title":"Getting Server Status","text":"<p>Once KumoMTA is installed, you can check on the server status with systemctl.</p> <pre><code>$ sudo systemctl status kumomta\n</code></pre> <p>The result should look something like this:</p> <pre><code> kumomta.service - KumoMTA SMTP service\n     Loaded: loaded (/lib/systemd/system/kumomta.service; enabled; vendor preset: enabled)\n     Active: active (running) since Thu 2023-04-27 22:59:06 MST; 10h ago\n   Main PID: 17912 (kumod)\n      Tasks: 28 (limit: 19190)\n     Memory: 257.1M\n     CGroup: /system.slice/kumomta.service\n             \u2514\u250017912 /opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --user kumod\n\nApr 27 22:59:06 kdev2.kumomta.com systemd[1]: Started KumoMTA SMTP service.\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.444479Z  INFO main kumod::memory: using limits: soft=Some(\"12.58 GB\"), hard=So&gt;\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.450824Z  INFO localset-2 kumod::http_server: http listener on 0.0.0.0:8000\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.471926Z  INFO localset-2 kumod::spool: starting enumeration for meta\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.471995Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:25\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.472008Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:2026\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.475882Z  INFO localset-2 kumod: initialization complete\n</code></pre> <p>The above is from a newer installation, but the log will grow.  If you are debugging an older install, <code>journalctl -r -n 10 -u kumomta.service</code> will show the last 10 lines (<code>-n 10</code>) in reverse order (<code>-r</code>).  <code>man journalctl</code> is your friend.</p> <p>If you need to find the installed version, you can run:</p> <pre><code>$ /opt/kumomta/sbin/kumod --version\n</code></pre> <p>This will be important if you ever need to reach out for support.</p>"},{"location":"userguide/operation/status/#monitoring","title":"Monitoring","text":"<p>If you have configured an HTTP listener, you can access server metrics in Prometheus format with:</p> <pre><code>$ curl -i 'http://localhost:8000/metrics'\n</code></pre> <p>That will show a long form of the server metrics with detailed comments.</p> <p>If you want just the data in a nice JSON format, use:</p> <pre><code>$ curl -i 'http://localhost:8000/metrics.json'\n</code></pre> <p>Metrics available include the following at the time of writing, and will increase as we build out the product:</p> <ul> <li><code>connection_count</code>: number of active connections</li> <li><code>lua_count</code>: the number of lua contexts currently alive</li> <li><code>lua_load_count</code>: how many times the policy lua script has been loaded into a new context</li> <li><code>lua_spare_count</code>: the number of lua contexts available for reuse in the pool</li> <li><code>memory_limit</code>: soft memory limit measured in bytes</li> <li><code>memory_usage</code>: number of bytes of used memory</li> </ul>"},{"location":"userguide/operation/status/#using-kcli","title":"Using kcli","text":"<p>Two handy commands are:</p> <ul> <li>kcli queue-summary to show a textual representation of queue depths</li> <li>kcli top to show a TUI charting top-line metrics</li> </ul> <p>These depend upon having the HTTP listener configured so that the metrics endpoint can be accessed.</p>"},{"location":"userguide/operation/status/#setting-up-a-grafana-dashboard","title":"Setting up a Grafana Dashboard","text":"<p>You will need to install Prometheus to act as a datasource, and install Grafana for its dashboard capabilities.</p> <p>With Prometheus installed and available, configure it to collect data from your kumod instances using a scraper configuration like this:</p> <pre><code>scrape_configs:\n  - job_name: kumomta\n    scrape_interval: 5s\n    metrics_path: /metrics\n    static_configs:\n      - targets:\n          - 'kumomta-1:8000'\n          - 'kumomta-2:8000'\n</code></pre> <p>In the above configuration <code>kumomta-1:8000</code> is the hostname (or IP address) of one of the machines running kumod, and <code>8000</code> is the HTTP listener port it has open. <code>kumomta-2:8000</code> is the <code>IP:port</code> of another instance of kumod; you can list out as many as are present in your infrastructure.</p> <p>With the Prometheus datasource in place, you can import our starter dashboard in the Grafana UI by entering its ID number <code>21391</code> or otherwise downloading the JSON from the dashboard page and then importing it into your Grafana instance directly.</p>"},{"location":"userguide/operation/troubleshooting/","title":"Troubleshooting KumoMTA","text":"<p>There are several things that can go wrong, especially when first installing KumoMTA. This page is intended to help with troubleshooting common issues.</p> <p>Note</p> <p>There are multiple ways to get help with KumoMTA, see the How To Get Help page for more information.</p>"},{"location":"userguide/operation/troubleshooting/#validate-your-configuration","title":"Validate Your Configuration","text":"<p>The first step in any troubleshooting session is to validate your current running configuration.</p> <p>For information on validating configuration see Validating Your Configuration.</p>"},{"location":"userguide/operation/troubleshooting/#using-swaks","title":"Using Swaks","text":"<p>When troubleshooting, it helps to eliminate external factors, including the injecting email infrastructure. We recommend using Swaks to perform test injections as it is known to act in an RFC compliant way when injecting messages. See the Swaks Documentation for more information.</p>"},{"location":"userguide/operation/troubleshooting/#tracing-server-communications","title":"Tracing Server Communications","text":"<p>When having issues with injecting messages, use the <code>kcli trace-smtp-server</code> command to receive an output of all communications between KumoMTA and the incoming client.</p> <pre><code>[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === Connected 2023-11-24 15:54:55.532224578 UTC\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === conn_meta received_from=\"2xx.xxx.xx.xx:40422\"\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === conn_meta received_via=\"1xx.x.xxx.xx:587\"\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === conn_meta reception_protocol=\"ESMTP\"\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]  17\u00b5s &lt;-  220 kumomta.abcdef.com KumoMTA\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 182ms  -&gt; EHLO kumomta.abcdef.com\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms === smtp_server_ehlo: Ok\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250-kumomta.abcdef.com Aloha kumomta.abcdef.com\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250-PIPELINING\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250-ENHANCEDSTATUSCODES\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250 STARTTLS\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 588ms  -&gt; STARTTLS\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 588ms &lt;-  220 Ready to Start TLS\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]    1s  -&gt; QUIT\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]    1s &lt;-  221 So long, and thanks for all the fish!\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]    1s === Closed\n</code></pre>"},{"location":"userguide/operation/troubleshooting/#obtaining-a-stack-trace","title":"Obtaining a Stack Trace","text":"<p>In some cases, the <code>kumod</code> process may hang without outputting relevant logs. When this occurs a stack trace should be obtained and provided as part of a help request:</p> <pre><code>lldb -p $(pgrep kumod) -o 'bt all' -o 'quit' &gt; /tmp/kumo-bt.txt\n</code></pre> <p>Note that lldb needs to be installed to collect the stack trace.</p> <p>When providing a stack trace you should also provide the output of <code>kumod --version</code> to help with interpreting the output.</p>"},{"location":"userguide/operation/troubleshooting/#reviewing-the-system-journal","title":"Reviewing the System Journal","text":"<p>KumoMTA logs to the system journal for all error and status messages during operation, to view the log entries use journalctl:</p> <pre><code>[root@localhost ~]# journalctl -f -n 50 -u kumomta.service\nOct 19 21:52:59 localhost systemd[1]: Started KumoMTA SMTP service.\nOct 19 21:53:00 localhost.localdomain kumod[902]: 2023-10-20T01:53:00.328546Z  INFO localset-0 kumod: NodeId is 2a32fb9b-7353-48bd-a06e-cc97e224c924\nOct 19 21:53:00 localhost.localdomain kumod[902]: 2023-10-20T01:53:00.337267Z  INFO localset-0 kumo_server_common::http_server: http listener on 127.0.0.1:8000\nOct 19 21:53:00 localhost.localdomain kumod[902]: 2023-10-20T01:53:00.348273Z  INFO localset-0 kumod::smtp_server: smtp listener on 0.0.0.0:25\nOct 19 21:53:01 localhost.localdomain kumod[902]: 2023-10-20T01:53:01.221127Z  INFO localset-0 kumod::spool: start_spool: enumeration done, spooled in 2 msgs over 117.40671ms\nOct 19 21:53:01 localhost.localdomain kumod[902]: 2023-10-20T01:53:01.221509Z  INFO localset-0 kumo_server_common::start: initialization complete\n</code></pre> <p>In this example the -f option tells journalctl to follow the log, in other words to tail or continuously read the file, the -n 50 option tells journalctl to start by reading the previous 50 lines, and the -u option tells journalctl to filter by a specific unit, in this case the kumomta.service unit.</p> <p>A common issue with new installs is ownership of the spool directory. When the spool is provisioned as a separate volume, it will not be owned by the kumod user. In this example we change ownership of the /var/spool/kumomta directory, then attempt to start the kumomta service, then read the system journal to identify the issue:</p> <pre><code>[root@localhost spool]# systemctl stop kumomta\n[root@localhost spool]# chown -R root /var/spool/kumomta/\n[root@localhost spool]# systemctl start kumomta\n[root@localhost spool]# journalctl -f -n 50 -u kumomta.service\nOct 19 22:09:06 localhost.localdomain systemd[1]: Started KumoMTA SMTP service.\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.752782Z  INFO localset-0 kumod: NodeId is 2a32fb9b-7353-48bd-a06e-cc97e224c924\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.755699Z  INFO localset-0 kumo_server_common::http_server: http listener on 127.0.0.1:8000\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.756982Z  INFO localset-0 kumod::smtp_server: smtp listener on 0.0.0.0:25\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.757415Z ERROR localset-0 kumod::spool: Error in spool: Opening spool data: opening pid file /var/spool/kumomta/data/lock: Permission denied (os error 13)\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.758039Z ERROR localset-0 kumod::spool: Error in spool: Opening spool meta: opening pid file /var/spool/kumomta/meta/lock: Permission denied (os error 13)\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.758363Z  INFO localset-0 kumod::smtp_server: smtp listener on 0.0.0.0:25 -&gt; stopping\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.758051Z  INFO       main kumo_server_common::start: Shutdown completed OK!\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.772671Z ERROR localset-0 kumo_server_common::start: problem initializing: No spools have been defined\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.772827Z  INFO localset-0 kumo_server_common::start: initialization complete\nOct 19 22:09:06 localhost.localdomain kumod[5356]: Error: Initialization raised an error\nOct 19 22:09:06 localhost.localdomain systemd[1]: kumomta.service: Main process exited, code=exited, status=1/FAILURE\nOct 19 22:09:06 localhost.localdomain systemd[1]: kumomta.service: Failed with result 'exit-code'.\nOct 19 22:09:07 localhost.localdomain systemd[1]: Failed to start KumoMTA SMTP service.\n</code></pre> <p>This error message makes it clear that there was an issue with permissions on the spool folder that prevented the kumomta service from starting.</p>"},{"location":"userguide/operation/troubleshooting/#reviewing-the-kumomta-logs","title":"Reviewing the KumoMTA Logs","text":"<p>If KumoMTA is starting but you are encountering issues when connecting with KumoMTA or how it processes your messages, refer to the KumoMTA logs.</p> <p>For information on how to read the logs, see the Viewing Logs page.</p>"},{"location":"userguide/operation/troubleshooting/#changing-the-log-level","title":"Changing the Log Level","text":"<p>Sometimes the default logging level will not expose sufficient information to troubleshoot certain issues.</p> <p>To increase the verbosity of the logs written to the system journal, use the kumo.set_diagnostic_log_filter function in your `init.lua`` policy's init event handler:</p> <pre><code>kumo.on('init', function()\n  kumo.set_diagnostic_log_filter 'kumod=debug'\nend)\n</code></pre> <p>You can adjust the log filter level dynamically using kcli set-log-filter:</p> <pre><code>$ kcli set-log-filter 'kumod=debug'\nOK\n</code></pre> <p>In addition, you can adjust the log filter level dynamically using the HTTP API:</p> <pre><code>curl -i 'http://localhost:8000/api/admin/set_diagnostic_log_filter/v1' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"filter\":\"kumod=debug\"}'\n</code></pre> <p>This will produce output similar to the following:</p> <pre><code>Oct 20 09:26:43 localhost.localdomain systemd[1]: Started KumoMTA SMTP service.\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.030934Z  INFO localset-2 kumod: NodeId is 2a32fb9b-7353-48bd-a06e-cc97e224c924\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.032892Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:25\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033051Z DEBUG localset-2 kumod::spool: Defining local disk spool 'data' on /var/spool/kumomta/data\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033179Z ERROR localset-2 kumod::spool: Error in spool: Opening spool data: opening pid file /var/spool/kumomta/data/lock: Permission denied (os error 13)\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033404Z DEBUG localset-2 kumod::spool: Defining local disk spool 'meta' on /var/spool/kumomta/meta\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033490Z ERROR localset-2 kumod::spool: Error in spool: Opening spool meta: opening pid file /var/spool/kumomta/meta/lock: Permission denied (os error 13)\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.048202Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:25 -&gt; stopping\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.050200Z DEBUG     logger kumod::logging: started logger thread\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.051984Z DEBUG     logger kumod::logging: calling state.logger_thread()\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.052337Z DEBUG     logger kumod::logging: LogFileParams: LogFileParams {\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     log_dir: \"/var/log/kumomta\",\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     max_file_size: 1000000000,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     back_pressure: 128000,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     compression_level: 0,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     max_segment_duration: None,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     meta: [],\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     headers: [],\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     per_record: {},\nOct 20 09:26:44 localhost.localdomain kumod[6061]: }\nOct 20 09:26:44 localhost.localdomain kumod[6061]: Error: Initialization raised an error\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.053482Z DEBUG     logger kumod::logging: waiting until deadline=None for a log record\nOct 20 09:26:44 localhost.localdomain systemd[1]: kumomta.service: Main process exited, code=exited, status=1/FAILURE\nOct 20 09:26:44 localhost.localdomain systemd[1]: kumomta.service: Failed with result 'exit-code'.\n</code></pre> <p>Note the additional DEBUG level log entries compared to the previous example.</p> <p>The log levels available, in order from least to most verbose are:</p> <ul> <li>Error</li> <li>Warn</li> <li>Info</li> <li>Debug</li> <li>Trace</li> </ul> <p>Warning</p> <p>The lower, more verbose levels of log levels can be very verbose, especially the  trace level. These levels should not be enabled permanently as they can lead to a full disk in a short period of time.</p>"},{"location":"userguide/operation/webhooks/","title":"Publishing Log Events Via Webhooks","text":"<p>While logs are an invaluable resource for monitoring and troubleshooting mail flows, log rotating and parsing adds complexity and latency when the goal is loading the email event data into an existing platform.</p> <p>Webhooks are ideal for near real-time integration into existing platforms, providing the ability to send message events to a user-defined HTTP endpoint, with queuing out of the box to ensure durability in the event of an error on the part of the HTTP receiving service.</p> <p>Webhooks are implemented in KumoMTA by triggering a Lua hook on log events that allows for a policy script to load the log events into their own message queue within the KumoMTA queueing structure like any other message, ensuring durability and performance for queued log events.</p> <p>Webhook events are moved through the queues like SMTP messages, and when they enter the Ready Queue they are set to deliver via an arbitrary Lua event rather than SMTP, with the Lua script configured to issue an HTTP request to the destination server.</p>"},{"location":"userguide/operation/webhooks/#using-the-log_hookslua-helper","title":"Using the log_hooks.lua Helper","text":"<p>We strongly recommend that all users make use of the <code>policy-extras.log_hooks</code> module for their web (or other protocol) hooks. The module is much more convenient to use than the underlying low level events, and handles some subtle edge cases for you.</p> <p>To implement the helper, add the following to your init.lua:</p> <pre><code>local log_hooks = require 'policy-extras.log_hooks'\n\n-- Send a JSON webhook to a local network host.\n-- See https://docs.kumomta.com/userguide/operation/webhooks/\nlog_hooks:new_json {\n  name = 'webhook',\n  url = 'http://10.0.0.1:4242/log',\n  log_parameters = {\n    headers = { 'Subject', 'X-Customer-ID' },\n  },\n}\n</code></pre> <p>Warning</p> <p>The call to <code>new_json</code> must appear before the queues helper for it to work properly. See the Example Config to see a working layout for the <code>init.lua</code> file.</p> <p>Warning</p> <p>The default traffic shaping rules that are likely present in your Shaping Helper configuration will also affect messages queued for delivery via webhooks. To avoid issues, add throttle configuration specific to your webhook queue (based on the name provided when creating a webhook):</p> <pre><code>['webhook.log_hook']\nmx_rollup = false\nconnection_limit = 100\nmax_deliveries_per_connection = 100000\nmax_connection_rate = \"1000/s\"\n</code></pre> <p>More advanced usage is possible by implementing the full call to the <code>log_hooks.lua</code> helper; the example below shows approximately how you might define your own equivalent of <code>log_hooks:new_json</code>:</p> <pre><code>local log_hooks = require 'policy-extras.log_hooks'\nlog_hooks:new {\n  name = 'webhook',\n  -- log_parameters are combined with the name and\n  -- passed through to kumo.configure_log_hook\n  log_parameters = {\n    headers = { 'Subject', 'X-Customer-ID' },\n  },\n  -- queue config are passed to kumo.make_queue_config.\n  -- You can use these to override the retry parameters\n  -- if you wish.\n  -- The defaults are shown below.\n  queue_config = {\n    retry_interval = '1m',\n    max_retry_interval = '20m',\n  },\n\n  -- The constructor is called when kumod needs to initiate\n  -- a new connection to the log target. It must return\n  -- a connection object\n  constructor = function(domain, tenant, campaign)\n    -- Define the connection object\n    local connection = {}\n\n    -- Create an HTTP client\n    local client = kumo.http.build_client {}\n\n    -- The send method is called for each log event\n    function connection:send(message)\n      local response = client\n        :post('http://10.0.0.1:4242/log')\n        :header('Content-Type', 'application/json')\n        :body(message:get_data())\n        :send()\n\n      local disposition = string.format(\n        '%d %s: %s',\n        response:status_code(),\n        response:status_reason(),\n        response:text()\n      )\n\n      if response:status_is_success() then\n        return disposition\n      end\n\n      -- Signal that the webhook request failed.\n      -- In this case the 500 status prevents us from retrying\n      -- the webhook call again, but you could be more sophisticated\n      -- and analyze the disposition to determine if retrying it\n      -- would be useful and generate a 400 status instead.\n      -- In that case, the message will be retried later, until\n      -- it reached its expiration.\n      kumo.reject(500, disposition)\n    end\n\n    -- The close method is called when the connection needs\n    -- to be closed\n    function connection:close()\n      client:close()\n    end\n\n    return connection\n  end,\n}\n</code></pre> <p>You can use the above to define logging that uses other protocols than HTTP, such as AMQP or Kafka.</p>"},{"location":"userguide/operation/webhooks/#batched-hooks","title":"batched hooks","text":"Since: Version 2024.11.08-d383b033 <p>The functionality described in this section requires version 2024.11.08-d383b033 of KumoMTA, or a more recent version.</p> <p>It can be desirable for log events to be delivered to the destination system in a batch; the primary motivation for this is to amortize the cost of a database transaction on the remote system by handling more than one record per transaction.</p> <p>You can implement batching by setting the <code>batch_size</code> parameter to a value greater than 1. When you do this, the hook is run in a batch mode and it is expected to return a <code>connection</code> object that has a <code>send_batch</code> method rather than the <code>send</code> method shown in the example above.</p> <p>When in batch mode, the connection will receive a batch consisting of 1 or more messages, up to the <code>batch_size</code> that you configured. The batch can be less than the <code>batch_size</code>; the connection will pop off up-to the configured number of messages from the ready queue. That queue holds only a finite number of messages that are immediately ready for delivery. The popping process does not artificially delay to encourage a larger batch size. It will grab whatever is immediately ready and send it as a batch.</p> <p>Here's how you would write something that is similar to the above example using batching:</p> <pre><code>local log_hooks = require 'policy-extras.log_hooks'\nlog_hooks:new {\n  name = 'webhookbatch',\n  -- batches of up to 100 messages at a time\n  batch_size = 100,\n  constructor = function(domain, tenant, campaign)\n    local connection = {}\n    local client = kumo.http.build_client {}\n\n    -- This method must be named send_batch when batch_size &gt; 1\n    function connection:send_batch(messages)\n      local payload = {}\n      for _, msg in ipairs(messages) do\n        -- Rather than collecting the pre-templated record as\n        -- a string, get it as an object.  This makes it easier\n        -- to compose it as an array and json encode than doing\n        -- the string manipulation by-hand.\n        table.insert(payload, msg:get_meta 'log_record')\n      end\n\n      -- encode the array of objects as json\n      local data = kumo.serde.json_encode(payload)\n\n      local response = client\n        :post('http://10.0.0.1:4242/log')\n        :header('Content-Type', 'application/json')\n        :body(data)\n        :send()\n\n      local disposition = string.format(\n        '%d %s: %s',\n        response:status_code(),\n        response:status_reason(),\n        response:text()\n      )\n\n      if response:status_is_success() then\n        return disposition\n      end\n      kumo.reject(500, disposition)\n    end\n\n    function connection:close()\n      client:close()\n    end\n\n    return connection\n  end,\n}\n</code></pre> <p>If your <code>send_batch</code> method returns a transient failure, either by allowing errors to escape the function without being caught by <code>pcall</code>, or by explicitly using <code>kumo.reject</code> with a <code>4xx</code> status code, then that transient disposition applies to every message in the batch. Each transiently failed message will have its own jittered retry time computed, and it will be reattempted at a later time.  This per-message jitter can help to break out of a situation where one message in the batch is somehow objectionable to the destination endpoint and continues to cause the messages that get lumped into its batch to transiently fail.</p>"},{"location":"userguide/performance/","title":"KumoMTA Performance Optimization","text":"<p>KumoMTA is designed for high-performance sending environments and is architected to allow for significant performance tuning.</p> <p>This chapter will cover the following:</p> <ul> <li>Architecture - Architecting for performance and scalability.</li> <li>Linux Tuning - Linux tuning for performance.</li> <li>DNS - The impact of DNS on MTA performance.</li> <li>Performance Testing - How to test KumoMTA for tuning and performance.</li> <li>Message Flows - Understanding message flows and resource usage in KumoMTA.</li> <li>Log Hooks - The impact of webhooks and other alternative log delivery methods.</li> </ul>"},{"location":"userguide/performance/architecture/","title":"Architecting for Performance and Scalability","text":"<p>For lower volume environments it may be practical to run your email infrastructure on a single KumoMTA instance, especially in a virtualized environment where single-node fault tolerance is relatively high.</p> <p>In high-volume environments the deployment architecture can have a significant impact on the performance and scalability of your KumoMTA installation.</p> <p>The following areas should be considered when planning a high-volume KumoMTA installation:</p>"},{"location":"userguide/performance/architecture/#cpu-architecture","title":"CPU Architecture","text":"<p>KumoMTA is available for both Intel and ARM architectures. While the individual node performance on ARM will be lower than on Intel, horizontal scaling makes it possible to achieve a better price/performance ratio.</p>"},{"location":"userguide/performance/architecture/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>While KumoMTA can be deployed on very large servers with excellent results (in excess of 20 million messages per hour on a single node), vertical scaling is not as cost effective as horizontal scaling and can result in significant capacity loss in the event of a server failure. We recommend targeting a throughput of somewhere between 4-6 million messages per hour per node in your deployment.</p>"},{"location":"userguide/performance/architecture/#dynamic-cluster-sizing","title":"Dynamic Cluster Sizing","text":"<p>In most sending environment there is a cyclical nature to sending volumes that can vary on the time of day, day of week, and even month of the year. In cyclical environment it can be very cost effective to scale the size of your cluster up and down based on these cycles, especially in public cloud environments.</p> <p>KumoMTA does not automatically perform cluster scaling as our users deploy in a wide variety of ways, but we do provide tools to help users perform the scaling using their tool of choice. See the Scaling page in the Clustering chapter of the User Guide for more information.</p>"},{"location":"userguide/performance/architecture/#hardware-planning","title":"Hardware Planning","text":"<p>When planning for hardware in a performance environment you should plan on testing multiple options where practical (such as in a public cloud environment). In our testing we have identified that a good starting point is servers with 16 cores and 32GB of RAM. Disk IOPS and throughput can be a bottleneck in some environments so it is important to calculate disk needs based on your average message size and desired throughput. Disk capacity is calculated based on average message size and expected queue depth.</p> <p>The following chart shows internal KumoMTA testing and should provide a rough estimate of hardware deployments:</p> <p></p> <p>For more information on hardware see this blog post.</p>"},{"location":"userguide/performance/architecture/#disk-performance","title":"Disk Performance","text":"<p>When planning storage, especially on physical hardware, it is important to consider the different I/O that runs in parallel on an active MTA. These I/O sets should ideally reside on separate disks:</p> <p>1) Spool - KumoMTA will be continuously reading and writing from/to the spool disk. By default KumoMTA will place its spool under <code>/var/spool/kumomta</code> and this location should be mounted to a separate disk (or at least a separate partition).</p> <p>2) Logs - KumoMTA will continuously write logs, and it should be noted that there is no log purging provided by KumoMTA. By default logs will be written under <code>/var/log/kumomta</code> which should be mounted on a separate disk (or a least a separate partition). To prevent running out of disk space you will need to implement log rotation and deletion based on your needs for data retention.</p> <p>3) Other IO - While KumoMTA will perform the majority of its I/O on the spool and log directories, a separate root partition is recommended to help isolate the general I/O from the spool and log I/O.</p>"},{"location":"userguide/performance/architecture/#network-performance","title":"Network Performance","text":"<p>An MTA cannot relay messages faster than it can move data across the network, and in extremely high-volume environments this can introduce significant network bandwidth needs.</p> <p>Modern 10Gbps networking is recommended, and WAN throughput needs should be calculated based on average message size times desired messages per hour (with generous headroom).</p> <p>Keep in mind that every message you relay consumes bandwidth twice on a given MTA: once as the message arrives and once as it is relayed out, so when considering bandwidth at the server NIC you should look at double the desired maximum message rate. In some cases it can be beneficial to separate out internal and external traffic to separate NICs where one interface is used for incoming LAN traffic from message generators and another interface is used for outbound relay to the WAN.</p>"},{"location":"userguide/performance/architecture/#separation-of-machine-roles","title":"Separation of Machine Roles","text":"<p>When planning a high-performance architecture for KumoMTA one key principle is to ensure that KumoMTA nodes are only responsible for running KumoMTA. This means that all other daemons and executables should be hosted on separate systems.</p> <p>Some of the components that should be offloaded to their own servers include:</p> <ul> <li>The TSA Daemon - While it is acceptable to operate the TSA daemon on the same node as KumoMTA in a single-node environment, separating out the TSA daemon to its own node(s) is preferred for larger deployments.</li> <li>Redis - Redis is used in multi-node environments for common throttles and counters and should not run on the same hardware as individual nodes.</li> <li>Injectors - A common architecture in many sending environments is to run message generators on the MTA nodes. This approach can lead to resource contention between the generators and the KumoMTA daemon and should be avoided.</li> <li>Log Processors - Another common architecture choice is to run log processors locally on the MTA nodes, with the processor reading the logs and pushing the data to a destination of choice. We recommend configuring KumoMTA either with log hooks to deliver data via HTTP/AMQP/Kafka, or to operate the minimum tooling necessary to move log files to a separate system for processing. Note that any log processing done locally will potentially lead to resource contention and can take disk IOPS away from the KumoMTA daemon.</li> <li>DNS - While we do recommend running a local caching Bind 9 service to ensure DNS performance, you do not need to run it on your MTA hardware. KumoMTA has its own resolver and caching in-process, DNS should be on its own server local to the KumoMTA nodes.</li> </ul>"},{"location":"userguide/performance/dns/","title":"DNS Performance","text":"<p>DNS is at the core of KumoMTA's processing pathway, it's used to validate incoming messages and their destination and to define queueing, and it's needed to successfully route messages to their MXes.</p> <p>DNS performance is critical, and if DNS performance is missing it can slow down the entire message flow.</p>"},{"location":"userguide/performance/dns/#use-a-local-cacheing-dns-resolver","title":"Use a Local Cacheing DNS Resolver","text":"<p>Due to the large volume of queries issued by KumoMTA it is strongly recommended that you use a local cacheing DNS resolver. Relying on external DNS providers introduces excess latency and potential service outages.</p> <p>On most Linux distributions the default resolver is Bind. Not all distributions maintain a current version of Bind, updating to the latest stable release is strongly recommended.</p> <p>Tuning Bind for performance is beyond the scope of this document but is recommended.</p>"},{"location":"userguide/performance/linuxtuning/","title":"Linux Tuning for Performance","text":"<p>KumoMTA performance can be optimized by fine tuning system parameters. The settings below are examples only but have helped optimize test and development servers. This example represents a starting off point, you should research these and tune as needed for your own system.</p> <p>KumoMTA makes heavy use of files, RAM, CPU and network resources. Setting these can be helpful as a default Linux install assumes the need to share resources with many applications, but we need to allow KumoMTA to use as much of the resource pool as possible.</p>"},{"location":"userguide/performance/linuxtuning/#tuning-sysctlconf","title":"Tuning sysctl.conf","text":"<p>The following tuning parameters should be reviewed to ensure they are properly tuned for your workload.</p> <p>These parameters should be added or updated in /etc/sysctl.conf:</p> <ul> <li>vm.max_map_count</li> <li>net.core.rmem_default</li> <li>net.core.wmem_default</li> <li>net.core.rmem_max</li> <li>net.core.wmem_max</li> <li>fs.file-max</li> <li>net.ipv4.ip_local_port_range</li> <li>net.ipv4.tcp_tw_reuse</li> <li>kernel.shmmax</li> <li>net.core.somaxconn</li> <li>vm.nr_hugepages</li> <li>kernel.shmmni</li> </ul> <p>This does not necessarily represent the full range of kernel tuning parameters you may need to adjust.</p> <p>KumoMTA Sponsors should consult with the KumoMTA support team for assistance with performance tuning. More information on sponsoring KumoMTA can be found here.</p>"},{"location":"userguide/performance/loghooks/","title":"The Performance Implications of Log Hooks","text":"<p>KumoMTA supports the use of webhooks for the delivery of log events, as well as routing events via AMQP and Kafka.</p> <p>It is important to understand the flow of log hooks to be able to optimize its performance.</p> <pre><code>flowchart TD\n  A[Event Occurs]\n  --&gt; C{should_enqueue_log_record}\n  C -- False --&gt; D[Discard]\n  C -- True --&gt; E[Queue Message]\n --&gt; G([get_queue_config]) --&gt; F[\"`Scheduled Queue\n _'webhook'_`\"]\n--&gt; W([make.webhook]) -- HTTP/AMQP/Kafka\n--&gt; DE{delivered?}\nDE -- No --&gt; F\nDE -- Yes --&gt; END[DONE]</code></pre> <p>The key concept in this flow is that when you enable shipping logs via HTTP/AMQP/Kafka the log events will be queued in the server queues alongside messages to be delivered.</p> <p>This means that when planning server capacity you must take into account the events that will be associated with each message and count them toward the capacity goal.</p> <p>For example: if your target is to relay 1,000,000 messages per hour through a server, and you plan on delivering log data via HTTP as webhooks, and you estimate that on average each message will have three log events (receiption, one transient failure (4xx), and one delivered or permanent failure (5XX)), then your required server throughput is actually 4,000,000 messages per hour. Inversely, if your server is designed to relay 1,000,000 messages per hour it will in fact only be able to relay 250,000 outbound messages and 750,000 log events.</p>"},{"location":"userguide/performance/loghooks/#traffic-shaping-for-log-queues","title":"Traffic Shaping For Log Queues","text":"<p>KumoMTA's default traffic shaping rules are configured to prevent reputation damage when sending by respecting the expectation of MailBox Providers(MBPs).</p> <p>While those defaults can help prevent throttling, they are overly restrictive when sending messages to internal HTTP/AMQP/Kafka endpoints, and can result is queue backpressure.</p> <p>To prevent queue buildup, your traffic shaping configuration should explicitly define shaping rules for your webhook queue.</p> <p>Consider the following log hook configuration:</p> <pre><code>local log_hooks = require 'policy-extras.log_hooks'\n\n-- Send a JSON webhook to a local network host.\n-- See https://docs.kumomta.com/userguide/operation/webhooks/\nlog_hooks:new_json {\n  name = 'webhook',\n  url = 'http://10.0.0.1:4242/log',\n  log_parameters = {\n    meta = { 'From', 'Subject', 'x-virtual-mta', 'x-dkim-options' },\n  },\n}\n</code></pre> <p>Note</p> <p>In the preceding example we use the <code>meta</code> option instead of the <code>headers</code> option because logging headers requires the message body to be processed during logging. This can be combined with the msg:import_x_headers function to push the relevant headers into the message metadata for efficient logging.</p> <p>Given the log hook name of <code>webhook</code> the following should be added to the shaping helper TOML configuration file:</p> <pre><code>['webhook.log_hook']\n# This is not a regular email domain, so do not try to resolve it as an MX record\nmx_rollup = false\nmax_deliveries_per_connection = 8192\n# No need to coordinate with other MTAs on a shared limit\nconnection_limit = \"local:10\"\nmax_connection_rate = \"1000/s\"\n# Allow a healthy amount in the ready queue in case things get busy\nmax_ready = 10000\n# Limit how long we wait for connections to close at shutdown so we don't delay unneccessarily\nsystem_shutdown_timeout = \"30s\"\n</code></pre> <p>While these settings can be adjusted to best fit your use cases, the example above will be a good starting point.</p>"},{"location":"userguide/performance/loghooks/#batching-webhooks","title":"Batching Webhooks","text":"<p>By default KumoMTA will deliver log messages to a webhook endpoint one entry at a time.</p> <p>In some implementations a webhook consumer may be more efficient when receiving batching of webhook events instead of individual events (one example is webhook consumers that simply write data to storage without processing). </p> <p>To activate batch sending, see the log hooks helper page of the Operation chapter.</p>"},{"location":"userguide/performance/messageflow/","title":"Understanding Message Flows","text":"<p>Most KumoMTA performance tuning is going to involve tuning the flow of messages through KumoMTA and how each stage of the flow can affect performance. This involves understanding both how the queues work as well as the various processing that occurs.</p>"},{"location":"userguide/performance/messageflow/#queue-flow","title":"Queue Flow","text":"<p>First let's review how messages flow through the queues in KumoMTA. This is covered in more detail in the Queues chapter of the reference manual but will be summarized here.</p> <pre><code>graph TD\n   SQ[\"Scheduled Queue: campaign:tenant@domain.com\"]\n   SMTPL[\"ESMTP Listener\"]\n   HTTPI[\"Injection API\"]\n   RQ1[\"Ready Queue: 10.0.0.1-&gt;MX(domain.com)\"]\n   RQ2[\"Ready Queue: 10.0.0.2-&gt;MX(domain.com)\"]\n   POOL[\"egress pool\"]\n   IP1[\"Source: 10.0.0.1\"]\n   IP2[\"Source: 10.0.0.2\"]\n   MAINT[\"Queue Maintainer\"]\n   DESTSITE[\"domain.com\"]\n\n   SMTPL --&gt; SQ\n   HTTPI --&gt; SQ\n   SQ --&gt; MAINT\n   IP1 --&gt; POOL\n   IP2 --&gt; POOL\n   POOL -- per tenant:domain config --&gt; MAINT\n   MAINT -- throttle per tenant:domain config --&gt; RQ1\n   MAINT -- throttle per tenant:domain config --&gt; RQ2\n   RQ1 -- throttle per source:domain config\\nconnect via 10.0.0.1 --&gt; DESTSITE\n   RQ2 -- throttle per source:domain config\\nconnect via 10.0.0.2 --&gt; DESTSITE</code></pre> <p>1) A message is injected into the KumoMTA server. Either the <code>smtp_server_message_received</code> or <code>http_message_generated</code> event will fire and code attached to the corresponding hook will be executed. </p> <ul> <li> <p>The most common action executed at this stage is DKIM signing, performed either through the <code>dkim_sign.lua</code> helper or by calling <code>msg:dkim_sign()</code> in lua.</p> </li> <li> <p>Those using the queues helper will call <code>queue_helper:apply()</code> at this point.</p> </li> <li> <p>A log entry will be generated for the message reception event. </p> </li> </ul> <p>Note</p> <p>If you have configured log hooks or routing logs via AMQP or Kafka then a message will be queued for each log entry that needs to be routed. This means that each message injected will result in multiple messages in the queues (at least one message for the Received log entry and one for the Delivered log entry).</p> <p>2) The message is assigned into a Scheduled Queue based on the combination of its campaign, tenant, and destination domain. If there is no defined campaign or tenant, the message is placed in a queue based on the elements that are present.</p> <ul> <li>At this point there will potentially be thousands of scheduled queues depending on the number of tenants, campaigns, and destination domains involved. Note that egress_source, site_name, and provider are not factored into this queue architecture.</li> </ul> <p>3) The KumoMTA server moves the message from the Scheduled Queue into the Ready Queue based on retry intervals configured for the Standby Queue. The Ready Queue will be defined as a combination of the Egress_Source to be used for the message and the Site_Name the destination domain belongs to. If a message is on its first attempt, it will be moved to the Ready Queue immediately.</p> <ul> <li> <p>As part of this process the appropriate ready queue will be compared to the corresponding max_ready setting to ensure there is room for the message. If there is not the message will be delayed by a random amount, returned to the Scheduled queue, and a <code>Delayed</code> log entry will be generated (potentially with a corresponding queued message to route the log entry over Webhook/AMQP/Kafka).</p> </li> <li> <p>Traffic shaping and other similar options are configured based on this combination, see the Configuring Traffic Shaping chapter for more information.</p> </li> <li> <p>The egress source is a configured structure that defines the name, source IP, and ehlo domain of a given pathway, and it is added to an egress pool, which the message is assigned to as part of the queue config. Note: While routing is assigned at the egress pool level, traffic shaping happens at the egress source level.</p> </li> <li> <p>The site name is an identifier string created by merging the combined MX hostnames for a given destination domain. This approach allows the server to queue and throttle based not on the destination domain for a given message, but on the aggregate of all domains that share the same set of MXes.</p> </li> </ul> <p>5) All delivery attempts are logged, and any messages that receive a 4xx tempfail response from the remote host are returned to the Scheduled Queue to await a retry attempt. See the Configuring Logging chapter for more information on logging.</p>"},{"location":"userguide/performance/testing/","title":"Performance Testing","text":"<p>Performance testing must not be performed against the public internet, as large volumes of test message can be catastrophic for sending reputation. This isn't to say that one-off test messages will be a problem, but that sending in bulk can cause serious issues.</p> <p>When testing you should send against a mail sink server, but your choice of sink can significantly impact your testing results. It is very common to install something link smtp_sink from Postfix for testing, but many message sinks simply accept all messages and discard them. This results in zero backpressure or queue buildup on the MTA, which can lead to inaccurate results.</p>"},{"location":"userguide/performance/testing/#using-kumomtas-smart-sink-docker-container","title":"Using KumoMTA's Smart Sink Docker Container","text":"<p>To ensure that your testing reflects the real world as much as possible, we recommend you use the Smart Sink Docker container found at https://github.com/KumoCorp/kumomta/tree/main/examples/smart-sink-docker for testing. The Smart Sink policy will accept most mail and discard them, but it will respond to a configurable percentage of traffic with temporary and permanent failure messages that are appropriate for the destination domain of the message (for example, a message sent to yahoo.com that is flagged for a temporary failure will result in a temporary failure message used in production by Yahoo).</p> <p>The Smart Sink can also recognize when the user portion of the email is <code>tempfail@</code> or <code>permfail@</code> and respond with a corresponding temporary or permanent failure message for the domain in the recipient address.</p> <p>The setting for bounce and tempfail percentages, as well as potential responses, can be found at https://github.com/KumoCorp/kumomta/blob/main/examples/smart-sink-docker/policy/responses.toml.</p> <p>For instructions on deploying the Smart Sink Docker container, see https://github.com/KumoCorp/kumomta/tree/main/examples/smart-sink-docker.</p>"},{"location":"userguide/performance/testing/#generating-traffic","title":"Generating Traffic","text":"<p>We strongly recommend deploying a QA version of your production traffic generating system for testing and loading it with data that closely mimics production data (ideally obfuscated production data). When performance testing the goal is to duplicate a production environment and workload as closely as possible, so you will want to generate the same volume of mail for the same variety of destination domains across the same number of IPs when possible to ensure that your test environment behaves as closely to your production environment as possible.</p> <p>This is important because KumoMTA works in a highly parallel fashion, with very granular queues created for the various combinations of campaign, tenant, destination domain, egress_source, and site_name required by your outgoing traffic, and if you send your tests from a single tenant or to a single destination you will not be able to tune your environment for production traffic because you will have a small handful of queues instead of thousands of queues and the server behavior will be very different.</p> <p>When you need to focus on a subset of your delivery pipeline, you can add custom headers to the generated messages via the <code>--header</code> option. Repeating the flag allows you to add multiple headers (for example, to mark a specific tenant or campaign) and observe how queue selection, shaping, and any additional custom header manipulation affect performance or latency during your tests</p>"},{"location":"userguide/performance/testing/#generating-traffic-using-traffic-gen","title":"Generating Traffic Using <code>traffic-gen</code>","text":"<p>For cases where accurate simulation is not feasible, KumoMTA includes a \"Traffic Generator\" that can be use to send volume test mail for this purpose. The <code>traffic-gen</code> appends a known domain to all outbound mail that resolves to your own loopback address so that mail can be delivered, but will never deliver to real addresses:</p> <pre><code>$ /opt/kumomta/sbin/traffic-gen --target &lt;your.sink.server&gt;:25 --concurrency 20000 --message-count 100000 --body-size 100000\n</code></pre> <p>For additional parameters for the <code>traffic-gen</code> utility see:</p> <pre><code>$ /opt/kumomta/sbin/traffic-gen --help\n</code></pre> <p>The <code>traffic-gen</code> script is used internally by the KumoMTA team to test performance before each release.</p> <p>A more advanced example is as follows:</p> <pre><code>$ cat traffic-gen.sh\n#!/bin/bash\n\nexec traffic-gen \\\n        --target localhost:2025 \\\n        --keep-going \\\n        --concurrency 400 \\\n        --body-size 60kb \\\n        --duration 1500 \\\n        --domain-suffix 'testingdomain.tld' \\\n        --domain aol.com:1.5 \\\n        --domain bellsouth.net:0.2 \\\n        --domain comcast.net:0.5 \\\n        --domain gmail.com:67.4 \\\n        --domain hotmail.com:8.8 \\\n        --domain icloud.com:1.2 \\\n        --domain live.com:0.3 \\\n        --domain me.com:0.2 \\\n        --domain msn.com:0.5 \\\n        --domain orange.fr:0.4 \\\n        --domain outlook.com:1.2 \\\n        --domain sbcglobal.net:0.3 \\\n        --domain yahoo.com:5.9 \\\n        $@\n</code></pre> <p>The preceding example uses the domain argument to list the destination domains that should be generated and their relative weights.</p> <p>When performing raw throughput testing, it can be helpful to use custom routing to configure the test server to route all messages to the sink server, with the sink configured to dev/null all messages. Modify the <code>init.lua</code> on the test server with the following:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  msg:set_meta('queue', 'my.sink.server')\nend)\n</code></pre> <p>However, when using the above smart hosting/routing technique you must be aware that it causes the outgoing traffic to fan in to a smaller-than-real-world set of egress sources.  It is suitable for measuring the maximum throughput possible, but will not reflect the system behavior in terms of managing queues and respecting your shaping settings for the various destination sites.</p> <p>For a truer representation of the overall system behavior we recommend using your firewall to redirect traffic to the sink in a transparent manner.  You can use the <code>iptables</code> command for this purpose:</p> <pre><code>$ iptables -t nat -A OUTPUT -p tcp \\! -d 192.168.1.0/24 \\\n  --dport 25 -j DNAT --to-destination 127.0.0.1:2026\n</code></pre> <p>In the preceding example all traffic, other than LAN traffic on 192.168.1.0/24, destined for port 25 is instead routed to localhost on port 2026.</p> <p>Note</p> <p>You will need to disable MTA-STS and DANE when using this sort of redirection, otherwise you will experience TLS failures for sites that publish MTA-STS and/or DANE policies.</p> <p>When using <code>iptables</code> correctly and safely, and you're sure that you cannot be leaking test SMTP traffic to the public internet, you can then change your <code>traffic-gen</code> command/script to remove the domain suffix:</p> <pre><code>  --domain-suffix '' \\\n</code></pre> <p>which will then cause the real-world DNS records to be resolved and further increase the realism of your testing environment.</p>"},{"location":"userguide/performance/testing/#sample-test-results","title":"Sample Test Results","text":"<p>The hardware configuration used in this example is one \"sending\" configured KumoMTA instance hosted on AWS (variable CPU and RAM) and one \"sink\" KumoMTA instance hosted on Azure (8 CPU/16GB RAM) using a payload of 100KB messages sent in a loop 100,000 times.</p> <p>The test utilized the included traffic-gen utility as described above.</p> CPU RAM RATE 2 4 2.7 MMH 4 16 4.4 MMH 8 30 4.9 MMH 16 64 5.1 MMH <p>NOTE that these numbers are NOT guaranteed and are for informational purposes only. Your results may vary considerably.</p> <p>In July 2023 another round of testing was done with more detailed results.  those results are shown in the table below and were documented in the blog post How we built the most performant Message Transfer Agent on the planet:</p> <p></p>"},{"location":"userguide/policy/","title":"Policy","text":"<p>While the entirety of configuring a KumoMTA instance is done with policy, this chapter is focused specifically on what could be considered advanced use cases involving Lua policy scripts.</p> <p>The examples in this chapter are for advanced users.</p>"},{"location":"userguide/policy/amqp/","title":"Routing Messages via AMQP","text":"<p>In addition to local logging and Webhooks, KumoMTA can relay log events (or other queued messages) via AMQP.</p> <p>KumoMTA supports publishing via AMQP, using Lua.</p> <p>The process to queue log events and make them available for sending via <code>custom_lua</code> as a protocol is covered in the Publishing Log Events Via Webhooks section of the Operations chapter of the User Guide.</p>"},{"location":"userguide/policy/amqp/#configuring-a-queue-handler-for-amqp","title":"Configuring A Queue Handler for AMQP","text":"<p>When a message is ready to be queued, the <code>get_queue_config</code> event is fired, at which point we can specify the protocol of the queue, in this case <code>custom_lua</code>. In the example below, we check whether the message is queued to the <code>amqp</code> queue and act accordingly:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'amqp' then\n    -- Use the `make.webhook` event to handle delivery\n    -- of webhook log records\n    return kumo.make_queue_config {\n      protocol = {\n        custom_lua = {\n          -- this will cause an event called `make.webhook` to trigger.\n          -- You can pick any name for this event, so long as it doesn't\n          -- collide with a pre-defined event, and so long as you bind\n          -- to it with a kumo.on call\n          constructor = 'make.amqp',\n        },\n      },\n    }\n  end\n  return kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"userguide/policy/amqp/#sending-messages-via-amqp","title":"Sending Messages via AMQP","text":"<p>With the custom_lua protocol defined and a custom event trigger declared, the next step is to catch the <code>make.amqp</code> event with code that sends the message contents over HTTP.</p> <p>The following example sends the content of the log message via AMQP:</p> <pre><code>-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- It returns a lua connection object that can be used to \"send\"\n-- messages to their destination.\nkumo.on('make.amqp', function(domain, tenant, campaign)\n  local sender = {}\n  function sender:send(message)\n    kumo.amqp.basic_publish {\n      routing_key = 'logging',\n      payload = message:get_data(),\n      connection = {\n        host = 'localhost',\n      },\n    }\n    return '250 ok'\n  end\n\n  function sender:close() end\n\n  return sender\nend)\n</code></pre> <p>See the AMQP section of the Reference Manual for more information.</p>"},{"location":"userguide/policy/hashicorp_vault/","title":"Using HashiCorp Vault","text":""},{"location":"userguide/policy/hashicorp_vault/#introduction","title":"Introduction","text":"<p>HashCorp Vault is a secure storage tool for maintaining a centralized and secure store of passwords, certificates and other secrets. Vault is only one of the ways you can store secrets outside of your running code, but it is very popular and KumoMTA has native integration.</p> <p>Vault helps you keep password and other secrets separated from running code to help reduce the possibility of security leaks such as accidentally saving your API key in a GitHub repo.</p>"},{"location":"userguide/policy/hashicorp_vault/#configuring-kumomta-to-use-hashicorp-vault","title":"Configuring KumoMTA to use Hashicorp Vault","text":"<p>The documentation in the reference manual is straightforward, but does have some nuance.</p> <p>In the example shown there and below, we are storing the DKIM signing key as a file in vault so it can be called dynamically, but including the vault token in the script is not a particularly secure way of doing things. It is recommended to place the vault address and token in environment variables that are accessible to KumoMTA. In most cases, that will mean modifying the systemd unit service file.</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'dkim/' .. msg:from_header().domain,\n    -- Optional: specify a custom key name (defaults to \"key\")\n    -- vault_key = \"private_key\"\n    -- vault_address = \"http://127.0.0.1:8200\"\n    -- vault_token = \"hvs.TOKENTOKENTOKEN\"\n  },\n}\n</code></pre> <p>To modify the systemd service file, use the built in edit command in systemctl. The man page is here, but Digital Ocean has an excellent tutorial that explains it in plain english.</p> <p>The short version is that you can use <code>systemctl edit</code> to edit the file and add \"Environment\" values under the <code>[Service]</code> section so that those values will be available when the system service daemon starts KumoMTA. The example below modified the FULL service config. The <code>--full</code> option can be removed to modify a snippet instead of the full config.</p> <pre><code>sudo systemctl edit --full kumomta.service\n</code></pre> <p>You should disregard everything except the <code>[Service]</code> section. At the bottom of that section, add 2 lines:</p> <pre><code>Environment=VAULT_ADDR='http://&lt;YOUR_SERVER_LOCATION&gt;:8200'\nEnvironment=VAULT_TOKEN='&lt;YOUR_ACCESS_TOKEN&gt;'\n</code></pre> <p>When done, it should look something like this:</p> <pre><code>[Unit]\nDescription=KumoMTA SMTP service\nAfter=syslog.target network.target\nConflicts=sendmail.service exim.service postfix.service\n\n[Service]\nType=simple\nRestart=always\nExecStart=/opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --user kumod\n# Allow sufficient time to wrap up in-flight tasks and safely\n# write out pending data\nTimeoutStopSec=300\nEnvironment=VAULT_ADDR='http://127.0.0.1:8200'\nEnvironment=VAULT_TOKEN='SAMPLE-TOKEN'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Save the file, then reload with the <code>sudo systemctl daemon-reload</code> command.</p>"},{"location":"userguide/policy/hashicorp_vault/#storing-secrets-for-later-use","title":"Storing secrets for later use","text":"<p>There are a number of ways to store secrets, and the method depends on how the vault was created. If configured via the Vault CLI, then a V2 password can be stored as follows:</p> <pre><code>vault kv put -mount=secret dkim/example.org key=@example-private-dkim-key.pem\n</code></pre> <p>It is important to ensure you are storing Version-2 secrets with a \"key=\" format. In the preceding example, the <code>key</code> points to a filename <code>example-private-dkim-key.pem</code>."},{"location":"userguide/policy/hashicorp_vault/#using-custom-key-names","title":"Using Custom Key Names","text":"Since: Version 2025.10.06-5ec871ab <p>The functionality described in this section requires version 2025.10.06-5ec871ab of KumoMTA, or a more recent version.</p> <p>By default, KumoMTA looks for a field named <code>key</code> in your vault secret. If you want to use a different field name, you can specify it with the <code>vault_key</code> parameter:</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'dkim/' .. msg:from_header().domain,\n    vault_key = 'private_key', -- Look for 'private_key' instead of 'key'\n  },\n}\n</code></pre> <p>And store it in vault like this:</p> <pre><code>vault kv put -mount=secret dkim/example.org private_key=@example-private-dkim-key.pem\n</code></pre> <p>This is particularly useful when you have multiple keys stored in the same vault secret or when your vault secrets follow a different naming convention.</p>"},{"location":"userguide/policy/hashicorp_vault/#ways-to-use-vault-with-kumomta","title":"Ways to Use Vault With KumoMTA","text":"<p>Vault has a number of advantages over statically storing secrets. Aside from the obvious security benefits of not exposing your passwords and security keys in your code, it also allows you to physically separate the information. One key use case is storing the vault server in a private network while the KumoMTA instances are deployed around the world or in public colocation or cloud services. If a remote server is compromised, the local vault server can be secured to prevent data leakage.</p> <p>Another advantage is being able to dynamically load keys on demand. This can be very helpful with DKIM key rotation. With the keys stored within the vault, they can be loaded as-needed when messages pass through the server that need a particular key:</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\n  key = {\n    vault_mount = 'secret',\n    vault_path = 'dkim/' .. msg:from_header().domain,\n  },\n}\n</code></pre>"},{"location":"userguide/policy/http/","title":"Routing Messages via HTTP Request","text":"<p>Some sending environments use a mixture of different services to send messages, and while it's possible to relay messages through many services using SMTP, some services are only/better served via an HTTP API.</p> <p>The following example shows how to send a queued message via custom lua, in this case assembling an API call and sending it to a third-party SMTP API relay provider.</p> <p>Warning</p> <p>Storing credentials as hardcoded values in a policy script such as this is not recommended, instead, use the built-in Secrets Load function. See https://docs.kumomta.com/reference/kumo.secrets/load/.</p> <pre><code>kumo.on('make.mailgun', function(domain, tenant, campaign)\n  local client = kumo.http.build_client {}\n  local sender = {}\n\n  function sender:send(message)\n    local request =\n      client:post 'https://api.mailgun.net/v3/YOUR_DOMAIN_NAME/messages.mime'\n\n    request:basic_auth('api', 'YOUR_API_KEY')\n    request:form_multipart_data {\n      to = message:recipient().email,\n      message = {\n        data = message:get_data(),\n        file_name = 'mime.msg',\n      },\n    }\n\n    -- Make the request\n    local response = request:send()\n\n    -- and handle the result\n    local disposition = string.format(\n      '%d %s %s',\n      response:status_code(),\n      response:status_reason(),\n      response:text()\n    )\n    if response:status_is_success() then\n      -- Success!\n      return disposition\n    end\n\n    -- Failed!\n    kumo.reject(400, disposition)\n  end\n  return sender\nend)\n\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if tenant == 'mailgun-user' then\n    return kumo.make_queue_config {\n      protocol = {\n        custom_lua = {\n          constructor = 'make.mailgun',\n        },\n      },\n    }\n  end\n\n  return kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"userguide/policy/inbound_auth/","title":"Checking Inbound SMTP Authentication","text":"<p>When hosting relay users it is important to protect your infrastructure from malicious senders, often without the ability to whitelist the IP addresses of legitimate users. In such environments, it is critical to setup SMTP Authentication to validate injecting hosts before relaying their mail.</p> <p>Note</p> <p>Authentication in KumoMTA can only occur on a TLS protected connection after <code>STARTTLS</code> has successfully been processed. This is because AUTH PLAIN credentials can be decoded and should not be sent over an open connection.</p>"},{"location":"userguide/policy/inbound_auth/#checking-authentication-against-a-static-user-table","title":"Checking Authentication Against a Static User Table","text":"<p>The simplest implementation of AUTH checking could be implemented by checking against a static value or table:</p> <pre><code>-- Use this to lookup and confirm a user/password credential\nkumo.on('smtp_server_auth_plain', function(authz, authc, password, conn_meta)\n  local password_database = {\n    ['daniel'] = 'tiger',\n  }\n  if password == '' then\n    return false\n  end\n  return password_database[authc] == password\nend)\n</code></pre> <p>The preceding example, also seen on the smtp_server_auth_plain page of the Reference Manual, simply checks against a table of usernames and passwords, looking for a match. If the password is blank the function returns false, otherwise the function returns true if the password in the table for the named user matches the password provided in the AUTH request.</p>"},{"location":"userguide/policy/inbound_auth/#querying-a-datasource-for-authentication","title":"Querying a Datasource for Authentication","text":"<p>A common use case for relay hosts is validating AUTH credentials against a datasource for more dynamic management of sending users.</p> <p>In the following example, the provided credentials are checked against a SQLite database:</p> <pre><code>local sqlite = require 'sqlite'\n\n-- Consult a hypothetical sqlite database that has an auth table\n-- with user and pass fields\nfunction sqlite_auth_check(user, password)\n  local db = sqlite.open '/path/to/auth.db'\n  local result = db:execute(\n    'select user from auth where user=? and pass=?',\n    user,\n    password\n  )\n  -- if we return the username, it is because the password matched\n  return result[1] == user\nend\n\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\n  return sqlite_auth_check(authc, password)\nend)\n</code></pre> <p>Warning</p> <p>To prevent blocking when checking data like AUTH credentials we recommend using the Memoize function to cache query results for future connections.</p>"},{"location":"userguide/policy/inbound_auth/#querying-a-keystore-for-authentication","title":"Querying a Keystore for Authentication","text":"<p>A more secure option for storing authentication credentials for checking is Hashicorp Vault. See the Storing Secrets in Hashicorp Vault page for more information on how to populate the credentials in the Vault as well as how to secure the connection credentials.</p> <pre><code>function vault_auth_check(user, password)\n  return password\n    == kumo.secrets.load {\n      vault_mount = 'secret',\n      vault_path = 'smtp-auth/' .. user,\n      -- Optional: specify a custom key name (defaults to \"key\")\n      -- vault_key = \"password\"\n    }\nend\n\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\n  return vault_auth_check(authc, password)\nend)\n</code></pre>"},{"location":"userguide/policy/inbound_auth/#enhancing-tenant-security-through-smtp-authentication","title":"Enhancing Tenant Security Through SMTP Authentication","text":"<p>When using SMTP authentication a certain amount of trust is put in the injecting client, and there are ways this can be abused.</p> <p>One example of this is using headers for identifying which tenant a message is associated with when using the Queues Helper to manage queues; you can designate a custom header that contains the tenant name, trusting the user to provide their own tenant name, but if a malicious user discovers the tenant name of another user on the server, they can spoof the other tenant.</p> <p>To prevent this, you can use the <code>require_authz</code> option in the helper:</p> TOMLJSON <pre><code>[tenant.'mytenant']\n# Which pool should be used for this tenant\negress_pool = 'pool-1'\n\n# Only the authorized identities are allowed to use this tenant via the tenant_header\nrequire_authz = [\"daniel\"]\n</code></pre> <pre><code>{\n  \"tenant\": {\n    \"mytenant\": {\n      // Which pool should be used for this tenant\n      \"egress_pool\": \"pool-1\",\n      // Only the authorized identities are allowed to use this tenant via the tenant_header\n      \"require_authz\": [\n        \"daniel\"\n      ]\n    }\n  }\n}\n</code></pre> <p>This prevents users other than daniel (multiple users can be specified) from using the tenant for sending.</p>"},{"location":"userguide/policy/kafka/","title":"Routing Messages via Kafka","text":"Since: Version 2023.12.28-63cde9c7 <p>The functionality described in this section requires version 2023.12.28-63cde9c7 of KumoMTA, or a more recent version.</p> <p>In addition to local logging and Webhooks, KumoMTA can relay log events (or other queued messages) via Apache Kafka.</p> <p>KumoMTA supports publishing via Kafka, using Lua.</p> <p>The process to queue log events and make them available for sending via <code>custom_lua</code> as a protocol is covered in the Publishing Log Events Via Webhooks section of the Operations chapter of the User Guide.</p>"},{"location":"userguide/policy/kafka/#configuring-a-queue-handler-for-kafka","title":"Configuring A Queue Handler for Kafka","text":"<p>When a message is ready to be queued, the <code>get_queue_config</code> event is fired, at which point we can specify the protocol of the queue, in this case, <code>custom_lua</code>. In the example below, we check whether the message is queued to the <code>kafka</code> queue and acts accordingly:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'kafka' then\n    -- Use the `make.webhook` event to handle delivery\n    -- of webhook log records\n    return kumo.make_queue_config {\n      protocol = {\n        custom_lua = {\n          -- this will cause an event called `make.webhook` to trigger.\n          -- You can pick any name for this event, so long as it doesn't\n          -- collide with a pre-defined event, and so long as you bind\n          -- to it with a kumo.on call\n          constructor = 'make.kafka',\n        },\n      },\n    }\n  end\n  return kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"userguide/policy/kafka/#sending-messages-via-kafka","title":"Sending Messages via Kafka","text":"<p>With the custom_lua protocol defined and a custom event trigger declared, the next step is to catch the <code>make.kafka</code> event with code that sends the message contents over HTTP.</p> <p>The following example sends the content of the log message via Kafka:</p> <pre><code>-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- It returns a lua connection object that can be used to \"send\"\n-- messages to their destination.\nkumo.on('make.kafka', function(domain, tenant, campaign)\n  local producer = kumo.kafka.build_producer {\n    ['bootstrap.servers'] = 'localhost:9092',\n  }\n\n  producer:send {\n    topic = 'my.topic',\n    payload = message:get_data(),\n    -- how long to keep trying to submit to kafka\n    -- before a lua error will be raised.\n    -- This is the default.\n    timeout = '1 minute',\n  }\nend)\n</code></pre> <p>See the Kafka section of the Reference Manual for more information.</p>"},{"location":"userguide/policy/nats/","title":"Routing Messages via NATS","text":"Since: Dev Builds Only <p>The functionality described in this section requires a dev build of KumoMTA. You can obtain a dev build by following the instructions in the Installation section.</p> <p>In addition to local logging and Webhooks, KumoMTA can relay log events (or other queued messages) via NATS JetStream.</p> <p>KumoMTA supports publishing via NATS, using Lua.</p> <p>The process to queue log events and make them available for sending via <code>custom_lua</code> as a protocol is covered in the Publishing Log Events Via Webhooks section of the Operations chapter of the User Guide.</p>"},{"location":"userguide/policy/nats/#configuring-a-queue-handler-for-nats","title":"Configuring A Queue Handler for NATS","text":"<p>When a message is ready to be queued, the <code>get_queue_config</code> event is fired, at which point we can specify the protocol of the queue, in this case, <code>custom_lua</code>. In the example below, we check whether the message is queued to the <code>nats</code> queue and acts accordingly:</p> <pre><code>kumo.on('init', function()\n  nats = kumo.nats.connect {\n    servers = { '127.0.0.1:4222' },\n  }\nend)\n\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n  if domain == 'nats' then\n    -- Use the `make.nats` event to handle delivery\n    -- of nats log records\n    return kumo.make_queue_config {\n      protocol = {\n        custom_lua = {\n          -- this will cause an event called `make.nats` to trigger.\n          -- You can pick any name for this event, so long as it doesn't\n          -- collide with a pre-defined event, and so long as you bind\n          -- to it with a kumo.on call\n          constructor = 'make.nats',\n        },\n      },\n    }\n  end\n  return kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"userguide/policy/nats/#sending-messages-via-nats","title":"Sending Messages via NATS","text":"<p>With the <code>custom_lua</code> protocol defined and a custom event trigger declared, the next step is to catch the <code>make.nats</code> event with code that sends the message contents over HTTP.</p> <p>The following example publishes the content of the log message via NATS:</p> <pre><code>-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- The connection must be established before in order to \"publish\"\n-- messages to their destination.\nkumo.on('make.nats', function(domain, tenant, campaign)\n  nats:publish {\n    subject = 'subject',\n    payload = message:get_data(),\n  }\nend)\n</code></pre> <p>See the NATS section of the Reference Manual for more information.</p>"},{"location":"userguide/policy/rewrite/","title":"Rewriting Remote Server Responses","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>One common use case for senders is the need to rewrite/transpose certain remote server responses before processing them as bounces. For example, a sender may receive a temporary failure message indicating that a mailbox is full, but wants to treat the response as a permanent failure because they don't expect the full mailbox to be resolved within the message's retry window and don't want the message increasing the size of the queue.</p> <p>In order to rewrite remote server responses, use the smtp_client_rewrite_delivery_status event.</p> <p>The following example is from the smtp_client_rewrite_delivery_status page in the Reference Manual:</p> <pre><code>{\n  \"4\\\\.2\\\\.1 &lt;.+&gt;: Recipient address rejected: this mailbox is inactive and has been disabled\": 500,\n  \"4\\\\.2\\\\.2 The email account that you tried to reach is over quota\\\\.\": 500\n}\n</code></pre> <pre><code>-- Compile a classifier from the json file; refresh it it every 5 minutes\nlocal get_dsn_classifier = kumo.memoize(function()\n  local data = kumo.json_load '/tmp/dsn_rewrite.json'\n  return kumo.regex_set_map.new(data)\nend, {\n  name = 'dsn_rewrite',\n  ttl = '5 minutes',\n  capacity = 1,\n})\n\n-- This example ignores the queue name parameters, but you could get more\n-- sophisticated and use those to define rules on a per-domain/tenant/campaign basis\n-- if required\nkumo.on(\n  'smtp_client_rewrite_delivery_status',\n  function(response, domain, tenant, campaign, routing_domain)\n    local map = get_dsn_classifier()\n    -- Match the classifier against the response.\n    -- This will return the rewritten code if any, or null otherwise.\n    -- We can simply return the result of the lookup directly.\n    return map[response]\n  end\n)\n</code></pre> <p>Note that the message specified will have <code>(kumomta: status was rewritten from 400 -&gt; 500)</code> appended to it when logged to make it clear that a rewrite has ocurred.</p>"},{"location":"userguide/policy/routing/","title":"Configuring Message Routing","text":"<p>If you need to \"smarthost\" or route messages through another server, you have several options.</p>"},{"location":"userguide/policy/routing/#changing-the-routing-domain-at-reception-time-per-message","title":"Changing the routing domain at reception time (per-message)","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>At reception time, you can specify an alternate routing domain for a message.  Messages with the same destination domain (based on their recipients) and routing domain will be queued into a separate scheduled queue from their normal destination domain.</p> <p>This is conceptually similar to the <code>queue</code> rewriting approach mentioned below, but the original destination domain, tenant and campaign information is preserved, and multiple separate scheduled queues are created to manage them.</p> <p>The example below will unconditionally smarthost all incoming messages to <code>my.smarthost.com</code>.  Mail originally destined for <code>example.com</code> will be queued into a scheduled queue named <code>example.com!my.smarthost.com</code> so that it can be managed independently of other domains.</p> <p>When delivering these messages, the regular MX resolution process will be performed but using <code>my.smarthost.com</code> instead of the recipient domain.</p> <p>This must be carried out in your smtp_server_message_received or http_message_generated event handler.</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n    msg:set_meta('routing_domain', 'my.smarthost.com')\nend)\n</code></pre>"},{"location":"userguide/policy/routing/#explicitly-overriding-the-mx-resolution-for-a-scheduled-queue-domain-based","title":"Explicitly overriding the MX resolution for a scheduled queue (domain-based)","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>If you are re-routing a domain to internal infrastructure that doesn't have MX records, then this technique may be suitable.  It works by overriding the MX resolution that would normally be used for a scheduled queue.</p> <p>The override is performed by setting the configuration for the scheduled queue using the get_queue_config event:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n    if domain == 'domain.to.be.smart.hosted' then\n        -- Relay via some other internal infrastructure.\n        -- Enclose IP (or IPv6) addresses in `[]`.\n        -- Otherwise the name will be resolved for A and AAAA records\n        return kumo.make_queue_config {\n            protocol = {\n                smtp = {\n                    mx_list = { 'smart.host.local', { name = 'mx.example.com', addr = '10.0.0.1' }}\n                },\n            },\n        }\n    end\n    -- Otherwise, just use the defaults\n    return kumo.make_queue_config {}\nend)\n</code></pre> <p>This approach will resolve <code>A</code>/<code>AAAA</code> records but not <code>MX</code> records for the list of hosts in <code>mx_list</code>.  <code>mx_list</code> is used as the ordered list of hosts to which the message should be delivered.  It is used in place of the normal MX resolution that would have been carried out for the domain.</p> <p>With this approach, the original scheduled queue name remains as it was.</p>"},{"location":"userguide/policy/routing/#rewriting-the-queue-at-reception-time-per-message","title":"Rewriting the queue at reception time (per-message)","text":"<p>Note</p> <p>Using the <code>routing_domain</code> approach mentioned above is generally preferred to this approach, as it preserves tenant and campaign information with no additional work required on your part.</p> <p>At reception time, you can override the default scheduled queue that a message will be placed into.  The original recipient domain, campaign and tenant information are effectively ignored when using this technique.</p> <p>The example below will unconditionally assign all incoming messages to the scheduled queue for <code>my.smarthost.com</code>.</p> <p>When delivering these messages, the regular MX resolution process will be performed but using <code>my.smarthost.com</code> instead of the recipient domain.</p> <p>This must be carried out in your smtp_server_message_received or http_message_generated event handler.</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  msg:set_meta('queue', 'my.smarthost.com')\nend)\n</code></pre>"},{"location":"userguide/policy/routing/#a-note-on-ipv4-and-ipv6-literal-addresses","title":"A note on IPv4 and IPv6 literal Addresses","text":"<p>When rewriting the routing domain or queue, it is possible to specify literal addresses instead of DNS names, but those must still be compliant with the SMTP specification which requires that literal address domains be enclosed in square brackets.</p> <p>For example:</p> <ul> <li><code>[10.0.0.1]</code> is a valid IPv4 domain literal</li> <li><code>[IPv6:::1]</code> is a valid IPv6 domain literal representing the <code>::1</code> address.</li> <li><code>[::1]</code> is an invalid, non-conforming IPv6 domain literal, because it is     missing the <code>IPv6:</code> address tag prefix, but is accepted by KumoMTA and treated     as an IPv6 address. In the context of smart-hosting, this is no problem, but     in general we do not recommend using this non-conforming syntax in the envelope     or body of your messages as it may not be supported by downstream MTAs.</li> </ul> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n  msg:set_meta('queue', '[20.83.209.56]')\nend)\n</code></pre>"}]}