use serde_json::{Value, json};
use std::collections::BTreeMap;
use std::io::Write;
use utoipa::openapi::path::{Operation, ParameterIn};
use utoipa::openapi::schema::{ArrayItems, SchemaType};
use utoipa::openapi::{
    Deprecated, KnownFormat, Object, OpenApi, PathItem, RefOr, Required, Schema, SchemaFormat, Type,
};

const DISCLAIMER: &str = r#"
!!! note
    This page was generated by extracting information from a JSON Schema
    data file for the API.  It may be missing some information, or otherwise
    suggest approximate or placeholder values based on information in the
    schema file; this is due to limitations on how that data is extracted
    from the underlying Rust code and into the JSON Schema, and then again
    from there and into these docs.
"#;

fn doc_dir_for_service(service: &str) -> String {
    format!("docs/reference/http/{service}")
}

fn rewrap(text: &str, line_sep: &str) -> String {
    text.replace("\n", line_sep)
}

fn type_description(t: &Type, format: &Option<SchemaFormat>) -> String {
    fn poor_mans_to_string(s: &impl serde::Serialize) -> String {
        serde_json::to_string(s).unwrap().replace("\"", "`")
    }

    let t = poor_mans_to_string(&t);

    let format = format.as_ref().map(|f| match f {
        SchemaFormat::KnownFormat(f) => poor_mans_to_string(&f),
        SchemaFormat::Custom(f) => format!("`{f}`"),
    });

    match format {
        Some(f) => format!("{t} ({f})"),
        None => t,
    }
}

fn schema_link(
    api: &OpenApi,
    s: Option<&RefOr<Schema>>,
    schema_dir: Option<&str>,
) -> Option<String> {
    s.as_ref().and_then(|r| match r {
        RefOr::Ref(r) => {
            let schema_dir = schema_dir.unwrap_or("");
            if let Some(name) = r.ref_location.strip_prefix("#/components/schemas/") {
                Some(format!("[{name}]({schema_dir}{name}.md)"))
            } else {
                Some(r.ref_location.clone())
            }
        }
        RefOr::T(Schema::Object(obj)) => match &obj.schema_type {
            SchemaType::Array(arr) => {
                let t = type_description(&arr[0], &obj.format);

                if arr.len() == 2 && arr[1] == Type::Null {
                    // Optional
                    Some(format!("nullable {t}"))
                } else {
                    Some(format!("array of {t}"))
                }
            }
            SchemaType::AnyValue => None,
            SchemaType::Type(t) => Some(type_description(t, &obj.format)),
        },
        RefOr::T(Schema::Array(arr)) => match &arr.items {
            ArrayItems::False => None,
            ArrayItems::RefOrSchema(s) => {
                schema_link(api, Some(s), schema_dir).map(|s| format!("array of {s}"))
            }
        },
        RefOr::T(Schema::OneOf(o)) => {
            let mut nullable = false;
            let mut types = vec![];
            for i in &o.items {
                let i_resolved = resolve_schema(api, i).unwrap();
                match i_resolved {
                    Schema::Object(o) if o.schema_type == SchemaType::Type(Type::Null) => {
                        nullable = true;
                        continue;
                    }
                    _ => {
                        if let Some(s) = schema_link(api, Some(i), schema_dir) {
                            types.push(s);
                        }
                    }
                }
            }
            if types.len() == 1 {
                let nullable = if nullable { "nullable " } else { "" };
                return Some(format!("{nullable}{}", types[0]));
            }

            Some(types.join(" | "))
        }
        RefOr::T(_) => None,
    })
}

fn resolve_schema<'a>(api: &'a OpenApi, ros: &'a RefOr<Schema>) -> Option<&'a Schema> {
    match ros {
        RefOr::T(s) => Some(s),
        RefOr::Ref(r) => {
            let comp = r.ref_location.strip_prefix("#/components/schemas/")?;
            api.components
                .as_ref()
                .and_then(|components| components.schemas.get(comp))
                .and_then(|ros| resolve_schema(api, ros))
        }
    }
}

fn fixup_absolute_doc_links_on_path_page(text: &str) -> String {
    // TODO: maybe one day make this use a regex, for now, just
    // remap some known links

    let mut text = text.to_string();

    for (search, replace) in &[
        (
            "<https://docs.kumomta.com/reference/kumo/set_diagnostic_log_filter/>",
            "[kumo.set_diagnostic_log_filter](../../kumo/set_diagnostic_log_filter.md)",
        ),
        (
            "<https://docs.kumomta.com/reference/queues/>",
            "[Queues](../../queues.md)",
        ),
    ] {
        text = text.replace(search, replace);
    }

    text
}

fn generate_path_op(
    api: &OpenApi,
    service: &str,
    path: &str,
    verb: &str,
    op: &Operation,
) -> anyhow::Result<()> {
    let page_name = format!(
        "{path}_{verb}",
        path = &path[1..],
        verb = verb.to_ascii_lowercase()
    )
    .replace(|c| c == '/' || c == '-', "_");
    let output_path = format!("{}/{page_name}.md", doc_dir_for_service(service));

    let mut output = std::fs::File::create(&output_path)?;

    let schema_dir = Some("schemas/");

    writeln!(&mut output, "---")?;
    if op
        .deprecated
        .as_ref()
        .map(|d| matches!(d, Deprecated::True))
        .unwrap_or_default()
    {
        writeln!(&mut output, "status: deprecated")?;
    }
    let tags = op.tags.as_ref().map(|v| &v[..]).unwrap_or(&[]);
    let mut kcli = None;
    if tags.is_empty() {
        writeln!(&mut output, "tags: []")?;
    } else {
        writeln!(&mut output, "tags:")?;
        for t in tags {
            if let Some(k) = t.strip_prefix("kcli:") {
                kcli.replace(k);
            } else {
                writeln!(&mut output, "  - {t}")?;
            }
        }
    }
    writeln!(&mut output, "---")?;

    writeln!(&mut output, "# {verb} {path}")?;
    writeln!(&mut output)?;

    writeln!(&mut output, "{DISCLAIMER}")?;

    if let Some(text) = &op.summary {
        writeln!(
            &mut output,
            "{}",
            fixup_absolute_doc_links_on_path_page(text)
        )?;
    }

    if let Some(k) = kcli {
        writeln!(
            &mut output,
            "\nThis API endpoint is used by the [kcli {k}](../../kcli/{k}.md) command."
        )?;
    }

    if let Some(text) = &op.description {
        writeln!(
            &mut output,
            "{}",
            fixup_absolute_doc_links_on_path_page(text)
        )?;
    }

    if let Some(params) = &op.parameters {
        let has_query_params = params.iter().any(|p| p.parameter_in == ParameterIn::Query);
        if has_query_params {
            writeln!(&mut output, "\n## Query Parameters")?;

            for p in params {
                writeln!(&mut output, "  * `{name}` - {required} {type}. {description}",
                    name = &p.name,
                    required = if matches!(p.required, Required::True) { "required" } else { "optional"},
                    description = rewrap(p.description.as_deref().unwrap_or(""), "\n    "),
                    type = schema_link(api, p.schema.as_ref(), schema_dir).as_deref().unwrap_or(""),
                )?;
            }
        }
    }

    if let Some(body) = &op.request_body {
        writeln!(&mut output, "\n## Request Body")?;
        if let Some(text) = &body.description {
            writeln!(&mut output, "{text}")?;
        }

        let required = body
            .required
            .as_ref()
            .map(|r| *r == Required::True)
            .unwrap_or(false);
        let required = if required { "required" } else { "optional" };

        writeln!(&mut output, "\nThe request body is {required}.")?;

        for (ct, content) in &body.content {
            if let Some(ros) = &content.schema {
                if let Some(s) = resolve_schema(api, ros) {
                    writeln!(
                        &mut output,
                        "\nThe `Content-Type` header must be set to `{ct}`.\n"
                    )?;

                    let mut examples = vec![];
                    emit_schema(&mut output, api, s, schema_dir, &mut examples)?;
                    emit_examples(&mut output, &mut examples)?;
                }
            }

            if let Some(ex) = &content.example {
                writeln!(&mut output, "\n## Example\n```json")?;
                serde_json::to_writer_pretty(&mut output, &ex)?;
                writeln!(&mut output, "\n```")?;
            }
        }
    }

    if !op.responses.responses.is_empty() {
        writeln!(&mut output, "\n## Responses")?;

        for (status, resp) in &op.responses.responses {
            match resp {
                RefOr::T(resp) => {
                    writeln!(&mut output, "### Status {status}\n{}\n", &resp.description)?;

                    for (ct, content) in &resp.content {
                        writeln!(&mut output, "\n`Content-Type: {ct}`\n")?;
                        if let Some(ros) = &content.schema {
                            if let Some(s) = resolve_schema(api, ros) {
                                let mut examples = vec![];
                                emit_schema(&mut output, api, s, schema_dir, &mut examples)?;
                                emit_examples(&mut output, &mut examples)?;
                            }
                        }

                        if let Some(ex) = &content.example {
                            writeln!(&mut output, "\n#### Example\n```json")?;
                            serde_json::to_writer_pretty(&mut output, &ex)?;
                            writeln!(&mut output, "\n```")?;
                        }
                    }
                }
                RefOr::Ref(_) => unreachable!(),
            }
        }
    }

    Ok(())
}

fn generate_path(api: &OpenApi, service: &str, path: &str, item: &PathItem) -> anyhow::Result<()> {
    for (verb, op) in &[
        ("GET", &item.get),
        ("PUT", &item.put),
        ("DELETE", &item.delete),
        ("POST", &item.post),
        ("OPTIONS", &item.options),
        ("HEAD", &item.head),
        ("PATCH", &item.patch),
        ("TRACE", &item.trace),
    ] {
        if let Some(op) = op {
            generate_path_op(api, service, path, verb, op)?;
        }
    }
    Ok(())
}

fn schema_title(s: &Schema) -> Option<&str> {
    match s {
        Schema::Array(a) => a.title.as_deref(),
        Schema::Object(o) => o.title.as_deref(),
        Schema::OneOf(o) => o.title.as_deref(),
        Schema::AllOf(o) => o.title.as_deref(),
        Schema::AnyOf(_) => None,
        _ => None,
    }
}

fn schema_description(s: &Schema) -> Option<&str> {
    match s {
        Schema::Array(a) => a.description.as_deref(),
        Schema::Object(o) => o.description.as_deref(),
        Schema::OneOf(o) => {
            if o.description.is_some() {
                return o.description.as_deref();
            }
            o.items.first().and_then(|ros| match ros {
                RefOr::Ref(r) => Some(r.description.as_str()),
                RefOr::T(s) => schema_description(s),
            })
        }
        Schema::AllOf(o) => o.description.as_deref(),
        Schema::AnyOf(o) => o.description.as_deref(),
        _ => None,
    }
}

fn ref_or_schema_description<'a>(api: &'a OpenApi, r: &'a RefOr<Schema>) -> Option<&'a str> {
    if let RefOr::Ref(r) = r {
        if !r.description.is_empty() {
            return Some(&r.description);
        }
    }
    schema_description(resolve_schema(api, r).expect("ref to resolve"))
}

fn schema_format_example(f: &SchemaFormat) -> Option<Value> {
    Some(match f {
        SchemaFormat::KnownFormat(KnownFormat::Uuid) => {
            "9511a32e-66f8-42aa-b151-ccb176df47d9".into()
        }
        SchemaFormat::KnownFormat(KnownFormat::Email | KnownFormat::IdnEmail) => {
            "user@example.com".into()
        }
        SchemaFormat::KnownFormat(KnownFormat::Hostname | KnownFormat::IdnHostname) => {
            "example.com".into()
        }
        SchemaFormat::KnownFormat(KnownFormat::Ipv4) => "10.0.0.1".into(),
        SchemaFormat::KnownFormat(KnownFormat::Ipv6) => "::1".into(),
        SchemaFormat::KnownFormat(KnownFormat::Time) => "12:00:00Z".into(),
        SchemaFormat::KnownFormat(KnownFormat::Date) => "1990-12-31".into(),
        SchemaFormat::KnownFormat(KnownFormat::DateTime) => "1990-12-31T23:59:60Z".into(),
        SchemaFormat::KnownFormat(KnownFormat::Duration) => "PT1S".into(),
        SchemaFormat::KnownFormat(KnownFormat::Password) => "secret".into(),
        SchemaFormat::KnownFormat(KnownFormat::Uri | KnownFormat::UriReference) => {
            "http://example.com/some/path".into()
        }
        SchemaFormat::KnownFormat(KnownFormat::Float | KnownFormat::Double) => 4.2.into(),
        SchemaFormat::KnownFormat(
            KnownFormat::Int8
            | KnownFormat::Int16
            | KnownFormat::Int32
            | KnownFormat::Int64
            | KnownFormat::UInt8
            | KnownFormat::UInt16
            | KnownFormat::UInt32
            | KnownFormat::UInt64,
        ) => 42.into(),
        SchemaFormat::KnownFormat(
            KnownFormat::Byte
            | KnownFormat::Binary
            | KnownFormat::Iri
            | KnownFormat::IriReference
            | KnownFormat::UriTemplate
            | KnownFormat::JsonPointer
            | KnownFormat::RelativeJsonPointer
            | KnownFormat::Regex,
        )
        | SchemaFormat::Custom(_) => return None,
    })
}

fn type_example(t: &Type) -> Option<Value> {
    Some(match t {
        Type::String => "string".into(),
        Type::Integer => 42.into(),
        Type::Number => 4.2.into(),
        Type::Boolean => false.into(),
        Type::Null => Value::Null,
        Type::Object => return None,
        Type::Array => return None,
    })
}

fn schema_type_example(f: &SchemaType) -> Option<Value> {
    match f {
        SchemaType::Type(t) => type_example(t),
        SchemaType::Array(arr) => type_example(&arr[0]),
        SchemaType::AnyValue => None,
    }
}

fn schema_examples(api: &OpenApi, s: &Schema) -> Vec<Value> {
    let mut result = vec![];

    match s {
        Schema::Array(a) => {
            if let Some(ex) = &a.example {
                result.push(ex.clone());
            }
            result.append(&mut a.examples.clone());

            if result.is_empty() {
                match &a.items {
                    ArrayItems::RefOrSchema(ros) => {
                        let ele_type = resolve_schema(api, ros).expect("resolve schema");
                        result.push(schema_examples(api, ele_type).into());
                    }
                    ArrayItems::False => {
                        result.push(json!([]));
                    }
                }
            }
        }
        Schema::Object(a) => {
            if let Some(ex) = &a.example {
                result.push(ex.clone());
            }
            result.append(&mut a.examples.clone());

            if result.is_empty() {
                if let Some(v) = a.enum_values.as_ref().and_then(|ev| ev.first()) {
                    result.push(v.clone());
                } else if let Some(ex) = a.format.as_ref().and_then(schema_format_example) {
                    result.push(ex);
                } else if let Some(ex) = schema_type_example(&a.schema_type) {
                    result.push(ex);
                } else {
                    let mut ex = json!({});

                    for (k, v) in &a.properties {
                        if let Some(s) = resolve_schema(api, v) {
                            if let Some(first) = interesting_example(&schema_examples(api, s)) {
                                ex[k] = first.clone();
                            }
                        }
                    }

                    result.push(ex);
                }
            }
        }
        Schema::OneOf(a) => {
            if let Some(ex) = &a.example {
                result.push(ex.clone());
            }
            result.append(&mut a.examples.clone());

            for i in &a.items {
                let s = resolve_schema(api, i).unwrap();
                result.append(&mut schema_examples(api, s));
            }

            if result.is_empty() {
                if let Some(def) = &a.default {
                    result.push(def.clone());
                }
            }
        }
        Schema::AllOf(a) => {
            if let Some(ex) = &a.example {
                result.push(ex.clone());
            }
            result.append(&mut a.examples.clone());
        }
        Schema::AnyOf(a) => {
            if let Some(ex) = &a.example {
                result.push(ex.clone());
            }
            result.append(&mut a.examples.clone());
        }
        _ => {}
    }

    result
}

fn emit_object(
    output: &mut impl Write,
    api: &OpenApi,
    obj: &Object,
    example_values: &mut BTreeMap<String, Vec<Value>>,
    schema_dir: Option<&str>,
) -> anyhow::Result<()> {
    for (k, v) in &obj.properties {
        let required = obj
            .required
            .iter()
            .find(|&n| n == k)
            .map(|_| "required")
            .unwrap_or("optional");
        let s = resolve_schema(api, v).expect("schema to resolve");
        let description = ref_or_schema_description(api, v).unwrap_or("");

        writeln!(
            output,
            "\n  * `{k}` - {required} {type}. {description}",
            description = rewrap(description, "\n    "),
            type = schema_link(api, Some(v), schema_dir).as_deref().unwrap_or(""),
        )?;

        let examples = schema_examples(api, s);

        if !examples.is_empty() {
            example_values.insert(k.clone(), examples);
        } else {
            eprintln!("no examples for {k}");
        }
    }

    // FIXME: additionalProperties

    Ok(())
}

/// Try to avoid using `null` as the example if we can use anything else
fn interesting_example(examples: &[Value]) -> Option<Value> {
    if let Some(v) = examples.iter().find(|v| **v != Value::Null) {
        return Some(v.clone());
    }
    examples.first().cloned()
}

fn compute_examples(example_values: &mut BTreeMap<String, Vec<Value>>) -> Vec<Value> {
    let mut example_object = json!({});
    for (k, list) in example_values {
        if let Some(v) = interesting_example(&list) {
            example_object[k] = v.clone();
        }
    }
    vec![example_object]
}

fn emit_schema(
    output: &mut impl Write,
    api: &OpenApi,
    schema: &Schema,
    schema_dir: Option<&str>,
    examples: &mut Vec<Value>,
) -> anyhow::Result<()> {
    if let Some(title) = schema_title(schema) {
        writeln!(output, "# {title}")?;
    }
    if let Some(description) = schema_description(schema) {
        writeln!(output, "{description}")?;
    }
    writeln!(output)?;

    match schema {
        Schema::Object(obj) => match &obj.enum_values {
            Some(enum_values) => {
                writeln!(
                    output,
                    "This type is an enum with the following allowed values:\n"
                )?;
                for v in enum_values.iter() {
                    writeln!(output, "  * `{v}`")?;
                }
            }
            None => match &obj.schema_type {
                SchemaType::Type(Type::String) => {
                    writeln!(output, "This is a string value.")?;
                }
                SchemaType::Type(Type::Integer) => {
                    writeln!(output, "This is an integer value.")?;
                }
                SchemaType::Type(Type::Number) => {
                    writeln!(output, "This is a numeric value.")?;
                }
                SchemaType::Type(Type::Boolean) => {
                    writeln!(output, "This is a boolean value.")?;
                }
                SchemaType::Type(Type::Null) => {
                    writeln!(output, "This is a null value.")?;
                }
                SchemaType::Type(Type::Array) => {
                    writeln!(output, "This is an array value.")?;
                }
                SchemaType::Type(Type::Object) => {
                    if obj.properties.is_empty() {
                        writeln!(output, "This is an object value, with no properties.")?;
                    } else {
                        writeln!(
                            output,
                            "This is an object value, with the following properties:\n"
                        )?;
                        let mut example = BTreeMap::new();
                        emit_object(output, api, &obj, &mut example, schema_dir)?;
                        examples.append(&mut compute_examples(&mut example));
                    }
                }
                SchemaType::AnyValue => {
                    writeln!(output, "This can have any value.")?;
                }
                SchemaType::Array(arr) => {
                    let t = &arr[0];
                    let t = serde_json::to_string(&t)?;
                    writeln!(
                        output,
                        "This is an array of {} values.",
                        t.replace("\"", "`")
                    )?;
                }
            },
        },
        Schema::Array(arr) => {
            match &arr.items {
                ArrayItems::RefOrSchema(ros) => {
                    writeln!(
                        output,
                        "This is an array of type {}.",
                        schema_link(api, Some(ros), schema_dir)
                            .as_deref()
                            .unwrap_or("unknown")
                    )?;
                }
                ArrayItems::False => unimplemented!(),
            }

            match (&arr.min_items, &arr.max_items) {
                (Some(min), Some(max)) if min == max => {
                    writeln!(output, "It must consist of exactly {min} elements.")?;
                }
                (Some(min), Some(max)) => {
                    writeln!(
                        output,
                        "It must consist of at least {min} elements but no more than {max} elements."
                    )?;
                }
                (Some(min), None) => {
                    writeln!(output, "It must consist of at least {min} elements.")?;
                }
                (None, Some(max)) => {
                    writeln!(output, "It must consist of no more than {max} elements.")?;
                }
                (None, None) => {
                    writeln!(output, "There are no constraints on the size of the array.")?;
                }
            }
        }
        Schema::OneOf(oneof) => {
            writeln!(output, "\nCan be one of the following shapes of data:")?;

            for (idx, item) in oneof.items.iter().enumerate() {
                writeln!(output, "\n## Option {}", idx + 1)?;

                match item {
                    RefOr::Ref(_) => {
                        writeln!(
                            output,
                            "A value of type {}",
                            schema_link(api, Some(item), schema_dir)
                                .as_deref()
                                .unwrap_or("unknown")
                        )?;
                    }
                    RefOr::T(s) => {
                        emit_schema(output, api, s, schema_dir, examples)?;
                    }
                }
            }
        }
        Schema::AllOf(allof) => {
            writeln!(
                output,
                "This is an object value, with the following properties:\n"
            )?;
            let mut example = BTreeMap::new();
            for item in &allof.items {
                match item {
                    RefOr::Ref(_r) => {
                        writeln!(
                            output,
                            "  * The fields allowed by {}",
                            schema_link(api, Some(item), schema_dir)
                                .as_deref()
                                .unwrap_or("unknown")
                        )?;
                    }
                    RefOr::T(Schema::Object(o)) => {
                        emit_object(output, api, o, &mut example, schema_dir)?;
                    }
                    RefOr::T(_) => {
                        writeln!(output, "  * FIXME: unhandled type information in doc build")?;
                    }
                }
            }
            examples.append(&mut compute_examples(&mut example));
        }
        _ => {
            writeln!(
                output,
                "FIXME: an unknown type of Schema that is not yet supported in the doc build"
            )?;
        }
    }

    examples.append(&mut schema_examples(api, schema));
    Ok(())
}

fn emit_examples(output: &mut impl Write, examples: &mut Vec<Value>) -> anyhow::Result<()> {
    if !examples.is_empty() {
        writeln!(output, "\n### Examples")?;

        examples.sort_by_key(|ex| serde_json::to_string(&ex).unwrap());
        examples.dedup();

        for ex in examples {
            writeln!(output, "```json")?;
            serde_json::to_writer_pretty(&mut *output, &ex)?;
            writeln!(output, "\n```")?;
        }
    }

    Ok(())
}

fn generate_component(
    api: &OpenApi,
    service: &str,
    type_name: &str,
    schema: &RefOr<Schema>,
) -> anyhow::Result<()> {
    let output_path = format!("{}/schemas/{type_name}.md", doc_dir_for_service(service));

    let mut output = std::fs::File::create(&output_path)?;
    writeln!(&mut output, "# {type_name}")?;
    writeln!(&mut output, "{DISCLAIMER}")?;

    match schema {
        RefOr::Ref(r) => {
            if let Some(name) = r.ref_location.strip_prefix("#/components/schemas/") {
                writeln!(
                    &mut output,
                    "The `{type_name}` type is an alias for [{name}]({name}.md)"
                )?;
            }
            Ok(())
        }
        RefOr::T(s) => {
            let mut examples = vec![];
            emit_schema(&mut output, api, s, None, &mut examples)?;
            emit_examples(&mut output, &mut examples)?;
            Ok(())
        }
    }
}

fn generate(api: &OpenApi) -> anyhow::Result<()> {
    let service = &api.info.title;

    std::fs::create_dir_all(doc_dir_for_service(service))?;

    for (path, item) in &api.paths.paths {
        generate_path(api, service, path, item)?;
    }

    if let Some(components) = &api.components {
        let schema_dir = format!("{}/schemas", doc_dir_for_service(service));
        std::fs::create_dir_all(&schema_dir)?;
        std::fs::write(
            format!("{schema_dir}/_index.md"),
            format!(
                r#"
# API Types for {service} service

The following types are defined for the {service} service:

## Types {{ data-search-exclude }}

"#
            ),
        )?;

        for (name, schema) in &components.schemas {
            generate_component(api, service, name, schema)?;
        }
    }

    Ok(())
}

fn main() -> anyhow::Result<()> {
    for path in &["docs/reference/kumod.openapi.json"] {
        let data = std::fs::read_to_string(path)?;
        let api: OpenApi = serde_json::from_str(&data)?;
        generate(&api)?;
    }
    Ok(())
}
