searchState.loadedDescShard("dns_resolver", 0, "AggregateResolver aggregates the results from multiple …\nA DNS Name pending resolution, plus an optional port number\nHelper to reason about a domain name string. It can either …\nA literal IP address (no port), or socket address (with …\nMaximum legal length of a domain name\nA domain name\nRFC 6698, DNS-Based Authentication for TLS\nAppends the <code>domain</code> to <code>self</code>, making the new <code>Name</code> an FQDN\nAppends the label to the end of this name\nAppends <code>other</code> to <code>self</code>, returning a new <code>Name</code>\nTrims off the first part of the name, to help with …\nBinary data for validating the cert, see other members to …\nSpecifies the provided association that will be used to …\nCase insensitive comparison, see <code>Name::cmp_case</code> for case …\nCase sensitive comparison\nEmits the canonical version of the name to the encoder.\nWrites the labels, as lower case, to the encoder\nCompares the Names, in a case sensitive manner\nNon-FQDN-aware case-insensitive comparison\nNon-FQDN-aware case-sensitive comparison\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWill convert the string to a name only allowing ascii as …\nCreates a new Name from the specified labels\nUses the Name::from_utf8 conversion on this string, see …\nFirst attempts to decode via <code>from_utf8</code>, if that fails IDNA …\nWill convert the string to a name using IDNA, punycode, to …\nIf the provided parameter ends with <code>:PORT</code> and <code>PORT</code> is a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a name to a wildcard, by replacing the first …\nReturns whether the length of the labels, in bytes is 0. …\nReturns true if the name is a fully qualified domain name.\nReturns true if the <code>Name</code> is either localhost or in the …\nReturns true if there are no labels, i.e. it’s empty.\nDNSSEC verified\nTrue if the first label of this name is the wildcard, i.e. …\nReturns an iterator over the labels\nreturns the length in bytes of the labels. ‘.’ counts …\nSpecifies how the certificate association is presented\nCreate a new domain::Name, i.e. label\nConstructs a new TLSA\nReturns the number of labels in the name, discounting <code>*</code>.\nattempts to parse a name such as <code>&quot;example.com.&quot;</code> or …\nConverts a *.arpa Name in a PTR record back into an IpNet …\nPrepends the label to the beginning of this name\nRandomize the case of ASCII alpha characters in a name\nparses the chain of labels this has a max of 255 octets, …\nReturns the list of resolve MX hosts in <em>reverse</em> preference …\nResolves TLSA records for a destination name and port …\nReturns the root label, i.e. no labels, can probably make …\nSpecifies which part of the TLS certificate presented by …\nSpecifies this name is a fully qualified domain name\nConverts this name into an ascii safe string.\nCreates a new Name with all labels lowercased\nConverts the Name labels to the utf8 String form.\nTrims to the number of labels specified\nAdd multiple separate TXT records for the specified domain\nreturns true if the name components of self are all …\nsame as <code>zone_of</code> allows for case sensitive call")