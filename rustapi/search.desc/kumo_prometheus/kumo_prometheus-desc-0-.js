searchState.loadedDescShard("kumo_prometheus", 0, "This trait enables having prunable and non-pruning value …\nEither a Counter or Gauge with a specific name, where …\n<code>macro_rules!</code> implementation of <code>count_tts</code>. Source: …\ncounter_bundle declares a struct holding a bundle of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nResolve an already-existing counter for the given key, or …\nResolve an already-existing counter for the given key, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUsed to declare a label key struct suitable for use in …\nGiven a new strong AtomicCounter reference, return Self …\nIndicate whether this type of value requires pruning the …\nRegister a set of Counters, values that are only allowed …\nRegister a set of Gauges, values that are allowed to …\nresolve this entry to an AtomicCounter instance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a quantile (eg: p90 would be q=0.9), returns the …\nKeeps track of all streaming collector instances\nReturns the argument unchanged.\nGet the Registry singleton, and spawn the pruning task if …\nCalls <code>U::from(self)</code>.\nPrune any stale entries from this collector\nRegister a new collector\nStream chunks in our json format, as chunks of text\nProduce a stream of String chunks that represent all known …\nStream chunks of text in prometheus text exposition format\nProduce a stream of String chunks that represent all known …")