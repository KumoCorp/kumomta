<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `dns_resolver` crate."><title>dns_resolver - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="dns_resolver" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../dns_resolver/index.html">dns_<wbr>resolver</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>dns_resolver</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/dns_resolver/lib.rs.html#1-1319">Source</a> </span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AggregateResolver.html" title="struct dns_resolver::AggregateResolver">Aggregate<wbr>Resolver</a></dt><dd>AggregateResolver aggregates the results from multiple
resolver instances.
This is most useful when you want to overlay or otherwise
force in test data to take precedence over real resolver
results.  In that situation, you’d push a TestResolver
ahead of the HickoryResolver that you want to use for
real DNS resolution.</dd><dt><a class="struct" href="struct.HickoryResolver.html" title="struct dns_resolver::HickoryResolver">Hickory<wbr>Resolver</a></dt><dt><a class="struct" href="struct.IpDisplay.html" title="struct dns_resolver::IpDisplay">IpDisplay</a></dt><dt><a class="struct" href="struct.MailExchanger.html" title="struct dns_resolver::MailExchanger">Mail<wbr>Exchanger</a></dt><dt><a class="struct" href="struct.Name.html" title="struct dns_resolver::Name">Name</a></dt><dd>A domain name</dd><dt><a class="struct" href="struct.TLSA.html" title="struct dns_resolver::TLSA">TLSA</a></dt><dd><a href="https://tools.ietf.org/html/rfc6698#section-2.1">RFC 6698, DNS-Based Authentication for TLS</a></dd><dt><a class="struct" href="struct.TestResolver.html" title="struct dns_resolver::TestResolver">Test<wbr>Resolver</a></dt><dt><a class="struct" href="struct.UnboundResolver.html" title="struct dns_resolver::UnboundResolver">Unbound<wbr>Resolver</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.DnsError.html" title="enum dns_resolver::DnsError">DnsError</a></dt><dt><a class="enum" href="enum.DomainClassification.html" title="enum dns_resolver::DomainClassification">Domain<wbr>Classification</a></dt><dd>Helper to reason about a domain name string.
It can either be name that needs to be resolved, or some kind
of IP literal.
We also allow for an optional port number to be present in
the domain name string.</dd><dt><a class="enum" href="enum.ResolvedMxAddresses.html" title="enum dns_resolver::ResolvedMxAddresses">Resolved<wbr>MxAddresses</a></dt></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Resolver.html" title="trait dns_resolver::Resolver">Resolver</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.fully_qualify.html" title="fn dns_resolver::fully_qualify">fully_<wbr>qualify</a></dt><dt><a class="fn" href="fn.get_mx_negative_ttl.html" title="fn dns_resolver::get_mx_negative_ttl">get_<wbr>mx_<wbr>negative_<wbr>ttl</a></dt><dt><a class="fn" href="fn.get_mx_timeout.html" title="fn dns_resolver::get_mx_timeout">get_<wbr>mx_<wbr>timeout</a></dt><dt><a class="fn" href="fn.get_resolver.html" title="fn dns_resolver::get_resolver">get_<wbr>resolver</a></dt><dt><a class="fn" href="fn.has_colon_port.html" title="fn dns_resolver::has_colon_port">has_<wbr>colon_<wbr>port</a></dt><dd>If the provided parameter ends with <code>:PORT</code> and <code>PORT</code> is a valid u16,
then crack apart and return the LABEL and PORT number portions.
Otherwise, returns None</dd><dt><a class="fn" href="fn.ip_lookup.html" title="fn dns_resolver::ip_lookup">ip_<wbr>lookup</a></dt><dt><a class="fn" href="fn.ipv4_lookup.html" title="fn dns_resolver::ipv4_lookup">ipv4_<wbr>lookup</a></dt><dt><a class="fn" href="fn.ipv6_lookup.html" title="fn dns_resolver::ipv6_lookup">ipv6_<wbr>lookup</a></dt><dt><a class="fn" href="fn.ptr_host.html" title="fn dns_resolver::ptr_host">ptr_<wbr>host</a></dt><dt><a class="fn" href="fn.reconfigure_resolver.html" title="fn dns_resolver::reconfigure_resolver">reconfigure_<wbr>resolver</a></dt><dt><a class="fn" href="fn.resolve_a_or_aaaa.html" title="fn dns_resolver::resolve_a_or_aaaa">resolve_<wbr>a_<wbr>or_<wbr>aaaa</a></dt><dt><a class="fn" href="fn.resolve_dane.html" title="fn dns_resolver::resolve_dane">resolve_<wbr>dane</a></dt><dd>Resolves TLSA records for a destination name and port according to
<a href="https://datatracker.ietf.org/doc/html/rfc6698#appendix-B.2">https://datatracker.ietf.org/doc/html/rfc6698#appendix-B.2</a></dd><dt><a class="fn" href="fn.reverse_ip.html" title="fn dns_resolver::reverse_ip">reverse_<wbr>ip</a></dt><dt><a class="fn" href="fn.set_mx_concurrency_limit.html" title="fn dns_resolver::set_mx_concurrency_limit">set_<wbr>mx_<wbr>concurrency_<wbr>limit</a></dt><dt><a class="fn" href="fn.set_mx_negative_cache_ttl.html" title="fn dns_resolver::set_mx_negative_cache_ttl">set_<wbr>mx_<wbr>negative_<wbr>cache_<wbr>ttl</a></dt><dt><a class="fn" href="fn.set_mx_timeout.html" title="fn dns_resolver::set_mx_timeout">set_<wbr>mx_<wbr>timeout</a></dt></dl></section></div></main></body></html>